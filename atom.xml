<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AcFunction&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-17T12:47:00.003Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AcFunction</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「AGC036B」Do Not Duplicate</title>
    <link href="http://yoursite.com/2019/09/06/AGC036B/"/>
    <id>http://yoursite.com/2019/09/06/AGC036B/</id>
    <published>2019-09-06T12:48:10.000Z</published>
    <updated>2019-10-17T12:47:00.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给一个长度为 $n$ 的序列 $a_i$ 和一个数 $k$ 。现在把 $a$ 序列重复 $k$ 次生成一个数列 $b$ ，然后从第一位开始往一个栈中加入 $b_i$ 。如果这个栈里存在元素与 $b_i$ 相等那么一直 $\text{pop}$ 直到把那个数弹掉然后不加入新数；否则 $\text{push}$ $b_i$ 入栈。求全部操作完之后栈中的元素。</p><p>数据范围：$n \leq 2 \times 10^5, k \leq 10^{12}, a_i \leq 2 \times 10^5$   </p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>把 $a_i$ 排在一个圆周上，定义 $nxt_i = j$ 表示沿着顺时针方向第一个 $j$ 使得 $a_i=a_j$ 。</p><p>可以发现，假设目前栈中第一个元素是 $a_x = y$ ，那么下一次这个栈被整体清空是加入了<br>$nxt_x$ 之后。特别的，如果 $nxt_x = x$ ，那么就是再加一遍整个 $a_i$ 之后再次清空。</p><p>自然地可以想象 $x$ 向 $nxt_x +1$ 加一条边，表示 $x$ 之后下一个第一个下标会是 $nxt_x + 1$。这样的得到的图会形成一个一个环。也就是说，加了若干次 $a$ 后，全部都被清空，回到原点，也就是循环节。</p><p>我们可以把 $k$ 模上循环节，然后再对余下的不完整的部分直接模拟跳环的过程。如果一个时刻所加的数总数超出了 $k$ 就直接能够模拟一遍得到答案。</p><p>由于最后跳环每次最多会跳出去 $n+1$ 个点，并且循环节长度不会超过 $n(n+1)$ ，所以最后最多跳 $n$ 次以及统计答案时最多只需要考虑 $n$ 个点。所以时间复杂度为 $O(n)$ </p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-09-04 21:48:14</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ldb long double </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pil pair <span class="meta-string">&lt;int, ll&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pli pair <span class="meta-string">&lt;ll, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair <span class="meta-string">&lt;ll, ll&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> All(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf push_front</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms0(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms1(x) memset(x, -1, sizeof(x))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oiu cerr &lt;&lt; <span class="meta-string">"Yes!"</span> &lt;&lt; endl; </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">": "</span> &lt;&lt; x &lt;&lt; endl;  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printarr</span><span class="params">(T a[], <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b &gt; e) <span class="keyword">return</span> ; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &lt; e; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a[e] &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">chkmax</span><span class="params">(T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? x = y, <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">chkmin</span><span class="params">(T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y ? x = y, <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5001000</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> nxt[N], fir[N], pos[N], a[N], ans[N], cnt, len[N];</span><br><span class="line">ll k;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %lld"</span>, &amp;n, &amp;k); k *= n; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]); </span><br><span class="line">    <span class="keyword">if</span>(!fir[a[i]]) &#123;</span><br><span class="line">      fir[a[i]] = i;</span><br><span class="line">      pos[a[i]] = i;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nxt[pos[a[i]]] = i; </span><br><span class="line">      pos[a[i]] = i;  </span><br><span class="line">    &#125;</span><br><span class="line">    nxt[i] = fir[a[i]]; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nxt[i] &gt; i) &#123;</span><br><span class="line">      len[i] = nxt[i] - i + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> len[i] = n - (i - nxt[i] - <span class="number">1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> u = <span class="number">1</span>; ll num = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    num += len[u]; </span><br><span class="line">    u = nxt[u] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; n) u -= n;  </span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">1</span>) <span class="keyword">break</span> ; </span><br><span class="line">  &#125;</span><br><span class="line">  k = k % num; </span><br><span class="line">  <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  u = <span class="number">1</span>; num = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">// k *= n; </span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    num += len[u];</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= k) &#123;</span><br><span class="line">      num -= len[u]; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = u; j &lt;= u + k - num - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = j; <span class="keyword">if</span>(t &gt; n) t -= n; </span><br><span class="line">        ans[++cnt] = a[t]; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) </span><br><span class="line">        pos[ans[i]] = fir[ans[i]] = nxt[i] = <span class="number">0</span>; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!fir[ans[i]]) &#123;</span><br><span class="line">          fir[ans[i]] = i;</span><br><span class="line">          pos[ans[i]] = i;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          nxt[pos[ans[i]]] = i;   </span><br><span class="line">          pos[ans[i]] = i;  </span><br><span class="line">        &#125;</span><br><span class="line">        nxt[i] = fir[ans[i]]; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> p = <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">while</span>(p &lt;= cnt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nxt[p] &gt; p) &#123;</span><br><span class="line">          p = nxt[p] + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[p]); </span><br><span class="line">          p++; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    u = nxt[u] + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(u &gt; n) u -= n; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给一个长度为 $n$ 的序列 $a_i$ 和一个数 $k$ 。现在把 $a$ 序列重复 $k$ 次生成一个数列 $b$ ，然后从第一位开始往一个栈中加入 $b_i$ 。如果这个栈里存在元素与 $b_i$ 相等那么一直 $\text{pop}$ 直到把那个数弹掉然后不加入新数；否则 $\text{push}$ $b_i$ 入栈。求全部操作完之后栈中的元素。&lt;/p&gt;
&lt;p&gt;数据范围：$n \leq 2 \times 10^5, k \leq 10^{12}, a_i \leq 2 \times 10^5$   &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维题" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「AGC037B」RGB Balls</title>
    <link href="http://yoursite.com/2019/09/06/AGC037B/"/>
    <id>http://yoursite.com/2019/09/06/AGC037B/</id>
    <published>2019-09-06T12:47:58.000Z</published>
    <updated>2019-09-07T02:45:12.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有 $3n$ 个球摆成一列，其中有 $\text{RGB}$ 每种颜色各 $n$ 个。现在第 $i$ 个人有三个颜色互不相同的球，并且在序列中的位置从小到大是 $a_i &lt;b_i &lt; c_i$ 。求在保证 $\sum c_i - a_i$ 最小的情况下有多少种分球方案。答案对 $998244353$ 取模。</p><p>数据范围：$n \leq 10^5$ </p><a id="more"></a> <h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>自然地第一步要想的是如何满足 $\sum c_i - a_i$ 最小。</p><p>我们换一个角度来分析它。把问题看成从前往后把每一个球给一个人。那么对于每一个人，他对答案产生的贡献是他手中已经分了球但是还没有凑全三个球的时刻数。</p><p>于是便可以贪心的最小化每一个时刻手中拿了球但是没有拿全三个的人数。</p><p>对于一个时刻，不妨设目前球数最多的是 $\text{R}$ ，其次是 $\text{G}$ ，然后是 $\text{B}$ 。那么此时最优的情况一定是若干组 $\text{RGB}$ 加上若干组 $\text{RG}$ 再加上若干组 $\text{R}$ 。于是便可以解决 $\sum c_i - a_i$ 最小的问题。</p><p>方案数也能够求出。每次新加一个球的时候看他是原来的第几大和现在的第几大。方案数相应的乘上能够放进的组的个数即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ldb long double </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pil pair <span class="meta-string">&lt;int, ll&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pli pair <span class="meta-string">&lt;ll, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair <span class="meta-string">&lt;ll, ll&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> All(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf push_front</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms0(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms1(x) memset(x, -1, sizeof(x))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oye cerr &lt;&lt; <span class="meta-string">"Yes!"</span> &lt;&lt; endl; </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">": "</span> &lt;&lt; x &lt;&lt; endl;  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printarr</span><span class="params">(T a[], <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b &gt; e) <span class="keyword">return</span> ; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &lt; e; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a[e] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">chkmax</span><span class="params">(T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? x = y, <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">chkmin</span><span class="params">(T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y ? x = y, <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1001000</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x += y) &gt;= mod ? x - mod : x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; </span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">3</span>];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); n *= <span class="number">3</span>;  </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">3</span>], y[<span class="number">3</span>]; </span><br><span class="line">    x[<span class="number">0</span>] = cnt[<span class="number">0</span>]; x[<span class="number">1</span>] = cnt[<span class="number">1</span>], x[<span class="number">2</span>] = cnt[<span class="number">2</span>]; </span><br><span class="line">    sort(x, x + <span class="number">3</span>); </span><br><span class="line">    <span class="keyword">int</span> op = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'R'</span>) op = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'G'</span>) op = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'B'</span>) op = <span class="number">2</span>; </span><br><span class="line">    cnt[op]++; </span><br><span class="line">    y[<span class="number">0</span>] = cnt[<span class="number">0</span>]; y[<span class="number">1</span>] = cnt[<span class="number">1</span>], y[<span class="number">2</span>] = cnt[<span class="number">2</span>]; </span><br><span class="line">    sort(y, y + <span class="number">3</span>); </span><br><span class="line">    <span class="keyword">if</span>(y[<span class="number">2</span>] != x[<span class="number">2</span>]) &#123;</span><br><span class="line">      ; <span class="comment">// ans = 1ll * ans * x[2] % mod; </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y[<span class="number">0</span>] != x[<span class="number">0</span>]) &#123;</span><br><span class="line">      ans = <span class="number">1l</span>l * ans * (x[<span class="number">1</span>] - x[<span class="number">0</span>]) % mod; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ans = <span class="number">1l</span>l * ans * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) % mod; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">3</span>; i++) ans = <span class="number">1l</span>l * ans * i % mod; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;有 $3n$ 个球摆成一列，其中有 $\text{RGB}$ 每种颜色各 $n$ 个。现在第 $i$ 个人有三个颜色互不相同的球，并且在序列中的位置从小到大是 $a_i &amp;lt;b_i &amp;lt; c_i$ 。求在保证 $\sum c_i - a_i$ 最小的情况下有多少种分球方案。答案对 $998244353$ 取模。&lt;/p&gt;
&lt;p&gt;数据范围：$n \leq 10^5$ &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维题" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>CF547E Mike and Friends</title>
    <link href="http://yoursite.com/2019/08/23/CF547E/"/>
    <id>http://yoursite.com/2019/08/23/CF547E/</id>
    <published>2019-08-23T04:40:18.000Z</published>
    <updated>2019-08-23T04:44:11.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定 $ n $ 个串  $ s_1, s_2, \cdots, s_n $ 和 $q$ 个询问，每次查询 $ s_i $ 一共在 $ s_l, s_{l+1}, \cdots, s_r $ 出现了多少次。</p><p>$ n, q, \sum \limits_{i=1}^{n} |s_i| \leq 2 \times 10^5 $。</p><a id="more"></a> <h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这里有一个后缀数组的做法。</p><ul><li>把 $ n $ 个串依次连在一起，相邻两个之间用一个 <code>#</code> 隔开。得到一个大串 $ \mathtt{S} $ 。  </li><li>我们可以简单地求出第 $ i $ 个串 $ s_i $ 的长度 $len_i$，在 $ \mathtt{S} $ 中第一个字母所在的位置 $pos_i$ 以及 $ \mathtt{S} $ 的后缀数组。  </li><li>对于一个询问，假设询问串是 $s_k$，他在一个位置 $p$ 出现当且仅当从 $p$ 开始的后缀与从 $pos_k$ 开始的后缀的 $\mathtt{LCP} $ 的长度 $\ge len_k $ 。</li><li>众所周知，两个后缀 $i, j (\mathtt{rk[i]} &lt; \mathtt{rk[j]})$ 的 $ \mathtt{LCP} $ 就是 $\min\limits_{\mathtt{rk[i] + 1} \le x \le \mathtt{rk[j]}} \{\mathtt{height[x]}\}$ ，也就是一段区间的最小值。</li><li>对于每个 $k$ ，我们可以简单地通过二分来找到最长的一段包含 $\mathtt{rk[k]}$ 的区间 $[L_k, R_k]$ 使得这一段区间中的 $\mathtt{height[i]}$ 最小值 $ \ge len_i$ 。</li><li>那么如果一个后缀的前缀是 $s_k$ ，那么他的 $ \mathtt{rk} $ 必须要在 $[L_k, R_k]$ 中。</li><li>而我们想要的是 $s_l, s_{l+1}, \cdots, s_r$ 中出现了多少次 $s_k$ ，所以这个后缀的出现位置 $i$ 要满足 $pos_l \le i \le pos_{r+1}-1$ 。为了方便，我们假设 $pos_{n+1} = |S|+1$ 。</li><li>做法已经比较显然：如果把后缀 $i$ 对应成平面直角坐标系中的点 $(i, rk_i)$ ，那么对于一个询问 $l, r, k$ ，答案便是左下角为 $(pos_l, L_k)$ ，右上角为 $(pos_{r+1}-1, R_k)$ 的矩形中点的个数。</li><li>这便是一个经典问题。只需要把一个询问拆成四个，拿出来按照第一关键字排序，按照顺序扫一遍，对于每个新的询问把满足第一维限制的点的第二维坐标加一，询问就查询前缀和即可。可以用一个简单的树状数组维护。</li><li>时间复杂度 $O(n \log n)$ 。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-08-20 12:57:11</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair <span class="meta-string">&lt;int, int&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1002000</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, qq, m, rk[N], sa[N], cnt[N], c[N]; </span><br><span class="line"><span class="keyword">int</span> len[N], pos[N], h[N], st[N][<span class="number">25</span>], lg2[N], ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N];  </span><br><span class="line"><span class="built_in">string</span> S; </span><br><span class="line"><span class="keyword">char</span> A[N]; </span><br><span class="line"><span class="keyword">int</span> Lp[N], Rp[N], tot; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y, id; </span><br><span class="line">&#125; a[N], b[N]; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y, id, typ; </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x == t.x ? y &lt; t.y : x &lt; t.x; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; Q[N * <span class="number">4</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">-1</span>; <span class="keyword">int</span> k = lg2[r - l + <span class="number">1</span>]; </span><br><span class="line">  <span class="keyword">return</span> min(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= m; i += lb(i)) </span><br><span class="line">    c[i] += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lb(i))</span><br><span class="line">    ret += c[i]; </span><br><span class="line">  <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;qq);</span><br><span class="line">  <span class="keyword">int</span> nowlen = <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    pos[i] = nowlen; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); </span><br><span class="line">    len[i] = <span class="built_in">strlen</span>(s + <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[i]; j++) </span><br><span class="line">      S += s[j]; </span><br><span class="line">    nowlen += len[i] + <span class="number">1</span>; </span><br><span class="line">    S += <span class="string">'#'</span>;  </span><br><span class="line">  &#125; </span><br><span class="line">  m = S.length();   </span><br><span class="line">  pos[n + <span class="number">1</span>] = m + <span class="number">1</span>;</span><br><span class="line">  A[<span class="number">0</span>] = <span class="string">'#'</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) A[i + <span class="number">1</span>] = S[i]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cnt[A[i]]++; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">256</span>; i++) cnt[i] += cnt[i - <span class="number">1</span>]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) rk[i] = cnt[A[i]]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">1</span>; L &lt;= m; L &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      a[i].x = rk[i], a[i].y = rk[i + L]; a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cnt[i] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cnt[a[i].y]++; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cnt[i] += cnt[i - <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) b[cnt[a[i].y]--] = a[i]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cnt[i] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cnt[b[i].x]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cnt[i] += cnt[i - <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--) a[cnt[b[i].x]--] = b[i]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i].x == a[i - <span class="number">1</span>].x &amp;&amp; a[i].y == a[i - <span class="number">1</span>].y)</span><br><span class="line">        rk[a[i].id] = rk[a[i - <span class="number">1</span>].id]; </span><br><span class="line">      <span class="keyword">else</span> rk[a[i].id] = rk[a[i - <span class="number">1</span>].id] + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) sa[rk[i]] = i; </span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k) k--; <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">while</span>(i + k &lt;= m &amp;&amp; j + k &lt;= m &amp;&amp; A[i + k] == A[j + k]) k++;</span><br><span class="line">    h[rk[i]] = k; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) st[i][<span class="number">0</span>] = h[i]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= m; j++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= m; i++) </span><br><span class="line">      st[i][j] = min(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> pp = pos[i];</span><br><span class="line">    <span class="keyword">int</span> l = rk[pp] + <span class="number">1</span>, r = m; </span><br><span class="line">    Lp[i] = Rp[i] = rk[pp]; </span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">if</span>(lcp(rk[pp] + <span class="number">1</span>, mid) &gt;= len[i]) &#123;</span><br><span class="line">        Rp[i] = mid; l = mid + <span class="number">1</span>;  </span><br><span class="line">      &#125; <span class="keyword">else</span> r = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    l = <span class="number">1</span>, r = rk[pp]; </span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">if</span>(lcp(mid + <span class="number">1</span>, rk[pp]) &gt;= len[i]) &#123;</span><br><span class="line">        Lp[i] = mid; r = mid - <span class="number">1</span>; </span><br><span class="line">      &#125; <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qq; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, k; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;l, &amp;r, &amp;k); </span><br><span class="line">    Q[++tot] = &#123;pos[l] - <span class="number">1</span>, Lp[k] - <span class="number">1</span>, i, <span class="number">1</span>&#125;; </span><br><span class="line">    Q[++tot] = &#123;pos[r + <span class="number">1</span>] - <span class="number">1</span>, Lp[k] - <span class="number">1</span>, i, <span class="number">-1</span>&#125;; </span><br><span class="line">    Q[++tot] = &#123;pos[l] - <span class="number">1</span>, Rp[k], i, <span class="number">-1</span>&#125;; </span><br><span class="line">    Q[++tot] = &#123;pos[r + <span class="number">1</span>] - <span class="number">1</span>, Rp[k], i, <span class="number">1</span>&#125;; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> P = <span class="number">1</span>; </span><br><span class="line">  sort(Q + <span class="number">1</span>, Q + tot + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(P &lt;= Q[i].x &amp;&amp; P &lt;= m) &#123;</span><br><span class="line">      add(rk[P], <span class="number">1</span>); P++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; Q[i].x &lt;&lt; " " &lt;&lt; Q[i].y &lt;&lt; endl; </span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; P &lt;&lt; endl; </span></span><br><span class="line">    ans[Q[i].id] += Q[i].typ * sum(Q[i].y); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qq; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定 $ n $ 个串  $ s_1, s_2, \cdots, s_n $ 和 $q$ 个询问，每次查询 $ s_i $ 一共在 $ s_l, s_{l+1}, \cdots, s_r $ 出现了多少次。&lt;/p&gt;
&lt;p&gt;$ n, q, \sum \limits_{i=1}^{n} |s_i| \leq 2 \times 10^5 $。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="http://yoursite.com/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>CF886E Maximum Element</title>
    <link href="http://yoursite.com/2019/08/02/CF886E/"/>
    <id>http://yoursite.com/2019/08/02/CF886E/</id>
    <published>2019-08-02T12:56:48.000Z</published>
    <updated>2019-08-02T13:49:45.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>​    有一个排列 $a_1, a_2,\cdots, a_n$。已知一种求最大值的方式：遍历一遍序列，如果一个数比他后面的 $k$ 个值都要大，则直接返回该值。求有多少个排列使得这种方式返回的答案是错误的。</p><p>​    $n, k \leq 10^6$ 。</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>​    考虑如何求正确的排列个数。可以发现，如果一个序列在求最大值时还没有遍历到 $n$ 就中途退出了，那么他返回的一定不会是正确的值。</p><p>​    于是可以设计出 $dp$ 状态：$dp_i$ 表示遍历完前 $i$ 个数依然没有返回的 $1,2,\cdots, i$ 的排列个数 。</p><p>​    注意，这里只考虑 $1, 2, \cdots, i$ 的排列个数，即他们的相对大小关系。</p><p>​    转移时，我们可以枚举前 $i - 1$ 个数的最大值所在的位置 $j$。显然有几个性质。一是 $j$ 要在 $[i - k + 1, i]$ 内，否则就会退出；二是在遍历到这个最大值之前不能退出；三是这个最大值之后的 $i - j$ 个位置可以随便交换位置，原因是他们不会对退出这件事造成任何影响。</p><p>​    于是，我们可以列出转移方程：</p><script type="math/tex; mode=display">dp_i = \sum\limits_{j=i-k+1}^{i} \binom{i-1}{j-1} \cdot dp_{j-1} \cdot (i-j)!</script><p>​    暴力 dp 是 $O(n^2)$ 的，考虑把组合数拆开，简单推导可得：</p><script type="math/tex; mode=display">dp_i = (i-1)!\cdot \sum\limits_{j=i-k}^{i-1} \frac{dp_j}{j!}</script><p>​    直接维护 $\sum\limits_{j=i-k}^{i-1} \frac{dp_j}{j!}$ 即可。</p><p>​    最后的答案如何计算？考虑最大值的位置 $i​$ ，有： </p><script type="math/tex; mode=display">\begin{aligned}ans &= n!- \sum\limits_{i=1}^{n} dp_{i-1} \cdot \binom{n-1}{i-1} \cdot (n-i)! \\&= n!-(n-1)!\cdot \sum\limits_{i=1}^{n} \frac{dp_{i-1}}{(i-1)!}\end{aligned}</script><p>​    时间复杂度 $O(n)$。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>代码中可以考虑直接维护 $\frac{dp_i}{i!}$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e6</span> + <span class="number">10</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, f[N], g[N], dp[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x += y) &gt;= mod ? x - mod : x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">while</span>(k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * x % p; </span><br><span class="line">    x = <span class="number">1l</span>l * x * x % p; k &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">  &#125; <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k); </span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    f[i] = <span class="number">1l</span>l * f[i - <span class="number">1</span>] * i % mod; </span><br><span class="line">  g[n] = fpw(f[n], mod - <span class="number">2</span>, mod);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    g[i] = <span class="number">1l</span>l * g[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;  </span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>; dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    s = add(s, dp[i - <span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">if</span>(i &gt; k) s = add(s, mod - dp[i - k - <span class="number">1</span>]);</span><br><span class="line">    dp[i] = <span class="number">1l</span>l * g[i] * f[i - <span class="number">1</span>] % mod * s % mod;  </span><br><span class="line">  &#125; s = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s = add(s, dp[i - <span class="number">1</span>]); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1l</span>l * f[n - <span class="number">1</span>] * add(n, mod - s) % mod); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;​    有一个排列 $a_1, a_2,\cdots, a_n$。已知一种求最大值的方式：遍历一遍序列，如果一个数比他后面的 $k$ 个值都要大，则直接返回该值。求有多少个排列使得这种方式返回的答案是错误的。&lt;/p&gt;
&lt;p&gt;​    $n, k \leq 10^6$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>CF848C Goodbye Souvenir</title>
    <link href="http://yoursite.com/2019/07/07/CF848C/"/>
    <id>http://yoursite.com/2019/07/07/CF848C/</id>
    <published>2019-07-07T14:00:36.000Z</published>
    <updated>2019-07-07T14:28:13.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给出一个长度为 $n$ 的序列 $a_i$，$1 \le a_i \le n$ 。有 $m$ 个操作，每次操作输入三个数 $o,x,y$ 表示</p><ul><li>$o=1$ ，此时表示令 $a_x=y$ </li><li>$o=2$ ，此时表示询问 $\sum_{i=1}^n v(i)$ 。其中 $v(i)$ 是数字 $i$ 在 $[x,y]$ 中最后一次出现的位置减去第一次出现的位置。如果没有出现，则 $v(i) = 0$ </li></ul><p>$n, m \leq 10^5$ </p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们令 $pre_i$ 表示最大的 $j$ 满足 $j &lt; i$ 且 $a_j = a_i$ （若不存在这样的 $j$ 则 $j = 0$）</p><p>同样的 $nxt_i$ 表示最小的 $j$ 满足 $j &gt; i$ 且 $a_j = a_i$ （若不存在这样的 $j$ 则 $j = n+1$）</p><p>如果没有修改操作，那么我们把每一个 $(i, pre_i)$ 这样的二元组看成坐标上的一个点，他的值为 $i - pre_i$ ，那么每次询问 $[l, r]$ 的答案就是一个左下角为 $(l,l)$ 右上角为 $(r,r)$ 的矩（正方）形内的所有点值之和（包括边）。</p><p>这样做的原因在于，对于一个值，如果他最后一次出现在 $e$ 这个位置，第一次出现在 $s$ 这个位置，那么他对答案的贡献就是 $s-e = (s - pre_s) + (pre_s - pre_{pre_s})+ \cdots+(nxt_s - s)$ 即把 $[s, e]$ 这个区间拆分成若干个 $[pre_i, i]$ 的区间。如果把 $(i, pre_i)$  看成一个坐标系上的点，那么他的两个维度都满足在 $[l, r]$ 中，那么他会对答案产生贡献；反之，$[l, r]$ 内的答案也是由这些点的贡献所组成的。</p><p>有了修改操作，直接用 $n$ 个 set 维护一下 $nxt$ 和 $pre$ 。对于每一个 $a[x] = y$ 修改，会减少 $(x, pre_{a_x}), (nxt_{a_x}, x), (nxt_y, pre_y)$ 三个点，增加了 $(nxt_{a_x}, pre_{a_x}), (x, pre_y), (nxt_y, x)$ 三个点。（注意这里的 $nxt_a, pre_a$ 表示的是对于 $a$ 这个值在 $x$ 这个位置之前/之后第一次出现的位置）。于是问题转化成一个加点删点求矩形内部值之和，可以以时间为第一维，$i$ 为第二维，$pre_i$ 为第三维用CDQ分治做三维偏序就做完了。（询问矩阵再用一个差分）</p><p>时间复杂度：$O(n \log^2 n)$ （由于点数可能很多所以参与 CDQ 分治的点有大概 $6n$ 个所以很慢）</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-07-06 17:01:34</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500500</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], nxt[N], pre[N], po[N]; </span><br><span class="line"><span class="keyword">int</span> tot, fla[N]; </span><br><span class="line">ll ans[N], c[N]; </span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s[<span class="number">100001</span>]; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> op, y, z, v, id; </span><br><span class="line">&#125; Q[N * <span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mk</span> <span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> v, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  Q[++tot].y = y, Q[tot].z = z; </span><br><span class="line">  Q[tot].id = id; Q[tot].op = op; Q[tot].v = v; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= <span class="number">100005</span>; i += lb(i))</span><br><span class="line">    c[i] += d; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  ll ret = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lb(i)) </span><br><span class="line">    ret += c[i]; </span><br><span class="line">  <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query x, Query y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.y &lt; y.y; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ; </span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">  CDQ(l, mid); CDQ(mid + <span class="number">1</span>, r); </span><br><span class="line">  sort(Q + l, Q + mid + <span class="number">1</span>, cmp); </span><br><span class="line">  sort(Q + mid + <span class="number">1</span>, Q + r + <span class="number">1</span>, cmp); </span><br><span class="line">  <span class="keyword">int</span> pos = l; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(pos &lt;= mid &amp;&amp; Q[pos].y &lt;= Q[i].y) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Q[pos].op == <span class="number">0</span>)</span><br><span class="line">        add(Q[pos].z + <span class="number">1</span>, Q[pos].v); </span><br><span class="line">      pos++; </span><br><span class="line">    &#125; <span class="keyword">if</span>(Q[i].op == <span class="number">1</span>) &#123;</span><br><span class="line">      ans[Q[i].id] += sum(Q[i].z + <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt; pos; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Q[i].op == <span class="number">0</span>) </span><br><span class="line">      add(Q[i].z + <span class="number">1</span>, -(Q[i].v)); </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    s[i].insert(<span class="number">0</span>), s[i].insert(n + <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]); </span><br><span class="line">    pre[i] = po[a[i]]; </span><br><span class="line">    po[a[i]] = i; </span><br><span class="line">    mk(<span class="number">0</span>, i, pre[i], i - pre[i], <span class="number">0</span>); </span><br><span class="line">    s[a[i]].insert(i); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    po[i] = n + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    nxt[i] = po[a[i]]; </span><br><span class="line">    po[a[i]] = i; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> op, x, y; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[x] == y) <span class="keyword">continue</span> ;</span><br><span class="line">      mk(<span class="number">0</span>, x, pre[x], pre[x] - x, <span class="number">0</span>); </span><br><span class="line">      mk(<span class="number">0</span>, nxt[x], x, x - nxt[x], <span class="number">0</span>); </span><br><span class="line">      mk(<span class="number">0</span>, nxt[x], pre[x], nxt[x] - pre[x], <span class="number">0</span>);   </span><br><span class="line">      nxt[pre[x]] = nxt[x]; </span><br><span class="line">      pre[nxt[x]] = pre[x]; </span><br><span class="line">      s[a[x]].erase(x);</span><br><span class="line">      a[x] = y; </span><br><span class="line">      s[y].insert(x);</span><br><span class="line">      <span class="built_in">set</span> &lt; <span class="keyword">int</span> &gt; :: iterator Nw = s[y].find(x); </span><br><span class="line">      <span class="keyword">int</span> Pr = *(--Nw), Nx = *(++(++(Nw))); </span><br><span class="line">      mk(<span class="number">0</span>, Nx, Pr, Pr - Nx, <span class="number">0</span>); </span><br><span class="line">      mk(<span class="number">0</span>, x, Pr, x - Pr, <span class="number">0</span>); </span><br><span class="line">      mk(<span class="number">0</span>, Nx, x, Nx - x, <span class="number">0</span>); </span><br><span class="line">      pre[Nx] = nxt[Pr] = x; </span><br><span class="line">      pre[x] = Pr, nxt[x] = Nx; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mk(<span class="number">1</span>, x - <span class="number">1</span>, x - <span class="number">1</span>, <span class="number">0</span>, i * <span class="number">4</span> - <span class="number">3</span>); </span><br><span class="line">      mk(<span class="number">1</span>, x - <span class="number">1</span>, y, <span class="number">0</span>, i * <span class="number">4</span> - <span class="number">2</span>); </span><br><span class="line">      mk(<span class="number">1</span>, y, x - <span class="number">1</span>, <span class="number">0</span>, i * <span class="number">4</span> - <span class="number">1</span>); </span><br><span class="line">      mk(<span class="number">1</span>, y, y, <span class="number">0</span>, i * <span class="number">4</span>); </span><br><span class="line">      fla[i] = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  CDQ(<span class="number">1</span>, tot);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fla[i]) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i * <span class="number">4</span> - <span class="number">3</span>] - ans[i * <span class="number">4</span> - <span class="number">2</span>] - ans[i * <span class="number">4</span> - <span class="number">1</span>] + ans[i * <span class="number">4</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给出一个长度为 $n$ 的序列 $a_i$，$1 \le a_i \le n$ 。有 $m$ 个操作，每次操作输入三个数 $o,x,y$ 表示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$o=1$ ，此时表示令 $a_x=y$ &lt;/li&gt;
&lt;li&gt;$o=2$ ，此时表示询问 $\sum_{i=1}^n v(i)$ 。其中 $v(i)$ 是数字 $i$ 在 $[x,y]$ 中最后一次出现的位置减去第一次出现的位置。如果没有出现，则 $v(i) = 0$ &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$n, m \leq 10^5$ &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="CDQ分治" scheme="http://yoursite.com/tags/CDQ%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4828 「HNOI2017」大佬</title>
    <link href="http://yoursite.com/2019/06/21/BZOJ4828/"/>
    <id>http://yoursite.com/2019/06/21/BZOJ4828/</id>
    <published>2019-06-21T10:34:44.000Z</published>
    <updated>2019-06-21T11:48:44.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>你现在要怼 $m$ 个大佬，第 $i$ 个大佬的自信值是 $C_i$ 。每次怼大佬之前，你的自信值是 $mc$，等级 $L=0$，嘲讽值 $F = 1$。对于每一个大佬，你都有 $n$ 天时间来怼大佬。无论哪个大佬，他们都会在第 $i$ 天使你的的自信值下降 $a_i$ 如果你的自信值为负数，那么你失败了。在第 $i$ 天，你可以干一下事情中的恰好一件：</p><ol><li>使得大佬自信值下降 $1$</li><li>使得自己的自信值增加 $w_i$ </li><li>把自己的等级 $+1$ </li><li>把自己的 $F$ 乘上 $L$</li><li>怼大佬，使得大佬的自信值下降 $F$，之后$L=0$  ，$F=1$</li></ol><p>如果中途大佬自信值为负数，你失败了。若大佬自信值恰好为 $0​$ ，则你成功了。</p><p>对于每个大佬求你能否成功。</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，可以发现，怼大佬和活下来两件事是互相独立的。并且怼大佬只与天数相关。显然天数越多越有可能。</p><p>所以先用一遍简单 dp 得出最多能剩下多少天来怼大佬并且保证自己活下来。设最多天数是 $D$ 。</p><p>然后用一遍 BFS 的出所有二元组 $(d, f)$ 表示用了 $d(&lt;D)$  天并且此时 $F = f$ 。注意去重。</p><p>你能怼死大佬有三种情况：</p><ol><li>不怼大佬。只执行 $1$ 操作。此时需要满足 $C_i \leq D$ </li><li>只怼一次大佬。这时能怼死大佬需要满足存在一个二元组 $(d’,f’)$ 使得 $f’ \leq C_i$ 并且 $f’+D - d \ge C_i$ （一次不能怼死，用 $1$ 操作耗死）</li><li>怼两次。可以发现，若两次分别是 $(d_1,f_1), (d_2, f_2)$ 则类似于第二种情况，有 $f_1+f_2\leq C_i$ 并且 $f_1+f_2+(D-d_1-d_2) \ge C_i$ 。显然，对于一个 $f_i$ ，只有最小的那个 $d_i$ 才是最优的。所以我们对每个 $f$  只保存最小的 $d$ ，并且按照 $f$ 排序。由于需要满足$f_1+f_2\leq C_i$， 就可以直接用双指针扫一遍，中途判断是否存在 $f_1+f_2+(D-d_1-d_2) \ge C_i$ 即可。</li></ol><p>由于 $f$ 增长的很快，导致二元组不会特别多，于是可以通过此题。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-06-21 14:35:24</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair <span class="meta-string">&lt;int, int&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = (<span class="keyword">int</span>)<span class="number">3e6</span> + <span class="number">10</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m, mc, mxc, cnt, tot; </span><br><span class="line"><span class="keyword">int</span> a[N], w[N], dp[N][N], D, C[<span class="number">22</span>]; </span><br><span class="line"> </span><br><span class="line">pair &lt;<span class="keyword">int</span>, PII&gt; Q[NN]; </span><br><span class="line">PII A[NN], B[NN]; </span><br><span class="line"><span class="built_in">map</span> &lt;PII, <span class="keyword">int</span>&gt; mp; </span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mmp; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = a[i]; j &lt;= mc; j++) &#123;</span><br><span class="line">      dp[i][j - a[i]] = max(dp[i][j - a[i]], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>); </span><br><span class="line">      <span class="keyword">int</span> t = min(j - a[i] + w[i], mc); </span><br><span class="line">      dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j]); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= mc; j++)</span><br><span class="line">      D = max(D, dp[i][j]); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// fi : day</span></span><br><span class="line">  <span class="comment">// se.fi : level</span></span><br><span class="line">  <span class="comment">// se.se : att</span></span><br><span class="line">  Q[++t] = MP(<span class="number">1</span>, MP(<span class="number">0</span>, <span class="number">1</span>)); </span><br><span class="line">  mp[MP(<span class="number">1</span>, <span class="number">1</span>)] = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">while</span>(h &lt;= t) &#123;</span><br><span class="line">    pair &lt;<span class="keyword">int</span>, PII&gt; tmp = Q[h++]; </span><br><span class="line">    <span class="keyword">if</span>(tmp.fi &gt;= D) <span class="keyword">continue</span> ; </span><br><span class="line">    <span class="keyword">int</span> d = tmp.fi, l = tmp.se.fi, f = tmp.se.se;</span><br><span class="line">    Q[++t] = MP(d + <span class="number">1</span>, MP(l + <span class="number">1</span>, f)); </span><br><span class="line">    mp[MP(d + <span class="number">1</span>, f)] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(l &gt; <span class="number">1</span> &amp;&amp; <span class="number">1l</span>l * l * f &lt;= mxc &amp;&amp; !mp[MP(d + <span class="number">1</span>, l * f)]) &#123;</span><br><span class="line">      <span class="keyword">int</span> nf = l * f; </span><br><span class="line">      Q[++t] = MP(d + <span class="number">1</span>, MP(l, nf)); </span><br><span class="line">      mp[MP(d + <span class="number">1</span>, nf)] = <span class="number">1</span>; A[++cnt] = MP(d + <span class="number">1</span>, nf); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(PII a, PII b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.se == b.se ? a.fi &lt; b.fi : a.se &lt; b.se; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;mc); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C[i]); </span><br><span class="line">    mxc = max(mxc, C[i]); </span><br><span class="line">  &#125;</span><br><span class="line">  getday(); </span><br><span class="line">  getst(); </span><br><span class="line">  sort(A + <span class="number">1</span>, A + cnt + <span class="number">1</span>, cmp); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!mmp[A[i].se]) &#123;</span><br><span class="line">      mmp[A[i].se] = <span class="number">1</span>; </span><br><span class="line">      B[++tot] = A[i]; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= m; _++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(C[_] &lt;= D) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"1"</span>); </span><br><span class="line">      <span class="keyword">continue</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">0</span>, pos = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">int</span> d = B[i].fi, f = B[i].se;</span><br><span class="line">      <span class="keyword">if</span>(f &lt;= C[_] &amp;&amp; D - d + f &gt;= C[_]) &#123;</span><br><span class="line">        ok = <span class="number">1</span>; <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> mx = -INF; </span><br><span class="line">      <span class="keyword">while</span>(pos &lt;= tot &amp;&amp; f + B[pos].se &lt;= C[_]) &#123;</span><br><span class="line">        mx = max(mx, B[pos].se - B[pos].fi); pos++; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span>(f - d + mx &gt;= C[_] - D) &#123;</span><br><span class="line">        ok = <span class="number">1</span>; <span class="keyword">break</span> ; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ok); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;你现在要怼 $m$ 个大佬，第 $i$ 个大佬的自信值是 $C_i$ 。每次怼大佬之前，你的自信值是 $mc$，等级 $L=0$，嘲讽值 $F = 1$。对于每一个大佬，你都有 $n$ 天时间来怼大佬。无论哪个大佬，他们都会在第 $i$ 天使你的的自信值下降 $a_i$ 如果你的自信值为负数，那么你失败了。在第 $i$ 天，你可以干一下事情中的恰好一件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使得大佬自信值下降 $1$&lt;/li&gt;
&lt;li&gt;使得自己的自信值增加 $w_i$ &lt;/li&gt;
&lt;li&gt;把自己的等级 $+1$ &lt;/li&gt;
&lt;li&gt;把自己的 $F$ 乘上 $L$&lt;/li&gt;
&lt;li&gt;怼大佬，使得大佬的自信值下降 $F$，之后$L=0$  ，$F=1$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果中途大佬自信值为负数，你失败了。若大佬自信值恰好为 $0​$ ，则你成功了。&lt;/p&gt;
&lt;p&gt;对于每个大佬求你能否成功。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="two pointers" scheme="http://yoursite.com/tags/two-pointers/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4784 「ZJOI2017」仙人掌</title>
    <link href="http://yoursite.com/2019/06/21/BZOJ4784/"/>
    <id>http://yoursite.com/2019/06/21/BZOJ4784/</id>
    <published>2019-06-21T10:33:51.000Z</published>
    <updated>2019-06-21T11:48:53.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一张 $n$ 个点 $m$ 条边的无向简单连通图，问有多少种加边方法使其是一颗仙人掌。</p><p>$n \leq 5\cdot 10^5, m \leq \min\{\frac{n\cdot(n+1)}{2}, 10^6\}$  </p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>若原图不是一颗仙人掌，直接输出 $0​$ 即可。</p><p>若其是一颗仙人掌，其中的环对答案没有贡献（既不能在其中加边，也不能向外连边），可以直接把与这个环相关的边删掉。剩下的即是一颗森林。求出每棵树的方案数将其直接累乘即可。</p><p>如果图是树的情况下怎么做？发现如果在一颗树找出若干个不相交的链，每个链的首尾连一条边，那么这个图一定是仙人掌；反之，最后加完边的图，加上的每一条边都对应一条链，每一条边也只会属于至多一个环即至多属于一个树链加上加上的边。所以问题转化成在一棵树中找出若干不相交的链的方案数。 这样还是不是特别好做，如果我们把那些没有在任何一个环的树边看成在他与他自己的环里，那么问题就转化成了 <strong>用若干条不相交的链覆盖整颗树的方案数</strong> 。</p><p>考虑树形dp。令 $dp_u​$ 为 $u​$ 的子树中所有边加上他到父亲的一条边的方案数。令 $f_x​$ 表示一个点的度数为 $x​$，把所有与它相连的边用长度不超过 $2​$ 的链全部覆盖的方案数，则 $dp_u = f_{deg_u}\Pi _vdp_{v}​$ 。其中 $v​$ 是 $u​$ 的子节点，$deg_u​$ 是 $u​$ 的度数。</p><p>$f$ 考虑用递推求。每次新加入一条边，他可以自己是一条链，也可以与之前的一条匹配成一条链。易得 $f_n = f_{n-1}+(n-1)\cdot f_{n-2}$ 并且 $f_0 = f_1= 1$ 。</p><p>复杂度 $O(n+m)$ </p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-05-20 22:37:18</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000010</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> vis[N], C[N], fa[N], dep[N];</span><br><span class="line"><span class="keyword">int</span> dp[N], x[N];  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v; </span><br><span class="line">&#125; E[M]; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v; edge *next; </span><br><span class="line">&#125; pool[M * <span class="number">2</span>], *h1[N], *h2[N], *h3[N], *cur = pool; </span><br><span class="line"></span><br><span class="line"><span class="comment">// h1 : pre ; h2 : tree</span></span><br><span class="line"><span class="comment">// h3 : delete circle</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x += y) &gt;= mod ? x - mod : x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x[<span class="number">0</span>] = x[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">500000</span>; i++) </span><br><span class="line">    x[i] = add(x[i - <span class="number">1</span>], <span class="number">1l</span>l * (i - <span class="number">1</span>) * x[i - <span class="number">2</span>] % mod); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ade1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++; p-&gt;v = v; </span><br><span class="line">  p-&gt;next = h1[u], h1[u] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ade2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++; p-&gt;v = v; </span><br><span class="line">  p-&gt;next = h2[u], h2[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ade3</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++; p-&gt;v = v; </span><br><span class="line">  p-&gt;next = h3[u], h3[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTree</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(edge *p = h1[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = p-&gt;v; <span class="keyword">if</span>(v == pre) <span class="keyword">continue</span> ; </span><br><span class="line">    <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span> ; </span><br><span class="line">    fa[v] = u; dep[v] = dep[u] + <span class="number">1</span>; </span><br><span class="line">    GetTree(v, u); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetC</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(edge *p = h2[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = p-&gt;v; <span class="keyword">if</span>(v == pre) <span class="keyword">continue</span> ;</span><br><span class="line">    GetC(v, u); C[u] += C[v];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="number">1</span>; dp[u] = <span class="number">1</span>; <span class="keyword">int</span> cl = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(edge *p = h3[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = p-&gt;v; <span class="keyword">if</span>(v == pre) <span class="keyword">continue</span> ; </span><br><span class="line">    <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span> ; </span><br><span class="line">    solve(v, u); </span><br><span class="line">    dp[u] = <span class="number">1l</span>l * dp[u] * dp[v] % mod; ++cl; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(u == pre) dp[u] = <span class="number">1l</span>l * dp[u] * x[cl] % mod;</span><br><span class="line">  <span class="keyword">else</span> dp[u] = <span class="number">1l</span>l * dp[u] * x[cl + <span class="number">1</span>] % mod;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prework(); </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); </span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      vis[i] = C[i] = dp[i] = dep[i] = <span class="number">0</span>; </span><br><span class="line">      h1[i] = h2[i] = h3[i] = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    cur = pool; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;E[i].u, &amp;E[i].v);</span><br><span class="line">      ade1(E[i].u, E[i].v), ade1(E[i].v, E[i].u);  </span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    GetTree(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(dep[E[i].u] &lt; dep[E[i].v]) </span><br><span class="line">        swap(E[i].u, E[i].v); </span><br><span class="line">      <span class="keyword">int</span> u = E[i].u, v = E[i].v; </span><br><span class="line">      <span class="keyword">if</span>(fa[u] == v || fa[v] == u) &#123;</span><br><span class="line">        ade2(u, v), ade2(v, u); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> C[u]++, C[v]--; </span><br><span class="line">    &#125;</span><br><span class="line">    GetC(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">bool</span> isc = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">      <span class="keyword">if</span>(C[i] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        isc = <span class="number">0</span>; <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span>(isc == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">continue</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      vis[i] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = E[i].u, v = E[i].v; </span><br><span class="line">      <span class="keyword">if</span>(fa[u] == v || fa[v] == u)</span><br><span class="line">        <span class="keyword">if</span>(!C[u]) ade3(u, v), ade3(v, u); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">        solve(i, i); </span><br><span class="line">        ans = <span class="number">1l</span>l * ans * dp[i] % mod; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定一张 $n$ 个点 $m$ 条边的无向简单连通图，问有多少种加边方法使其是一颗仙人掌。&lt;/p&gt;
&lt;p&gt;$n \leq 5\cdot 10^5, m \leq \min\{\frac{n\cdot(n+1)}{2}, 10^6\}$  &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="仙人掌" scheme="http://yoursite.com/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C/"/>
    
  </entry>
  
  <entry>
    <title>HDU6061 RXD and functions</title>
    <link href="http://yoursite.com/2019/05/27/hdu6061/"/>
    <id>http://yoursite.com/2019/05/27/hdu6061/</id>
    <published>2019-05-27T10:06:03.000Z</published>
    <updated>2019-05-28T13:44:34.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>已知 $f(x) = \sum\limits_{i=0}^{n}c_ix^i$ ，求 $g(x) = f(x+a) = \sum\limits_{i=0}^{n} c_i(x+a)^i$ 的各项系数。</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><img src="https://i.loli.net/2019/05/28/5ced3ad24549514149.png" alt="hdu6061"></p><p>（写了半天的公式忘保存还好我留了一张图片）</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">10</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], rev[<span class="number">1</span> &lt;&lt; <span class="number">21</span>], fac[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">while</span>(k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * x % p;</span><br><span class="line">    x = <span class="number">1l</span>l * x * x % p; k &gt;&gt;= <span class="number">1</span>;  </span><br><span class="line">  &#125; <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x += y) &gt;= mod ? x - mod : x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> L, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) </span><br><span class="line">    <span class="keyword">if</span>(i &lt; rev[i]) swap(a[i], a[rev[i]]); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>; i &lt; L; i &lt;&lt;= <span class="number">1</span>, l++) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = fpw(G, (mod - <span class="number">1</span>) &gt;&gt; (l + <span class="number">1</span>), mod); </span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">-1</span>) w = fpw(w, mod - <span class="number">2</span>, mod); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">int</span> wn = <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; i + j; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (<span class="number">1l</span>l * wn * a[i + k] % mod); </span><br><span class="line">        a[i + k] = add(a[k], mod - t); </span><br><span class="line">        a[k] = add(a[k], t); </span><br><span class="line">        wn = (<span class="number">1l</span>l * wn * w) % mod;  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(op == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> invL = fpw(L, mod - <span class="number">2</span>, mod); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) </span><br><span class="line">      a[i] = (<span class="number">1l</span>l * a[i] * invL % mod); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">21</span>], g[<span class="number">1</span> &lt;&lt; <span class="number">21</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)<span class="number">1e5</span>; i++) </span><br><span class="line">    fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % mod; </span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]); </span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, l = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(L &lt;= <span class="number">2</span> * (n + <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, l++; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">      rev[i] = ((rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | (i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)); </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * L); </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * L); </span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); A -= t; A %= mod; </span><br><span class="line">    &#125; A = (A + mod) % mod; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">      f[i] = <span class="number">1l</span>l * c[i] * fac[i] % mod, </span><br><span class="line">      g[n - i] = <span class="number">1l</span>l * fpw(A, i, mod) * fpw(fac[i], mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    NTT(f, L, <span class="number">1</span>), NTT(g, L, <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">      f[i] = <span class="number">1l</span>l * f[i] * g[i] % mod; </span><br><span class="line">    NTT(f, L, <span class="number">-1</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="number">1l</span>l * f[i] * fpw(fac[i - n], mod - <span class="number">2</span>, mod) % mod); </span><br><span class="line">    &#125; <span class="built_in">putchar</span>(<span class="string">'\n'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;已知 $f(x) = \sum\limits_{i=0}^{n}c_ix^i$ ，求 $g(x) = f(x+a) = \sum\limits_{i=0}^{n} c_i(x+a)^i$ 的各项系数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="NTT" scheme="http://yoursite.com/tags/NTT/"/>
    
  </entry>
  
  <entry>
    <title>一些 dp 的优化方式</title>
    <link href="http://yoursite.com/2019/05/14/%E4%B8%80%E4%BA%9B-dp-%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/05/14/一些-dp-的优化方式/</id>
    <published>2019-05-14T08:57:49.000Z</published>
    <updated>2019-05-14T14:09:22.513Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结了一下</p><a id="more"></a><h1 id="决策单调性"><a href="#决策单调性" class="headerlink" title="决策单调性"></a>决策单调性</h1><p>一些时候 dp 转移方程是这个样子 </p><script type="math/tex; mode=display">dp_i = \min\limits_{0 \leq j \leq i - 1} (dp_j + w(i, j))</script><p>这个时候暴力是 $O(n^2)$ 的。如果 $w(i, j)$ 满足一些特殊的性质，那么就可以优化他了。</p><p><strong>决策单调性：</strong></p><p> 对于 $i$ ，他的决策 $opt(i)$ 就是所有的 $j$ 中使得转移式子达到最值的那个 $j$ 。</p><p>如果对于任意的 $i, j$ 使得 $i \leq j$ 都有 $opt(i) \leq opt(j)$ 那么就有决策单调性。 它的用处放到后面。</p><p><strong>四边形不等式：</strong> 如果对于任意的 $1 \leq a \leq b \leq c \leq d \leq n$ 都有 $w(a, c) + w(b, d) \leq w(a, d) + w(b, c)$ ，那么 $w$ 就满足四边形不等式。</p><p>一个重要的事情是：<strong>如果 $w$ 满足四边形不等式，那么就有决策单调性</strong> </p><p>一个好理解的证明方式：如果没有决策单调性，那么我们可以找到不降的四个数 $a, b, c, d$ ，这四个点满足 $a = opt(d), b = opt(c)$ 即 $a, b$ 分别是 $c, d$ 的决策点。由于不满足决策单调性所以肯定能找到。此时 $dp_c + dp_d = dp_i + dp_j + w(a, d) + w(b, c)$ 。如果我们把决策点互换，即让 $b = opt(d), a = opt(c)$ ，此时 $dp_c + dp_d = dp_i + dp_j + w(a, c) + w(b, d)$ 。由于满足四边形不等式，下面的总和根据定义一定 $ \leq $ 上面的总和。就能推出决策点交换后 $c, d$ 至少有一个要更优。所以他是满足决策单调性的。（不是很严谨）</p><p>如果看到一个题，dp式子长成上面那个样子，没有什么很好的办法搞，就要考虑决策单调性。一般都是满足四边形不等式，不放心就证一下。</p><p>有了决策单调性，然后该如何优化？</p><p>再先看一个问题：给定一个 $n * n$ 表格，告诉你每行的最小值所在的列是单调不减的，找出每行每列的最小值及其所在的位置。</p><p>对于这个问题，我们可以利用<strong>分治</strong>来解决。用 <code>solve(l, r, L, R)</code> 来求解行在 $[l, r]$ 中列在 $[L, R]$ 中的子问题。每次我找到最中间的行 $mid$，暴力从 L 到 R for 找出最小值的列 $pos$，然后由于最小值位置不减，分成 <code>solve(l, mid - 1, L, pos)</code> 和 <code>solve(mid + 1, r, pos, R)</code> 继续求解。这样做的复杂度是 $O(n \log n)$ 。</p><p>所以这和决策单调性有什么关系？如果你把最小值所在的列看成决策点所在的位置，那么是否就成功的转化成了这个问题？所以我们找出了一种 $O(n \log n)$ 的方法。代码也十分好写。</p><p>另外一种处理决策单调性的方法在例题2中出现。</p><p><strong>[例题1] CF 321E </strong> <a href="https://www.luogu.org/problemnew/show/CF321E" target="_blank" rel="noopener">题面</a> </p><p>设 $dp[i][k]$ 表示前 $i$ 个人分了 $k$ 段的最小值。</p><p>先可以写出状态转移方程</p><script type="math/tex; mode=display">dp[i][k] = \min\limits_{0 \leq j \leq i - 1} (dp[j][k - 1] + w(i, j))</script><p>其中 $w(i, j)$ 表示把 $[j + 1, i]$ 中所有人分成一组的代价。就是一个矩阵的元素和。</p><p>由于它是矩阵的元素和，所以很显然满足四边形不等式。于是就有决策单调性。</p><p>但是有一个 $k$  的限制。这又应该如何处理？这里可以 <strong>按层分治</strong> 。可以发现，如果有了所有的 $dp[i][k]$ ，那么通过上面的方法就可以求出所有的 $dp[i][k + 1]$。于是，预处理 $k = 1$ 的情况，然后枚举 $k$，每次分治求出下一层的信息。 复杂度 $O(n k \log n)$ 。</p><p><strong>[例题2] NOI2009 诗人小G</strong> <a href="https://www.luogu.org/problemnew/show/P1912" target="_blank" rel="noopener">题面</a> </p><p>方程很显然。设 $dp_i$ 表示前 $i$ 句诗的最小代价。</p><script type="math/tex; mode=display">dp_i = \min\limits_{0 \leq j \leq i - 1} (dp_j + w(i, j))</script><p>$w(i, j) = (sum_i - sum_j - L - 1) ^ P$ (这里的 $sum_i$ 是带上空格之后的，最后的减一是末位不能加空格)。</p><p>可以证明 $w$ 满足四边形不等式。分治的做法在这里行不通了。为什么之前可以？因为他是按<strong>层</strong>分治，而这里没有这个条件，你就没法及时的得到信息了。你在找最小值的时候这个地方的数可能根本没有填上。我们考虑寻找另外的方法。</p><p>当我们一个 dp 值都没有的时候，考虑目前的 $opt(i)$ 一定是：</p><p><code>00000000000000000000000000000000000000000000000000000000000000000000</code> </p><p>当我们有了第一个 $dp$ 值，那么可能有一些 opt 产生变化。由于决策单调性，所以一定变化了一个后缀比如：</p><p><code>00000000000000000000011111111111111111111111111111111111111111111111</code> </p><p>然后有了第二个 $dp$ 值，会有一些 opt 变成 2 。比如</p><p><code>00000000000000000000011111111111111111111111111111111222222222222222</code>   </p><p>如此类推，我们试图从中找出一些性质。显然，每个决策形成一个区间。</p><p>我们考虑用一个栈来维护决策。用 $l_i$ 和 $r_i$ 来表示 $i$ 这个决策所形成的的区间的左右端点。</p><p>每次加入一个新的决策 $i$，与栈顶的决策点 $t$ 比较。有两种情况：</p><ol><li>如果在 $l_t$ 处 $t$ 的转移没有 $i$ 的优，那么这个决策整个就没有用了。即 $i$ 会把 $t$ 这一整段区间都覆盖住。此时把栈顶弹掉，继续。</li><li>不满足上述情况，那么 $i$ 的覆盖终止于 $t$ 。此时由于决策单调性，直接二分转折点 $pos$（即这个区间在转折点前是 $t$ ，后半部分是  $i$ ）。让 $r[t] = pos - 1, l[i] = pos, r[i] = n$ </li></ol><p>这样做的复杂度是 $O(n \log n)$</p><p>这一部分的代码还有一些细节问题，我直接贴出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的 w(i, j) 表示的是 dp[j] + 文中的 w(i, j) </span></span><br><span class="line"><span class="keyword">int</span> h = <span class="number">1</span>, t = <span class="number">0</span>; l[<span class="number">0</span>] = <span class="number">1</span>, r[<span class="number">0</span>] = n;</span><br><span class="line">Q[++t] = <span class="number">0</span>;  <span class="comment">// 要把 0 先放进去 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span>(h &lt;= t &amp;&amp; r[Q[h]] &lt; i) h++; <span class="comment">// 把栈底的没用的元素弹掉。</span></span><br><span class="line">  dp[i] = w(i, Q[h]); pre[i] = Q[h]; <span class="comment">// 更新 dp 以及 i 处的决策点</span></span><br><span class="line">  <span class="keyword">if</span>(w(n, Q[t]) &lt; w(n, i)) <span class="keyword">continue</span> ; <span class="comment">// 根本不会覆盖住任何一个区间直接弹掉</span></span><br><span class="line">  <span class="keyword">while</span>(h &lt;= t &amp;&amp; w(l[Q[t]], Q[t]) &gt; w(l[Q[t]], i)) t--; <span class="comment">// 弹掉没用的</span></span><br><span class="line">  <span class="keyword">int</span> lp = l[Q[t]], rp = n, pos = n; </span><br><span class="line">  <span class="keyword">while</span>(lp &lt;= rp) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lp + rp) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(w(mid, Q[t]) &gt; w(mid, i)) &#123;</span><br><span class="line">      pos = mid, rp = mid - <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> lp = mid + <span class="number">1</span>; </span><br><span class="line">  &#125; <span class="comment">// 二分 pos </span></span><br><span class="line">  l[i] = pos; r[i] = n; </span><br><span class="line">  r[Q[t]] = pos - <span class="number">1</span>; Q[++t] = i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><p>转移方程形如 $dp_i = \min(a[j] + b[j] + c[i] \cdot d[j])$ 。$a[i]$ 表示和 $i$ 相关的部分，其他类似。 </p><p>直接用题目讲</p><p><strong>[例题3] HNOI2008 玩具装箱TOY </strong> <a href="https://www.luogu.org/problemnew/show/P3195" target="_blank" rel="noopener">题面</a></p><p>令$dp[i]$为前$i$个装箱的最小花费。<br>转移方程如下：</p><script type="math/tex; mode=display">dp[i]=\min\limits_{0 \leq j < i} \{ dp[j]+( \sum \limits_{k = j + 1}^{i}{C_k} + i - j - 1 - L) ^ 2\}</script><p>用$sum[i]$表示前$i$个容器的长度之和（即$C$的前缀和），方程简化为：</p><script type="math/tex; mode=display">dp[i]=\min\limits_{0 \leq j < i} \{ dp[j]+( sum[i]-sum[j] + i - j - 1 - L) ^ 2\}</script><p>又令$f[i]$为$sum[i]+i$，继续简化方程为：</p><script type="math/tex; mode=display">dp[i]=\min\limits_{0 \leq j < i} \{ dp[j]+( f[i]-f[j] - 1 - L) ^ 2\}</script><p>暴力dp是$O(n^2)$，考虑优化。如何优化，就是用前面所提到的<strong>斜率优化</strong>。这玩意到底是什么？我们先来继续对状态转移方程进行进一步的推导。</p><p>对于每个$dp[i]$可以知道都是由一个$j_0$推过来的。这个$j_0$对于当前的$i$是最优的决策。假设现在有两个决策$j_1,j_2 (1 \leq j_1 &lt; j_2 &lt; i)$，且决策$j_2$优于$j_1$，则有：</p><script type="math/tex; mode=display">dp[j_1]+( f[i]-f[j_1] - 1 - L) ^ 2 \geq dp[j_2]+( f[i]-f[j_2] - 1 - L) ^ 2</script><p>拆开可得：</p><script type="math/tex; mode=display">dp[j_1]+f[i]^2-2f[i](f[j_1]+1+L)+(f[j_1]+L+1)^2 \geq dp[j_2]+f[i]^2-2f[i](f[j_2]+1+L)+(f[j_2]+L+1)^2</script><p>化简可得：</p><script type="math/tex; mode=display">2f[i](f[j_2] + 1 + L)-2f[i](f[j_1] + 1 + L) \geq dp[j_2]+(f[j_2]+1+L)^2 - (dp[j_1]+(f[j_1]+1+L)^2)</script><p>即：</p><script type="math/tex; mode=display">2f[i] \geq \frac{dp[j_2]+(f[j_2]+1+L)^2 - (dp[j_1]+(f[j_1]+1+L)^2)}{f[j_2]-f[j_1]}</script><p>令$g[i] = (f[i]+L+1)^2$，可得：</p><script type="math/tex; mode=display">2f[i] \geq \frac{dp[j_2]+g[j_2] - (dp[j_1]+g[j_1])}{f[j_2]-f[j_1]}</script><p>也就是说，若$j1,j2$满足上面这个式子，那么$j2$一定比$j1$优。</p><p>为什么叫斜率优化？因为上面这个式子可以把看作$dp[i]+g[i]$看做纵坐标，$f[i]$看做横坐标，上面的等式右侧就相当于 $\frac{\Delta y}{\Delta x}=k$ 也就是一个一次函数的斜率。当这个斜率$k \leq 2f[i]$则$j_2$优于$j_1$。</p><p>假如我们有三个决策$j_1,j_2,j_3$（如下图）<br><img src="https://cdn.luogu.org/upload/pic/20775.png" alt=""></p><p>容易证明：$j_2$不可能是最优的。<br>这样一来，每两个决策间的斜率便是<strong>单调上升的</strong>。</p><p>所以有两种做法：</p><ul><li>对于$dp[i]$，有了斜率单调上升这个条件，就可以去二分最优的决策点（也就是斜率小于$2f[i]$的）。复杂度$O(n \log n)$。</li><li>又因为$f[i]$是单调递增的，可以用单调队列来维护。具体实现就是，把决策放进一个单调队列里，如果队首和当前的$i$间的斜率 $&lt;f[i]$，就把队首删掉（即h++）。对于队尾，就每次把加入$i$后不满足斜率单调上升的队尾全部删掉（即t—），最后把$i$放进单调队列就好了。</li></ul><h1 id="带权二分"><a href="#带权二分" class="headerlink" title="带权二分"></a>带权二分</h1><p>先挖个坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结了一下&lt;/p&gt;
    
    </summary>
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="决策单调性" scheme="http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="斜率优化" scheme="http://yoursite.com/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="带权二分" scheme="http://yoursite.com/tags/%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4199 「NOI2015」品酒大会</title>
    <link href="http://yoursite.com/2019/05/03/BZOJ4199/"/>
    <id>http://yoursite.com/2019/05/03/BZOJ4199/</id>
    <published>2019-05-03T08:26:54.000Z</published>
    <updated>2019-05-03T14:26:35.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定字符串 $s$ ，和每个位置上的权值 $a_i$。对于每一个 $i \in [0, n)$ 求出有多少对 $(i, j)$  满足 $LCP(sa_i, sa_j) \ge i$ 以及在这些 $(i, j)$ 中 $a_i \times a_j$  最大是多少。$sa_i$ 表示从 $i$ 开始的后缀。</p><a id="more"></a> <h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>将原串反过来建 SAM 求得后缀树。考虑后缀树上一个节点 $u$ ，这个节点代表的子串是他的任意后代的后缀 。所以每两个在其子树中的点都会对第一问的答案造成贡献。只需要维护 right 集合的大小即可。</p><p>对于第二问，乘积最大有两种可能：一个是最大的两个相乘，一个是最小的两个相乘（负负得正）。所以只需要在 dfs 的时候顺便维护子树中的最大值和最小值，与子树合并的时候维护处答案。</p><p>最后再从后往前更新一遍答案。因为小的肯定包含在大的中，对第一问做加法，第二问取 max</p><p>具体看代码</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-05-02 09:10:52</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e6</span> + <span class="number">10</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, siz[N], o[N], w[N], mx[N], mn[N], dep[N]; </span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll ans1[N], ans2[N]; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sam</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ch[<span class="number">26</span>], len, fa; </span><br><span class="line">&#125; a[N]; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v; edge *next; </span><br><span class="line">&#125; pool[N * <span class="number">2</span>], *h[N], *cur = pool; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++; p-&gt;v = v; </span><br><span class="line">  p-&gt;next = h[u], h[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, tot = <span class="number">1</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = last, tp = ++tot; last = tp; w[tp] = o[x]; </span><br><span class="line">  a[tp].len = a[p].len + <span class="number">1</span>; siz[tot] = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(; p &amp;&amp; !a[p].ch[c]; p = a[p].fa) </span><br><span class="line">    a[p].ch[c] = tp; </span><br><span class="line">  <span class="keyword">if</span>(!p) &#123;</span><br><span class="line">    a[tp].fa = <span class="number">1</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> q = a[p].ch[c]; </span><br><span class="line">    <span class="keyword">if</span>(a[q].len == a[p].len + <span class="number">1</span>) &#123;</span><br><span class="line">      a[tp].fa = q; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> cl = ++tot; a[cl] = a[q]; </span><br><span class="line">      a[cl].len = a[p].len + <span class="number">1</span>; </span><br><span class="line">      a[q].fa = a[tp].fa = cl; </span><br><span class="line">      <span class="keyword">for</span>(; p &amp;&amp; a[p].ch[c] == q; p = a[p].fa)</span><br><span class="line">        a[p].ch[c] = cl; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(siz[u] == <span class="number">1</span>) &#123;</span><br><span class="line">    mx[u] = mn[u] = w[u]; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = p-&gt;v; <span class="keyword">if</span>(v == pre) <span class="keyword">continue</span> ; </span><br><span class="line">    dep[v] = dep[u] + <span class="number">1</span>; </span><br><span class="line">    dfs(v, u); </span><br><span class="line">    <span class="keyword">if</span>(mx[u] != INF &amp;&amp; mn[u] != INF)</span><br><span class="line">      ans2[a[u].len] = max(ans2[a[u].len], max(<span class="number">1l</span>l * mx[u] * mx[v], <span class="number">1l</span>l * mn[u] * mn[v])); </span><br><span class="line">    ans1[a[u].len] += <span class="number">1l</span>l * siz[u] * siz[v]; </span><br><span class="line">    siz[u] += siz[v]; </span><br><span class="line">    mx[u] = max(mx[u], mx[v]); </span><br><span class="line">    mn[u] = min(mn[u], mn[v]); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans1[i] = <span class="number">0</span>, ans2[i] = -(ll)<span class="number">9e18</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;o[i]); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) add(s[i] - <span class="string">'a'</span>, i); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) </span><br><span class="line">    mx[i] = -INF, mn[i] = INF; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; i++) addedge(a[i].fa, i); </span><br><span class="line">  dep[<span class="number">1</span>] = <span class="number">1</span>, dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    ans1[i] += ans1[i + <span class="number">1</span>], </span><br><span class="line">    ans2[i] = max(ans2[i], ans2[i + <span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ans1[i] == <span class="number">0</span>) ans2[i] = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans1[i], ans2[i]); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定字符串 $s$ ，和每个位置上的权值 $a_i$。对于每一个 $i \in [0, n)$ 求出有多少对 $(i, j)$  满足 $LCP(sa_i, sa_j) \ge i$ 以及在这些 $(i, j)$ 中 $a_i \times a_j$  最大是多少。$sa_i$ 表示从 $i$ 开始的后缀。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="后缀自动机" scheme="http://yoursite.com/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Do geese see god?</title>
    <link href="http://yoursite.com/2019/04/30/Do-geese-see-god/"/>
    <id>http://yoursite.com/2019/04/30/Do-geese-see-god/</id>
    <published>2019-04-30T12:32:40.000Z</published>
    <updated>2019-04-30T14:50:35.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给一个字符串 $s$ 和一个整数 $k$ 。求所有最短的满足 $s$ 是他的一个子序列并且是一个回文串的字符串中字典序第 $k$ 大的。</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>令 $f[i][j]$ 表示 $s$ 中 $i$ 到 $j$ 所构成的字符串至少还要再添加几个字符使得其变成回文串。</p><p>令 $g[i][j]$ 表示满足最短的条件的前提下的添加字符的方案数。</p><p>这两个数组都可以通过简单的 $O(n^2)$ 的 dp 完成。</p><p>接下来便是求第 $k$ 大的字符串。如果 $k &gt; g[1][n]$ 直接输出无解。接下来处理有解的情况。</p><p>用 <code>solve(l, r, k)</code> 表示从 $s_l$ 到 $s_r$ 构成的字符串满足添加字符最少的前提下所构成的字典序第 $k$  大的回文串。</p><ul><li><p>$l=r$  时，直接返回 $s_l$ </p></li><li><p>$s_l = s_r$ 时，返回 <code>s[l] + solve(l + 1, r - 1, k) + s[r]</code> （这里加法 = 按顺序拼接 = string 加法）</p></li><li><p>$s_l \not= s_r$ 时，我们有两种方法</p><ol><li>把字符串变成  <code>s[l] + solve(l + 1, r) + s[l]</code>  即在后面添加一个 $s_l$ 并且把中间变成回文</li><li>把字符串变成  <code>s[r] + solve(l, r - 1) + s[r]</code>  即在前面添加一个 $s_r$ 并且把中间变成回文</li></ol><p>此时，我们显然会贪心的走字典序小的那一边，这取决于 $s_l$ 和 $s_r$ 的大小。</p><p>不妨设 $s_l &lt; s_r$ 那么如果 $g[l+1][r] &gt;= k$ 我们就直接往第一种情况递归。否则把  $k$ 减掉 $g[l+1][r]$ 放到第二种情况递归。对于 $s_l &gt; s_r$   也是同理。  </p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2005</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; ll k; </span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> f[N][N]; ll g[N][N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="string">""</span>; </span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123; <span class="built_in">string</span> t = <span class="string">""</span>; t += s[l]; <span class="keyword">return</span> t; &#125;</span><br><span class="line">  <span class="keyword">if</span>(s[l] == s[r]) </span><br><span class="line">    <span class="keyword">return</span> s[l] + solve(l + <span class="number">1</span>, r - <span class="number">1</span>, k) + s[r]; </span><br><span class="line">  <span class="keyword">if</span>(f[l + <span class="number">1</span>][r] &lt; f[l][r - <span class="number">1</span>]) <span class="keyword">return</span> s[l] + solve(l + <span class="number">1</span>, r, k) + s[l]; </span><br><span class="line">  <span class="keyword">if</span>(f[l + <span class="number">1</span>][r] &gt; f[l][r - <span class="number">1</span>]) <span class="keyword">return</span> s[r] + solve(l, r - <span class="number">1</span>, k) + s[r]; </span><br><span class="line">  <span class="keyword">if</span>(s[l] &lt; s[r]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(g[l + <span class="number">1</span>][r] &gt;= k) </span><br><span class="line">      <span class="keyword">return</span> s[l] + solve(l + <span class="number">1</span>, r, k) + s[l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s[r] + solve(l, r - <span class="number">1</span>, k - g[l + <span class="number">1</span>][r]) + s[r]; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(g[l][r - <span class="number">1</span>] &gt;= k) </span><br><span class="line">      <span class="keyword">return</span> s[r] + solve(l, r - <span class="number">1</span>, k) + s[r]; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s[l] + solve(l + <span class="number">1</span>, r, k - g[l][r - <span class="number">1</span>]) + s[l]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s %lld"</span>, s + <span class="number">1</span>, &amp;k); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][i] = <span class="number">0</span>, g[i][i] = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(l == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>]) &#123; f[i][i + <span class="number">1</span>] = <span class="number">0</span>, g[i][i + <span class="number">1</span>] = <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; f[i][i + <span class="number">1</span>] = <span class="number">1</span>; g[i][i + <span class="number">1</span>] = <span class="number">2</span>; &#125;</span><br><span class="line">        <span class="keyword">continue</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> L = i, R = (i + l - <span class="number">1</span>); </span><br><span class="line">      <span class="keyword">int</span> mn = INF; </span><br><span class="line">      <span class="keyword">if</span>(s[L] == s[R]) &#123;</span><br><span class="line">        f[L][R] = f[L + <span class="number">1</span>][R - <span class="number">1</span>];</span><br><span class="line">        g[L][R] = g[L + <span class="number">1</span>][R - <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">continue</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">      mn = min(mn, <span class="number">1</span> + min(f[L][R - <span class="number">1</span>], f[L + <span class="number">1</span>][R])); </span><br><span class="line">      f[L][R] = mn; </span><br><span class="line">      <span class="keyword">if</span>(mn == f[L + <span class="number">1</span>][R] + <span class="number">1</span>) &#123;</span><br><span class="line">        g[L][R] += g[L + <span class="number">1</span>][R]; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(mn == f[L][R - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">        g[L][R] += g[L][R - <span class="number">1</span>]; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(g[L][R] &gt; k) g[L][R] = k + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span>(k &gt; g[<span class="number">1</span>][n]) &#123; <span class="built_in">puts</span>(<span class="string">"NONE"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; solve(<span class="number">1</span>, n, k) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给一个字符串 $s$ 和一个整数 $k$ 。求所有最短的满足 $s$ 是他的一个子序列并且是一个回文串的字符串中字典序第 $k$ 大的。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef RIN</title>
    <link href="http://yoursite.com/2019/04/30/CodeChef-RIN/"/>
    <id>http://yoursite.com/2019/04/30/CodeChef-RIN/</id>
    <published>2019-04-30T12:32:27.000Z</published>
    <updated>2019-05-03T08:29:43.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>你有  $m$ 个学期来完成 $n$ 个课程，每个学期能上任意多课程，每个课程恰好被学一遍。有些课程有前置条件，必须先学 $a$ 课程才能学 $b$ 课程。在第 $i$ 个学期完成第 $j$ 这个课程能够获得 $A[i][j]$ 的分数（$A[i][j]=-1$ 说明 $i$ 学期不教授 $j$ 课程）。求最大的平均分数。</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>类似于切糕的建图方式，把每个课程拆成 $m + 1$ 个点。令第 $i$个课程拆出来的第 $j$ 个点事 $(i, j)$</p><p>对于一个课程 $i$ ，有以下的建图方式：</p><ul><li>$(i, j) \to (i,j+1)$ 连流量 $100 - A[i][j]$ 的边</li><li>$S \to (i,1)$ 和  $(i,m+1) \to T$ 都连一条流量为 INF 的边</li><li>如果已知两个课程 $a,b$ 必须使得 $a$ 是 $b$  的前置课程，那么对于 $1 \leq i \leq m-1$ 连一条 $(a,i) \to (b,i+1)$ 的流量为  INF 的边</li></ul><p>然后跑出最大流，再用 $100 - \frac{\text{最大流}}{n}$ </p><p>为什么这是对的呢？首先，总分最大就是使得减分最小，所以把每个分数用最大值($\leq 100$) 减一下跑出最小割然后用总和减掉。此时 $A[i][j]$ 就变成了 $i$ 课程在 $j$ 学期的扣分。</p><p>对于每一条学期，我们必须上一次课，在最小割中体现就是对这个学期建立一条链，割了第 $j$ 个点和第 $j+1$ 个点之间的边表示在 $j$ 这个学期上了这个课。每条链显然只会恰好割一次。</p><p>对于前置条件的限制，在最小割中的体现便是 $a$ 学期的割边在 $b$ 学期之前。那么按照第三种连边使得如果不在 $b$ 前面那么必然会有一条通路（画图理解）。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010000</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">2e9</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T, vis[N]; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, f; edge *next, *rev; </span><br><span class="line">&#125; pool[N * <span class="number">2</span>], *h[N], *cu = pool, *cur[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  edge *p = cu++, *q = cu++; </span><br><span class="line">  p-&gt;v = v, p-&gt;next = h[u], h[u] = p, p-&gt;f = f, p-&gt;rev = q; </span><br><span class="line">  q-&gt;v = u, q-&gt;next = h[v], h[v] = q, q-&gt;f = <span class="number">0</span>, q-&gt;rev = p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[N], Q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = S; i &lt;= T; i++) </span><br><span class="line">    cur[i] = h[i], dep[i] = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">1</span>, t = <span class="number">0</span>; dep[S] = <span class="number">1</span>, Q[++t] = S; </span><br><span class="line">  <span class="keyword">while</span>(s &lt;= t) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q[s++]; </span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = p-&gt;v; <span class="keyword">if</span>(p-&gt;f &amp;&amp; !dep[v]) &#123;</span><br><span class="line">        Q[++t] = v, dep[v] = dep[u] + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(v == T) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(u == T || !lim) <span class="keyword">return</span> lim; <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(edge *p = cur[u]; p; p = p-&gt;next) &#123; cur[u] = p; </span><br><span class="line">    <span class="keyword">int</span> v = p-&gt;v; <span class="keyword">if</span>(p-&gt;f &amp;&amp; dep[v] == dep[u] + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> tmp = dfs(v, min(lim, p-&gt;f)); </span><br><span class="line">      p-&gt;f -= tmp, p-&gt;rev-&gt;f += tmp; </span><br><span class="line">      ret += tmp, lim -= tmp; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">if</span>(!ret) dep[u] = <span class="number">-1</span>; </span><br><span class="line">  <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">while</span>(bfs()) ret += dfs(S, INF); </span><br><span class="line">  <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>]; </span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x - <span class="number">1</span>) * (m + <span class="number">1</span>) + y; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i][j];  </span><br><span class="line">  S = <span class="number">0</span>; T = n * (m + <span class="number">1</span>) + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    addedge(S, id(i, <span class="number">1</span>), INF); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i][j] != <span class="number">-1</span>) addedge(id(i, j), id(i, j + <span class="number">1</span>), <span class="number">100</span> - a[i][j]); </span><br><span class="line">      <span class="keyword">else</span> addedge(id(i, j), id(i, j + <span class="number">1</span>), INF); </span><br><span class="line">    &#125; addedge(id(i, m + <span class="number">1</span>), T, INF); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">      addedge(id(x, j), id(y, j + <span class="number">1</span>), INF); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, <span class="number">1.0</span> * <span class="number">100</span> - <span class="number">1.0</span> * dinic() / (<span class="number">1.0</span> * n)); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;你有  $m$ 个学期来完成 $n$ 个课程，每个学期能上任意多课程，每个课程恰好被学一遍。有些课程有前置条件，必须先学 $a$ 课程才能学 $b$ 课程。在第 $i$ 个学期完成第 $j$ 这个课程能够获得 $A[i][j]$ 的分数（$A[i][j]=-1$ 说明 $i$ 学期不教授 $j$ 课程）。求最大的平均分数。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4585 「APIO2016」烟火表演</title>
    <link href="http://yoursite.com/2019/04/05/BZOJ4585/"/>
    <id>http://yoursite.com/2019/04/05/BZOJ4585/</id>
    <published>2019-04-05T09:37:11.000Z</published>
    <updated>2019-04-05T10:42:55.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一棵以 $1$ 为根的 $n$ 个节点的树，每条边有一个边权。有 $m$ 个叶子。将一条边的边权从 $x$ 修改至 $y$ 需要的代价是 $|x-y|$  。求将所有叶子到根节点的距离修改成相同的最小代价。</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>神仙题。参考：<a href="https://blog.csdn.net/u014609452/article/details/52347062；洛谷题解第一篇。" target="_blank" rel="noopener">https://blog.csdn.net/u014609452/article/details/52347062；洛谷题解第一篇。</a></p><p>定义 $f_x(y)$ 表示将以 $x$ 为根的子树中所有叶子结点到 $x$ 节点的距离都修改成 $y$ 所需要的代价。我们得到的结论是：<strong>$f_x$ 是个分段函数，每一段为一个一次函数，并且下凸（即一个凸壳）</strong>。</p><p>这个结论的证明要用到数学归纳法，不多赘述。</p><p>考虑维护这个凸壳。即现在已知每个儿子的凸壳，应该如何合并出这个节点的凸壳。</p><p>儿子节点的凸壳首先需要往其中加入父亲到他的这一条边。可以证明有了这一条边后依然是一个凸壳。</p><p>对每个儿子都这么做，得到的所有凸壳相加即为父亲节点的凸壳。</p><p>于是问题变为如何维护 ”往上增加一条边“ 后凸壳的变化。</p><p>设增加这条边的边权是 $w$ ，要增加的这个函数是 $f$ ，新的函数是 $g$ ，最小值在 $L$ 到 $R$ 取到。</p><ol><li>对于 $x \leq L$ ，此时要把新加的这条边减成 $0$ ，代价 $w$ 即 $g(x) = f(x) + w$</li><li>对于 $L \leq x \leq L + w$ ，此时先将原来的子树里的每个叶子到根的距离修改成 $L$ ，加上 $w$ 后要再修改成 $x$ 需要 $L + w - x$ 的代价 （先把 $w$ 的边干掉然后用 $L - x$ 的代价从 $L$ 到 $x$ ）。即 $g(x) = f(x) + w + L -x$</li><li>对于 $L + w \leq x \leq R + w$ ，此时 $g(x) = f(x - w)$ 。又因为 $x - w \in [L, R]$ 都是最小值，所以 $g(x) = f(L)$ </li><li>对于 $R+w \leq x$ ，此时先将原来的子树里的每个叶子到根的距离修改成 $R$ ，加上 $w$ 再修改成 $x$ 需要 $|R + w - x| = x - w - R$ （其实和 2 差不多只是正负的问题）。即 $g(x) = f(x) + x - w - R$ </li></ol><p>容易看出，$g$ 的最小值在 $[L + w, R + w]$ 取到。</p><p>得到这些性质后，<del>我已经自闭了…</del> 我们可以分析它的几何意义。</p><p>第一段（$x \leq L$） 相当于是往上做了一个平移。</p><p>第二段（$L \leq x \leq L + w$）你会发现，$g(x) = f(x) + w - L - x$ 中有一个 $-x$ 。这说明这一段的斜率是 $-1$ </p><p>第三段（$L + w \leq x \leq R + w$）这一段其实就是一段平的（这也是为啥它是新函数取到最小值的段），斜率维 $0$</p><p>第四段（$R + w \leq x$ ）你会发现，$g(x) = f(x) + x - w - R$ 有一个 $+x$ 。这说明这一段的斜率是 $1$ </p><p>这样我们就知道了新凸壳与原来的凸壳的区别：<strong>将 $L$ 左边一段向上平移，删除右边，新增两个拐点 $L+w, R+w$ 并且 $L$  到 $L+w$ 的斜率为 $-1$ ，$L+w$ 到 $R + w$ 的斜率是 $0$，$R + w$ 往右的斜率是 $1$ </strong>。</p><p>有了这个结论，然后的做法其实还不是很显然（至少对我来说）。</p><p>这个凸壳还有一个可以证明的性质：（从左到右）每当<strong>经过一个拐点</strong>，那么<strong>斜率会增加 $1$ </strong></p><p>我们可以对每个点存放凸壳的拐点（的横坐标）。</p><p>每次将儿子节点的凸壳弹出后面的（从大到小）拐点，然后加入两个新拐点。然后将儿子节点的拐点合并到该节点的凸壳中。</p><p>这个过程中，需要支持：删除（横坐标）最大的拐点；合并。自然想到<strong>可并堆</strong>。</p><p>还剩下几个小问题：</p><ol><li><strong>实现时，如何弹出拐点直到最小值的那一段</strong>？最右边的那一段的斜率是儿子数量。（因为每合并一次右端斜率 ++） 所以弹出儿子数量个拐点即可。</li><li><strong>最后的答案如何计算？或：最小值那一段该如何计算？</strong> $f_1(0)$ 很好计算，为所有边权的和。我们又知道，每一个拐点使得斜率++。于是可以先把右边的点弹掉（儿子个），然后计算即可</li></ol><p>还有一个很骚的操作，即一种快乐的可并堆：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x + y; </span><br><span class="line">  <span class="keyword">if</span>(vx[x] &lt; vx[y]) swap(x, y); </span><br><span class="line">  <span class="keyword">int</span> d = rand() % <span class="number">2</span>; </span><br><span class="line">  ch[x][d] = merge(ch[x][d], y); </span><br><span class="line">  <span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒人专用，复杂度很对（426ms）。会证明复杂度的可以私信我，我太菜了不会证…</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-03-19 21:45:47</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair <span class="meta-string">&lt;int, int&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Se second </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(RG int i = l; i &lt;= r; i++) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(RG int i = r; i &gt;= l; i--)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios :: sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="function"><span class="keyword">void</span> <span class="title">sc</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c = getchar(); T x = <span class="number">1</span>; t = <span class="number">0</span>; <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) x = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) t = t * <span class="number">10</span> + c - <span class="string">'0'</span> , c = getchar();t *= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T , <span class="keyword">typename</span>... Args &gt; <span class="function"><span class="keyword">void</span> <span class="title">sc</span><span class="params">(T&amp; t , Args&amp;... args)</span> </span>&#123;sc(t); sc(args...);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600300</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, fa[N], son[N];</span><br><span class="line">ll w[N], ans, vx[N];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, ch[N][<span class="number">2</span>], rt[N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">New</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  vx[++cnt] = x; ch[cnt][<span class="number">0</span>] = ch[cnt][<span class="number">1</span>] = <span class="number">0</span>; <span class="keyword">return</span> cnt; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x + y; </span><br><span class="line">  <span class="keyword">if</span>(vx[x] &lt; vx[y]) swap(x, y); </span><br><span class="line">  <span class="keyword">int</span> d = rand() % <span class="number">2</span>; </span><br><span class="line">  ch[x][d] = merge(ch[x][d], y); </span><br><span class="line">  <span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// INIT(); </span></span><br><span class="line">  srand((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)<span class="keyword">new</span> <span class="keyword">char</span>); </span><br><span class="line">  sc(n, m); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">    sc(fa[i], w[i]); ans += w[i]; son[fa[i]]++; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n + m; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= son[i] - <span class="number">1</span>; j++)</span><br><span class="line">      rt[i] = merge(ch[rt[i]][<span class="number">0</span>], ch[rt[i]][<span class="number">1</span>]); </span><br><span class="line">    ll R = vx[rt[i]]; rt[i] = merge(ch[rt[i]][<span class="number">0</span>], ch[rt[i]][<span class="number">1</span>]); </span><br><span class="line">    ll L = vx[rt[i]]; rt[i] = merge(ch[rt[i]][<span class="number">0</span>], ch[rt[i]][<span class="number">1</span>]); </span><br><span class="line">    rt[i] = merge(rt[i], merge(New(L + w[i]), New(R + w[i])));  </span><br><span class="line">    rt[fa[i]] = merge(rt[fa[i]], rt[i]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= son[<span class="number">1</span>]; j++) </span><br><span class="line">    rt[<span class="number">1</span>] = merge(ch[rt[<span class="number">1</span>]][<span class="number">0</span>], ch[rt[<span class="number">1</span>]][<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">while</span>(rt[<span class="number">1</span>]) &#123;</span><br><span class="line">    ans -= vx[rt[<span class="number">1</span>]]; </span><br><span class="line">    rt[<span class="number">1</span>] = merge(ch[rt[<span class="number">1</span>]][<span class="number">0</span>], ch[rt[<span class="number">1</span>]][<span class="number">1</span>]); </span><br><span class="line">  &#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定一棵以 $1$ 为根的 $n$ 个节点的树，每条边有一个边权。有 $m$ 个叶子。将一条边的边权从 $x$ 修改至 $y$ 需要的代价是 $|x-y|$  。求将所有叶子到根节点的距离修改成相同的最小代价。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="可并堆" scheme="http://yoursite.com/tags/%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>HDU6203 ping ping ping</title>
    <link href="http://yoursite.com/2019/04/05/HDU6203/"/>
    <id>http://yoursite.com/2019/04/05/HDU6203/</id>
    <published>2019-04-05T09:13:23.000Z</published>
    <updated>2019-04-05T09:29:36.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给你一颗以 $0$ 为根的有根树。现在有些节点坏掉了，与周围无法联通。已知 $m$ 对 $(u,v)​$ 无法联通，求最少坏了几个节点。</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>对于一对无法联通的节点 $(u,v)$，一般是贪心地删掉 $u, v$ 的 LCA。但如果这条链在之前删除其他链的 LCA 时已经不联通了，那么就可以直接跳过。</p><p>所以得到一个做法：求出每对 $(u,v)$ 的 LCA ，按照深度从大到小排序。依次处理。如果当前的链上已经有点被删除了，直接跳过；否则 ans++，将 LCA 打个标记表示已被删除。可以用树链剖分维护。</p><p>考虑更简单的做法。因为已经将 LCA 的深度从大到小排过序了，所以每次删除 LCA 可以直接把 LCA 这个子树里的所有点打上标记（加上1）与只打 LCA 一个标记是等价的。这个过程直接用树状数组维护 dfs 序就可以了。</p><p>时间复杂度 $O(m \log n)$ </p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, tot, dep[N], fa[N][<span class="number">19</span>], dfn[N], siz[N]; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v; edge *next;              </span><br><span class="line">&#125; pool[N * <span class="number">2</span>], *head[N], *cur = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++, *q = cur++; </span><br><span class="line">  p-&gt;v = v, p-&gt;next = head[u], head[u] = p; </span><br><span class="line">  q-&gt;v = u, q-&gt;next = head[v], head[v] = q; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  siz[u] = <span class="number">1</span>; dfn[u] = ++tot; </span><br><span class="line">  <span class="keyword">for</span>(edge *p = head[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = p-&gt;v; <span class="keyword">if</span>(v == pre) <span class="keyword">continue</span> ; </span><br><span class="line">    dep[v] = dep[u] + <span class="number">1</span>; fa[v][<span class="number">0</span>] = u; </span><br><span class="line">    dfs(v, u); siz[u] += siz[v]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, lca; </span><br><span class="line">&#125;E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v); </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; i--)  </span><br><span class="line">    <span class="keyword">if</span>(dep[fa[u][i]] &gt;= dep[v]) </span><br><span class="line">      u = fa[u][i]; </span><br><span class="line">  <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    <span class="keyword">if</span>(fa[u][i] != fa[v][i]) </span><br><span class="line">      u = fa[u][i], v = fa[v][i]; </span><br><span class="line">  <span class="keyword">return</span> fa[u][<span class="number">0</span>]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dep[x.lca] &gt; dep[y.lca]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n + <span class="number">1</span>; i += lb(i)) </span><br><span class="line">    c[i] += d; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lb(i))</span><br><span class="line">    ret += c[i]; </span><br><span class="line">  <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  add(l, <span class="number">1</span>), add(r + <span class="number">1</span>, <span class="number">-1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep)); </span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)); </span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn)); </span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c)); </span><br><span class="line">    tot = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">      head[i] = <span class="literal">NULL</span>; </span><br><span class="line">    cur = pool; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v); </span><br><span class="line">      u++, v++; addedge(u, v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m); </span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v); u++, v++; </span><br><span class="line">      E[i].u = u, E[i].v = v, E[i].lca = LCA(u, v); </span><br><span class="line">    &#125; sort(E + <span class="number">1</span>, E + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = E[i].u, v = E[i].v, lca = E[i].lca; </span><br><span class="line">      <span class="keyword">if</span>(!sum(dfn[u]) &amp;&amp; !sum(dfn[v])) </span><br><span class="line">        ans++, A(dfn[lca], dfn[lca] + siz[lca] - <span class="number">1</span>); </span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给你一颗以 $0$ 为根的有根树。现在有些节点坏掉了，与周围无法联通。已知 $m$ 对 $(u,v)​$ 无法联通，求最少坏了几个节点。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>BJOI2019 游记</title>
    <link href="http://yoursite.com/2019/03/31/BJOI2019-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/31/BJOI2019-游记/</id>
    <published>2019-03-31T07:10:29.000Z</published>
    <updated>2019-05-28T13:27:54.259Z</updated>
    
    <content type="html"><![CDATA[<p>提前占坑。记录第一次省（bao）选（ling）</p><a id="more"></a><hr><h1 id="Day-n"><a href="#Day-n" class="headerlink" title="Day -n"></a>Day -n</h1><p>颓废</p><h1 id="Day-m"><a href="#Day-m" class="headerlink" title="Day -m"></a>Day -m</h1><p>模拟赛（集训）爆零（严肃）</p><p><a href="https://lim817.github.io/2019/04/06/BJOI2019-%E6%B8%B8%E8%AE%B0/" target="_blank" rel="noopener">AK大佬点这里</a></p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>复习期中</p><p>打了些板子</p><p>准备迎接退役（雾</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>密码输错了几次..开题</p><p>T1 什么鬼…字符串匹配？…几何平均值？？</p><p>T2 emm感觉很可做</p><p>T3 什么鬼…看了下标题和题面长度，然后就几乎没看过…现在都不知道题意是啥（事实证明这决策非常对</p><p>T1 想了一会感觉这个15分很好拿，先放着，20min写得完。感觉下面可以搞个dp但是输出方案不好弄写起来性价比有点低放了去看 T2</p><p>T2 显然这个 2*n 就是求区间 C_{斐波数列}^{k} 的和。把组合数拆一下发现可以直接预处理出几次方的系数。然后问题转化成前缀和减一下。貌似能直接矩阵快速幂，写起来不算特别麻烦。算了下复杂度勉强能过  k &lt;= 50 突然发现 l, r 比较小的可以直接跑如果 k 太大反而不能用矩阵快速幂。于是就写写写。写了2个小时(3个小时?我还是太弱了码力不够)过了第一个样例（中间差点心态崩了）。最后写了一坨奇怪的代码</p><p>3*n 有点卡住，时间只剩 2h 了吧（记不清了）。然后回去写了一发 T2 的暴力。然后还剩 1.5h-。回去想 T2。手花了几种方格图发现是由这个 3 乘 奇数多一块 或者 3 乘偶数少一块递推而来的。设了个方程解出来是 4乘前面一项减去前面两项的数。也是一个二阶线性递推。还剩 1h+ 赶紧把前面的代码复制粘贴魔改了一番系数然后调了半天还剩 20min 的时候调出来了。过了两个样例心情舒坦。最后还发现 T3 有个无解输出个 -1 。检查了一番文件名就结束了。</p><p>中午（看大佬）颓废。等分真是漫长。</p><p>出分了。 15 + 65 + 0 丢了 5 分还行。rk16(17?)?!出人意料…</p><p>讲题，T1貌似听上去很套路？取个 log 变成平均数，然后二分，然后 AC自动机上dp？反正肯定是不会的。</p><p>T2正解要用什么奇怪的扩展整数域，听得很懵。。</p><p>T3全程掉线，我题意都不知道是啥（我还是太菜了</p><p>晚上还是要复习万恶的期中（（（</p><p>Day2 爆零预备</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提前占坑。记录第一次省（bao）选（ling）&lt;/p&gt;
    
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="省选游记" scheme="http://yoursite.com/tags/%E7%9C%81%E9%80%89%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="爆零" scheme="http://yoursite.com/tags/%E7%88%86%E9%9B%B6/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3143 「HNOI2013」游走</title>
    <link href="http://yoursite.com/2019/03/22/BZOJ3143/"/>
    <id>http://yoursite.com/2019/03/22/BZOJ3143/</id>
    <published>2019-03-22T09:04:09.000Z</published>
    <updated>2019-03-22T11:24:56.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>$n$ 个点 $m$ 条边的无向连通图，在上面从 $1$ 号点开始随机游走。现在你可以给每条边从 $1$ 到 $m$ 编号作为分数（经过就得分）。求如何编号使得总分的期望最小。输出这个最小值即可。</p><p>$n \leq 500$ </p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>如果知道了每条边被经过的期望次数，那么根据排序不等式显然是逆序分配最小。</p><p>设 $f_u$ 是 $u$ 点被经过的期望次数，$deg_u$ 表示 $u$ 的度数。那么边 $(u, v)$ 被经过的期望次数是 </p><script type="math/tex; mode=display">\frac{f_u}{deg_u}+\frac{f_v}{deg_v}</script><p>$f$ 的求法比较简单，即 </p><script type="math/tex; mode=display">f_u = \sum\limits_{(u,v) \in E} \frac{f_v}{deg_v}</script><p>高斯消元一波再排个序就做完了。时间复杂度 $O(n^3)$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-03-18 22:13:03</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair <span class="meta-string">&lt;int, int&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Se second </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(RG int i = l; i &lt;= r; i++) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(RG int i = r; i &gt;= l; i--)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios :: sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, deg[N]; </span><br><span class="line">PII E[N * N]; </span><br><span class="line">db a[N][N], t[N]; </span><br><span class="line">db A[N * N], ans; </span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  rep(u, <span class="number">1</span>, n) &#123;</span><br><span class="line">    a[u][u] = <span class="number">1.0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) </span><br><span class="line">      <span class="keyword">if</span>(v != n)</span><br><span class="line">        a[u][v] -= <span class="number">1.0</span> / deg[v];  </span><br><span class="line">  &#125; a[<span class="number">1</span>][n + <span class="number">1</span>] = <span class="number">1.0</span>; </span><br><span class="line">  a[n][n + <span class="number">1</span>] = <span class="number">-1.0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = i;</span><br><span class="line">    rep(j, i + <span class="number">1</span>, n) </span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i]) &gt; <span class="built_in">fabs</span>(a[p][i] + <span class="number">1e-13</span>))</span><br><span class="line">        p = j; </span><br><span class="line">    rep(j, i + <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i]) &lt; <span class="number">1e-13</span>) <span class="keyword">continue</span> ; </span><br><span class="line">      db cof = a[j][i] / a[i][i]; </span><br><span class="line">      rep(k, i, n + <span class="number">1</span>) </span><br><span class="line">        a[j][k] -= a[i][k] * cof; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  per(i, n, <span class="number">1</span>) &#123;</span><br><span class="line">    rep(j, i + <span class="number">1</span>, n) </span><br><span class="line">      a[i][n + <span class="number">1</span>] -= a[i][j] * t[j];</span><br><span class="line">    t[i] = a[i][n + <span class="number">1</span>] / a[i][i]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  INIT(); </span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m; </span><br><span class="line">  rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v; <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v; </span><br><span class="line">    E[i] = MP(u, v); </span><br><span class="line">    deg[u]++, deg[v]++;</span><br><span class="line">    g[u].pb(v), g[v].pb(u); </span><br><span class="line">  &#125; build(n), gauss(n); </span><br><span class="line">  rep(i, <span class="number">1</span>, m) </span><br><span class="line">    A[i] = <span class="number">1.0</span> * t[E[i].Fi] / deg[E[i].Fi] + </span><br><span class="line">           <span class="number">1.0</span> * t[E[i].Se] / deg[E[i].Se]; </span><br><span class="line">  sort(A + <span class="number">1</span>, A + m + <span class="number">1</span>);</span><br><span class="line">  rep(i, <span class="number">1</span>, m) ans += A[i] * (m - i + <span class="number">1</span>); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;$n$ 个点 $m$ 条边的无向连通图，在上面从 $1$ 号点开始随机游走。现在你可以给每条边从 $1$ 到 $m$ 编号作为分数（经过就得分）。求如何编号使得总分的期望最小。输出这个最小值即可。&lt;/p&gt;
&lt;p&gt;$n \leq 500$ &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="概率期望" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="高斯消元" scheme="http://yoursite.com/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4008 「HNOI2015」亚瑟王</title>
    <link href="http://yoursite.com/2019/03/22/BZOJ4008/"/>
    <id>http://yoursite.com/2019/03/22/BZOJ4008/</id>
    <published>2019-03-22T09:03:59.000Z</published>
    <updated>2019-03-22T11:52:32.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有 $n$ 张卡牌，$r$ 局游戏，每张卡牌有 $p_i$ 的概率发动技能，如果发动会造成 $d_i​$ 的伤害。每局游戏从第一张卡牌开始开始一个个遍历，如果发动过技能则忽略继续；否则如果这张卡牌现在发动了，则结束回合；没有发动则继续。求造成的总伤害的期望。</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>可以想象成把 $r$ 个机会分配给每一张卡牌。$dp[i][j]$ 表示前 $i$ 张还剩 $j$ 个机会的答案 </p><script type="math/tex; mode=display">dp[i][j] = dp[i-1][j] \cdot (1-p[i])^j+dp[i-1][j+1]\cdot (1-(1-p[i])^{j+1})</script><p>前半部分可以理解成在 $j$ 轮没有一次触发，后半部分就是至少一次触发。并且后半部分因为出触发了所以对答案有贡献，所以在 dp 的时候顺便把 ans 加上后半部分 * $d_i$ </p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-03-17 15:45:54</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair <span class="meta-string">&lt;int, int&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Se second </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(RG int i = l; i &lt;= r; i++) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(RG int i = r; i &gt;= l; i--)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios :: sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, r, d[N]; </span><br><span class="line">db f[N][N], p[N]; </span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">fpw</span><span class="params">(db x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  db ret = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">while</span>(k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ret = ret * x;</span><br><span class="line">    x = x * x; k &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">  &#125; <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  INIT(); </span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; T; </span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r; </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)); </span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; p[i] &gt;&gt; d[i]; </span><br><span class="line">    f[<span class="number">0</span>][r] = <span class="number">1</span>; db ans = <span class="number">0</span>; </span><br><span class="line">    rep(i, <span class="number">1</span>, n) </span><br><span class="line">      per(j, r, <span class="number">0</span>) </span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j] * fpw(<span class="number">1</span> - p[i], j) + f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (<span class="number">1</span> - fpw(<span class="number">1</span> - p[i], j + <span class="number">1</span>)), </span><br><span class="line">        ans += d[i] * f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (<span class="number">1</span> - fpw(<span class="number">1</span> - p[i], j + <span class="number">1</span>)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;有 $n$ 张卡牌，$r$ 局游戏，每张卡牌有 $p_i$ 的概率发动技能，如果发动会造成 $d_i​$ 的伤害。每局游戏从第一张卡牌开始开始一个个遍历，如果发动过技能则忽略继续；否则如果这张卡牌现在发动了，则结束回合；没有发动则继续。求造成的总伤害的期望。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="概率期望" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2134 单选错位</title>
    <link href="http://yoursite.com/2019/03/22/BZOJ2134/"/>
    <id>http://yoursite.com/2019/03/22/BZOJ2134/</id>
    <published>2019-03-22T09:03:51.000Z</published>
    <updated>2019-03-22T09:14:05.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>$n$ 道题，第 $i$ 道题有 $a_i$ 个选项。求将正确答案全部右移一位（第 $n$ 题移到第 $1$ 题）之后期望对的题数</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>答案 = 期望多少个 $i$ 满足 $ans_i = ans_{i+1}$ 也 = sum $ans_i = ans_{i+1}$ 的期望也就是 $\sum \frac{\min\{a_i, a_{i+1}\}}{a_ia_{i+1}}=\sum\frac{1}{\max\{a_i,a_{i+1}\}}$ （为了方便设 $a_{n+1}=a_1$）</p><p>做完了</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-03-20 14:41:06</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, A, B, C, a[<span class="number">10000002</span>]; </span><br><span class="line"><span class="keyword">double</span> ans; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;n,&amp;A,&amp;B,&amp;C,a+<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">    a[i] = ((<span class="keyword">long</span> <span class="keyword">long</span>)a[i - <span class="number">1</span>] * A + B) % <span class="number">100000001</span>; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    a[i] = a[i] % C + <span class="number">1</span>; </span><br><span class="line">  a[n + <span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += <span class="number">1.0</span> / max(a[i], a[i + <span class="number">1</span>]); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;$n$ 道题，第 $i$ 道题有 $a_i$ 个选项。求将正确答案全部右移一位（第 $n$ 题移到第 $1$ 题）之后期望对的题数&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="概率期望" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4665 小w的喜糖</title>
    <link href="http://yoursite.com/2019/03/17/BZOJ4665/"/>
    <id>http://yoursite.com/2019/03/17/BZOJ4665/</id>
    <published>2019-03-17T13:57:09.000Z</published>
    <updated>2019-03-17T14:59:28.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>$n$ 颗糖发给了 $n$ 个人，每颗糖有一个种类。$n$ 个人相互交换手中的糖那么有多少种方案使得每个人手中的糖的种类都与原来不同。</p><p>两个方案不同当且仅当，存在一个人，他手中的糖的种类在两个方案中不一样。</p><p>答案对 $10^9 + 9$ 取模</p><a id="more"></a> <p>答案对 $10^9 + 9$ 取模！！！！！ $10^9 + 9$  ！！！！ $10^9 + 9$ ！！！！！ $10^9 + 9$ ！！！！！</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>可以暂时不考虑相同种类糖之间的关系，把它们当成不同的最后把答案乘上 $\frac{1}{\Pi_{i} a_i!}$ . $a_i$ 表示种类 $i$ 的糖数</p><p>设 $dp[i][j]$ 表示前 $i$ 种糖至少有 $j$ 个人不合法（即手中拿的糖和原来一样。那么有</p><script type="math/tex; mode=display">dp[i][j] = \sum\limits_{k=0}^{\min(a_i,j)} \binom{a_i}{k} \cdot dp[i-1][j-k] \cdot a_i(a_i-1)\cdots(a_i - k + 1)</script><p>然后对于答案就可以直接容斥得到 </p><script type="math/tex; mode=display">ans = \sum\limits_{i=0}^{n} (-1)^{i}dp[n][i]\cdot(n-i)!</script><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-03-04 21:07:09</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(RG int i = l; i &lt;= r; i++) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(RG int i = r; i &gt;= l; i--)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios :: sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2005</span>; </span><br><span class="line"><span class="keyword">const</span> ll mod = (ll)<span class="number">1e9</span> + <span class="number">9</span>; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpw</span><span class="params">(ll x, ll k, ll p)</span> </span>&#123;</span><br><span class="line">  ll ret = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">while</span>(k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ret = ret * x % p; </span><br><span class="line">    x = x * x % p; k &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">  &#125; <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N]; </span><br><span class="line">ll dp[N][N], inv[N], invf[N], fac[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = invf[<span class="number">0</span>] = invf[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">  rep(i, <span class="number">2</span>, n) </span><br><span class="line">    inv[i] = (mod - mod / i) * inv[mod % i] % mod, </span><br><span class="line">    fac[i] = fac[i - <span class="number">1</span>] * i % mod, </span><br><span class="line">    invf[i] = invf[i - <span class="number">1</span>] * inv[i] % mod; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> fac[n] * invf[m] % mod * invf[n - m] % mod; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  INIT(); </span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n; </span><br><span class="line">  prework(); </span><br><span class="line">  rep(i, <span class="number">1</span>, n) &#123; <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t; a[t]++; &#125; </span><br><span class="line">  ll ans = <span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">  rep(i, <span class="number">1</span>, n) rep(j, <span class="number">0</span>, n)</span><br><span class="line">    rep(k, <span class="number">0</span>, min(a[i], j)) </span><br><span class="line">      dp[i][j] += <span class="number">1l</span>l * dp[i - <span class="number">1</span>][j - k] * C(a[i], k) % mod * fac[a[i]] % mod * invf[a[i] - k] % mod, </span><br><span class="line">      dp[i][j] %= mod; </span><br><span class="line">  <span class="comment">// rep(i, 0, n) cout &lt;&lt; dp[n][i] &lt;&lt; " "; </span></span><br><span class="line">  rep(i, <span class="number">0</span>, n) ans += <span class="number">1l</span>l * ((i &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span>) * dp[n][i] % mod * fac[n - i] % mod, ans %= mod, ans += mod, ans %= mod; </span><br><span class="line">  rep(i, <span class="number">1</span>, n) ans *= invf[a[i]], ans %= mod; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ((ans % mod + mod) % mod);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;$n$ 颗糖发给了 $n$ 个人，每颗糖有一个种类。$n$ 个人相互交换手中的糖那么有多少种方案使得每个人手中的糖的种类都与原来不同。&lt;/p&gt;
&lt;p&gt;两个方案不同当且仅当，存在一个人，他手中的糖的种类在两个方案中不一样。&lt;/p&gt;
&lt;p&gt;答案对 $10^9 + 9$ 取模&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="容斥" scheme="http://yoursite.com/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4361 isn</title>
    <link href="http://yoursite.com/2019/03/17/BZOJ4361/"/>
    <id>http://yoursite.com/2019/03/17/BZOJ4361/</id>
    <published>2019-03-17T13:57:00.000Z</published>
    <updated>2019-03-17T14:46:10.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给出一个长度为 $n$ 的序列 $A(A_1,A_2 \cdot A_n)$。如果序列 $A$ 不是非降的，你必须从中删去一个数这一操作，直到 $A$ 非降为止。求有多少种不同的操作方案，答案模 $10^9+7$ 。</p><a id="more"></a> <h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>设 $dp[i][j]$ 表示以 $i$ 这个点结尾，长度恰好为 $j$ 的非降子序列的个数 </p><p>求法要用树状数组维护（还要离散化）</p><p>考虑怎么求出答案 令 $g[i]$ 为有多少个长度为 $i$ 的非降子序列即</p><script type="math/tex; mode=display">g[i] = \sum\limits_{j=1}^{n} dp[j][i]</script><p>那么有：将原序列删除到长度为 $i$ 的子序列的方案数是</p><script type="math/tex; mode=display">g[i] \cdot (n-i)!</script><p>乍看很对，仔细一想其实这不是对的：<strong>因为并没有考虑在 (i+1) 的时候已经达到状态就不会再继续进行操作</strong></p><p>如果当前不合法那么这个序列只有可能是从 $i+1$ 的状态选择了一个数删掉得到的。所以有</p><script type="math/tex; mode=display">ans = \sum\limits_{i = 1} ^ {n} g[i] \cdot (n - i)! - (i + 1) \cdot g[i + 1] \cdot (n - i - 1)!</script><p>时间复杂度：$O(n^2 \log n)$ </p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: AcFunction</span></span><br><span class="line"><span class="comment"> * Date:   2019-03-04 19:04:32</span></span><br><span class="line"><span class="comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(RG int i = l; i &lt;= r; i++) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, r, l) for(RG int i = r; i &gt;= l; i--)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INIT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios :: sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2005</span>; </span><br><span class="line"><span class="keyword">const</span> ll mod = (ll)<span class="number">1e9</span> + <span class="number">7</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], f[N][N];</span><br><span class="line"></span><br><span class="line">ll fac[N], g[N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> c[N]; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= N; i += lb(i))</span><br><span class="line">      c[i] += d, c[i] %= mod; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lb(i)) </span><br><span class="line">      ret += c[i], ret %= mod; </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125; b[N]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> aa[N]; </span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp; <span class="keyword">int</span> cnt; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  INIT(); </span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n; rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; aa[i], a[i] = aa[i]; </span><br><span class="line">  sort(aa + <span class="number">1</span>, aa + n + <span class="number">1</span>); </span><br><span class="line">  rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!mp[aa[i]]) mp[aa[i]] = ++cnt; </span><br><span class="line">  &#125;</span><br><span class="line">  rep(i, <span class="number">1</span>, n) a[i] = mp[a[i]]; </span><br><span class="line">  rep(i, <span class="number">1</span>, n) f[i][<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">  rep(j, <span class="number">2</span>, n) &#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      f[i][j] = b[j - <span class="number">1</span>].sum(a[i]); </span><br><span class="line">      b[j - <span class="number">1</span>].add(a[i], f[i][j - <span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">  ll ans = <span class="number">0</span>; </span><br><span class="line">  rep(i, <span class="number">2</span>, n) fac[i] = fac[i - <span class="number">1</span>] * i % mod; </span><br><span class="line">  rep(i, <span class="number">1</span>, n) </span><br><span class="line">    rep(j, <span class="number">1</span>, n) </span><br><span class="line">      g[i] += f[j][i], g[i] %= mod; </span><br><span class="line">  rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    ans += ((g[i] * fac[n - i] % mod) - ((i + <span class="number">1</span>) * g[i + <span class="number">1</span>] % mod * fac[n - i - <span class="number">1</span>]) % mod) % mod;</span><br><span class="line">    ans %= mod;  </span><br><span class="line">  &#125; <span class="built_in">cout</span> &lt;&lt; (ans + mod) % mod &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给出一个长度为 $n$ 的序列 $A(A_1,A_2 \cdot A_n)$。如果序列 $A$ 不是非降的，你必须从中删去一个数这一操作，直到 $A$ 非降为止。求有多少种不同的操作方案，答案模 $10^9+7$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="容斥" scheme="http://yoursite.com/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
