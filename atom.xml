<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AcF&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-01T11:36:56.169Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AcFunction</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>杜教筛学习笔记</title>
    <link href="http://yoursite.com/2019/03/01/%E6%9D%9C%E6%95%99%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/01/杜教筛学习笔记/</id>
    <published>2019-03-01T11:13:21.000Z</published>
    <updated>2019-03-01T11:36:56.169Z</updated>
    
    <content type="html"><![CDATA[<p>设现在要求积性函数 $f$ 的前缀和， 设  $\sum \limits_{i=1}^{n} f(i) = S(n)$。</p><p>再找一个积性函数 $g$ ，则考虑它们的狄利克雷卷积的前缀和</p><p>$$<br>\begin{aligned}<br>\sum\limits_{i=1}^{n}(f*g)(i)<br>&amp;= \sum\limits_{i=1}^{n} \sum \limits _{d|i} f(d)g(\frac{i}{d}) \\<br>&amp;= \sum \limits _{d=1}^{n} g(d)\sum\limits _{i=1}^{\lfloor \frac{n}{d}\rfloor } f(i) \\<br>&amp;= \sum \limits _{d=1}^{n} g(d) S(\lfloor \frac{n}{d} \rfloor)<br>\end{aligned}<br>$$</p><p>其中得到第一行是根据狄利克雷卷积的定义。</p><p>得到第二行则是先枚举 $d$ 提出 $g$ 。</p><p>得到第三行则是把 $\sum\limits _{i=1}^{\lfloor \frac{n}{d}\rfloor } f(i) $ 替换为 $S(\lfloor \frac{n}{d} \rfloor) $</p><p>接着考虑 $g(1)S(n)$ 等于什么。</p><p>可以发现，他就等于<br>$$<br>\sum \limits _{i=1}^{n} g(i) S(\lfloor \frac{n}{i} \rfloor) - \sum \limits _{i=2}^{n} g(i) S(\lfloor \frac{n}{i} \rfloor)<br>$$<br>（可以理解成从1开始的前缀和减去从2开始的前缀和就是第一项）</p><p>前面这个式子 $\sum \limits _{i=1}^{n} g(i) S(\lfloor \frac{n}{i} \rfloor)$  </p><p>根据刚才的推导，他就等于 $\sum\limits_{i=1}^{n}(f*g)(i)$</p><p>所以得到杜教筛的核心式子：</p><p>$$g(1)S(n)=\sum\limits_{i=1}^{n}(f*g)(i) - \sum \limits _{i=2}^{n} g(i) S(\lfloor \frac{n}{i} \rfloor)$$</p><p>得到这个式子之后有什么用呢？</p><p>现在如果可以找到一个合适的积性函数 $g$ ，使得可以快速算出 $\sum\limits_{i=1}^{n}(f*g)(i)$ 和 $g$ 的前缀和，便可以用数论分块递归地求解。</p><p>代码按照理解大概可以写成这样（默认 <code>ll</code> 为 <code>long long</code>）<br>（可以理解成一个伪代码。。就是一个思路的框架）<br><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">ll <span class="hljs-title">GetSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123; <span class="hljs-comment">// 算 f 前缀和的函数</span></span><br><span class="line">  ll ans = f_g_sum(n); <span class="hljs-comment">// 算 f * g 的前缀和</span></span><br><span class="line">  <span class="hljs-comment">// 以下这个 for 循环是数论分块</span></span><br><span class="line">  <span class="hljs-keyword">for</span>(ll l = <span class="hljs-number">2</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 注意从 2 开始</span></span><br><span class="line">    r = (n / (n / l)); </span><br><span class="line">    ans -= (g_sum(r) - g_sum(l - <span class="hljs-number">1</span>)) * GetSum(n / l);</span><br><span class="line">    <span class="hljs-comment">// g_sum 是 g 的前缀和</span></span><br><span class="line">    <span class="hljs-comment">// 递归 GetSum 求解</span></span><br><span class="line">  &#125; <span class="hljs-keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码的复杂度是 $O(n^{\frac{3}{4}})$，证明如下：</p><p>设求出 $S(n)$ 的复杂度是 $T(n)$ ，要求出 $S(n)$ 需要求出 $\sqrt n$ 个 $S (\lfloor \frac{n}{i} \rfloor)$ 的值，结合数论分块的复杂度 $O(\sqrt n)$ 可得：<br>$$T(n) = \sum\limits_{i=1}^{\sqrt n} O(\sqrt i) + O(\sqrt {\frac{n}{i}})=O(n^{\frac{3}{4}})$$</p><p>还可以进一步优化杜教筛，即先线性筛出前 $m$ 个答案，之后再用杜教筛。这个优化之后的复杂度是：</p><p>$$T(n) = \sum\limits_{i=1}^{\lfloor \frac{n}{m} \rfloor} \sqrt \frac{n}{i} = O({\frac{n}{\sqrt m}})$$</p><p>当 $m = n ^ {\frac{2}{3}}$ 时，$T(n) = O(n^{\frac{2}{3}})$</p><p>可以使用哈希表来存下已经求过的答案，也可以不用。</p><p>考虑到上面的求和过程中出现的都是 $\lfloor \frac{n}{i} \rfloor $ 。开一个大小为两倍 $\sqrt n$ 的数组 $dp$ 记录答案。如果现在需要求出 <code>GetSum(x)</code> ，若 $x \leq \sqrt n$ ，返回 <code>dp[x]</code> ，否则返回 <code>dp[sqrt n + n / i]</code> 即可。这样可以省去哈希表的复杂度。</p><p>$$lim_{1\to+\infty}P(|\frac{1}{n}\sum_i^nX_i-\mu|&lt;\epsilon)=1, i=1,…,n$$  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设现在要求积性函数 $f$ 的前缀和， 设  $\sum \limits_{i=1}^{n} f(i) = S(n)$。&lt;/p&gt;
&lt;p&gt;再找一个积性函数 $g$ ，则考虑它们的狄利克雷卷积的前缀和&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;\sum\l
      
    
    </summary>
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="杜教筛" scheme="http://yoursite.com/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3160 万径人踪灭</title>
    <link href="http://yoursite.com/2019/02/28/BZOJ3160/"/>
    <id>http://yoursite.com/2019/02/28/BZOJ3160/</id>
    <published>2019-02-28T10:58:37.000Z</published>
    <updated>2019-02-28T11:26:48.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个字符串由 ‘a’ 或 ‘b’ 组成。求有多少个子序列满足字母和坐标都关于一条对称轴对称并且不是连续的</p><p>字符串长度 $=n \leq 10^5$</p><a id="more"></a> <h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>默认字符串为 $S$ 从 $0$ 开始标号。 </p><p>答案等于所有的满足字母和坐标都关于一条对称轴对称的子序列数量 - 连续的满足这个性质的子序列数量</p><p>后面这个可以直接用 <strong>manacher算法</strong> 直接求出，只需要考虑前面怎么求</p><p>考虑怎么算出关于第 $i$ 个位置对称的子序列个数。设有 $k$ 组 $(x, y)$ 使得 $x + y = 2 i$ 且 $x, y \not= i$ 且 $S_x = S_y$ ，那么方案数就是 $2^{k+1}-1$ （k 组和 $i$ 这个位置选不选减去都不选的一种情况）</p><p>考虑怎么算出关于第 $i$ 到第 $i+1$ 个位置中间这个空隙（可以认为是 $i + \frac{1}{2}$）对称的子序列的个数。设有 $k$ 组 $(x,y)$ 满足 $S_x = S_y$ 且 $x+y = 2(i+\frac{1}{2}) = 2i + 1$ ，那么方案数就是 $2^k - 1$（和上面不一样的原因是自己这个位置不是整数不能被选所以不用考虑）</p><p>令 $ f_i = \sum\limits_{x+y=i} [S_x=S_y] $ ，那么 $f_i$ 和这个 $k$ 的关系是什么呢？</p><p>这里要想清楚。当 $i$ 是偶数的时候，$[S_{\frac{i}{2}}=S_{\frac{i}{2}}]$ 其实也被算了进去，所以应该是 $f_i = 2k + 1$；而 $i$ 是奇数的时候就没有这个问题，直接就是 $f_i = 2k$；综合一下其实就是 $k = \lfloor \frac{f_i}{2} \rfloor$</p><p>然后就是怎么求 $f_i$ 的问题了。这是一个卷积的形式，又显然字母之间是独立的。那么对于每一个字母 $x$，令 $g_i = [S_i = x]$，那么 $f$ 就是由两个 $g$ 卷积得到的。所以最后 f 就是对于两个字母分别做一遍卷积加起来就行。</p><p>具体的，这道题的做法是：</p><ol><li>拿到字符串，跑 manacher 得到 s1 </li><li>令 $f_i = [S_i = a]$，将 $f * f$ 加到多项式 $h$ 中</li><li>令 $g_i = [S_i = b]$，将 $g * g$ 加到多项式 $h$ 中</li><li>答案就相当于 $ \sum\limits_{i=0}^{2n -  2} (2^{\lfloor\frac{h_i}{2}\rfloor + [2|i]}-1)$ （可能有点复杂不过综合上面来看是显然的）</li></ol><p>对于卷积，我用的是 <strong>NTT</strong> (FFT 我也写了，慢了 4 倍嘿嘿)</p><p>时间复杂度 $O(n \log n)$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Author: AcFunction</span></span><br><span class="line"><span class="hljs-comment"> * Date:   2019-02-26 22:14:41</span></span><br><span class="line"><span class="hljs-comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="hljs-comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> db double </span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RG register </span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for(RG int i = l; i &lt;= r; i++) </span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i, r, l) for(RG int i = r; i &gt;= l; i--)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">INIT</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  ios :: sync_with_stdio(<span class="hljs-literal">false</span>); <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1001000</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ll mod = (ll)<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; </span><br><span class="line"><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">998244353</span>; </span><br><span class="line"><span class="hljs-keyword">const</span> ll G = <span class="hljs-number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, len[N], r[N], L; </span><br><span class="line"><span class="hljs-keyword">char</span> S[N]; <span class="hljs-built_in">string</span> s; </span><br><span class="line">ll f[N], g[N], tmp[N], Ans[N], invl;  </span><br><span class="line"></span><br><span class="line"><span class="hljs-function">ll <span class="hljs-title">fpw</span><span class="hljs-params">(ll x, ll k, ll p)</span> </span>&#123;</span><br><span class="line">  ll ret = <span class="hljs-number">1l</span>l; </span><br><span class="line">  <span class="hljs-keyword">while</span>(k) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) ret = ret * x % p; </span><br><span class="line">    x = x * x % p; k &gt;&gt;= <span class="hljs-number">1</span>; </span><br><span class="line">  &#125; <span class="hljs-keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span><span class="hljs-params">(ll *a, <span class="hljs-keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, L - <span class="hljs-number">1</span>) tmp[i] = a[r[i]]; </span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, L - <span class="hljs-number">1</span>) a[i] = tmp[i]; </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; L; i &lt;&lt;= <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    ll w = fpw(G, (MOD - <span class="hljs-number">1</span>) / (i &lt;&lt; <span class="hljs-number">1</span>), MOD);</span><br><span class="line">    <span class="hljs-keyword">if</span>(op == <span class="hljs-number">-1</span>) w = fpw(w, MOD - <span class="hljs-number">2</span>, MOD); </span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; L; j += i &lt;&lt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">      ll wn = <span class="hljs-number">1l</span>l; </span><br><span class="line">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = j; k &lt; i + j; k++) &#123;</span><br><span class="line">        ll t = a[i + k] * wn % MOD; </span><br><span class="line">        a[i + k] = (a[k] - t + MOD) % MOD; </span><br><span class="line">        a[k] = (a[k] + t) % MOD; wn = wn * w % MOD; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span>(op == <span class="hljs-number">-1</span>) &#123;</span><br><span class="line">    rep(i, <span class="hljs-number">0</span>, L - <span class="hljs-number">1</span>) </span><br><span class="line">      a[i] *= invl, a[i] %= MOD; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  INIT(); </span><br><span class="line">  <span class="hljs-built_in">cin</span> &gt;&gt; (S + <span class="hljs-number">1</span>); n = <span class="hljs-built_in">strlen</span>(S + <span class="hljs-number">1</span>);</span><br><span class="line">  s = <span class="hljs-string">"^#"</span>; </span><br><span class="line">  rep(i, <span class="hljs-number">1</span>, n) &#123;</span><br><span class="line">    s += S[i]; s += <span class="hljs-string">'#'</span>; </span><br><span class="line">  &#125; <span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>, id = <span class="hljs-number">0</span>; </span><br><span class="line">  rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    len[i] = mx &gt; i ? min(len[<span class="hljs-number">2</span> * id - i], mx - i) : <span class="hljs-number">1</span>; </span><br><span class="line">    <span class="hljs-keyword">while</span>(s[i - len[i]] == s[i + len[i]]) len[i]++; </span><br><span class="line">    <span class="hljs-keyword">if</span>(mx &lt; i + len[i]) mx = i + len[i], id = i; </span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="hljs-number">0</span>; </span><br><span class="line">  rep(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>) ans += len[i] / <span class="hljs-number">2</span>, ans %= mod; </span><br><span class="line">  L = <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(L &lt;= <span class="hljs-number">2</span> * n) L &lt;&lt;= <span class="hljs-number">1</span>; </span><br><span class="line">  invl = fpw(L, MOD - <span class="hljs-number">2</span>, MOD); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; L; i &lt;&lt;= <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)</span><br><span class="line">      r[i + j] = r[j] + L / (i * <span class="hljs-number">2</span>); </span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) f[i] = (S[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'a'</span>); </span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) g[i] = f[i]; </span><br><span class="line">  NTT(f, <span class="hljs-number">1</span>), NTT(g, <span class="hljs-number">1</span>); </span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, L - <span class="hljs-number">1</span>) Ans[i] = f[i] * g[i] % MOD; </span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) f[i] = (S[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'b'</span>); </span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) g[i] = f[i];  </span><br><span class="line">  rep(i, n, L - <span class="hljs-number">1</span>) f[i] = g[i] = <span class="hljs-number">0</span>; </span><br><span class="line">  NTT(f, <span class="hljs-number">1</span>), NTT(g, <span class="hljs-number">1</span>); </span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, L - <span class="hljs-number">1</span>) Ans[i] += f[i] * g[i] % MOD, Ans[i] %= MOD;</span><br><span class="line">  NTT(Ans, <span class="hljs-number">-1</span>); ll anss = <span class="hljs-number">0</span>;</span><br><span class="line">  rep(i, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> t = Ans[i]; </span><br><span class="line">    t = t / <span class="hljs-number">2</span>; </span><br><span class="line">    <span class="hljs-keyword">if</span>(i &amp; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">      anss += (fpw(<span class="hljs-number">2</span>, t, mod) - <span class="hljs-number">1</span>) % mod; anss %= mod; </span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> anss += (fpw(<span class="hljs-number">2</span>, t + <span class="hljs-number">1</span>, mod) - <span class="hljs-number">1</span>) % mod; anss %= mod; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-built_in">cout</span> &lt;&lt; ((anss - ans) % mod + mod) % mod &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定一个字符串由 ‘a’ 或 ‘b’ 组成。求有多少个子序列满足字母和坐标都关于一条对称轴对称并且不是连续的&lt;/p&gt;
&lt;p&gt;字符串长度 $=n \leq 10^5$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="manacher" scheme="http://yoursite.com/tags/manacher/"/>
    
      <category term="FFT" scheme="http://yoursite.com/tags/FFT/"/>
    
      <category term="NTT" scheme="http://yoursite.com/tags/NTT/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3091 城市旅行</title>
    <link href="http://yoursite.com/2019/02/21/BZOJ3091/"/>
    <id>http://yoursite.com/2019/02/21/BZOJ3091/</id>
    <published>2019-02-21T14:44:18.000Z</published>
    <updated>2019-02-21T14:50:27.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给一颗以 $1$ 为根的有根树，维护以下操作</p><ol><li>连接 $(u,v)$ 这条边</li><li>删除 $(u,v)$ 这条边</li><li>给 $u$ 到 $v$ 的链上每个点加上一个数</li><li>求在 $(u,v)$ 上任意选两个点它们之间的权值和的期望</li></ol><p>$n, m \leq 50000, a_i \leq 10^6$</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>前三个操作就是 LCT 板子，考虑如何在 LCT 上维护 4 操作</p><p>为了方便，设这个路径是 $a_1, a_2, a_3, \cdots, a_{siz}$ ，其中 $siz$ 是长度</p><p>考虑每个点的贡献，易得我们要求的期望值 $=\frac{\sum\limits_{i=1}^{siz} i (siz - i + 1)a_i}{\frac{siz(siz+1)}{2}}$ </p><p>显然这个分母很好搞，只需要考虑怎么在 LCT 上维护分子，或者说在平衡树上。</p><p>也就是说，如果知道左子和右子的答案如何更新出这个点的答案</p><p>设左子表示 $a_1, a_2, \cdots, a_p$， 该点的值是 $a_{p+1}$ ，右子表示 $a_{p+2}, \cdots, a_{siz}$ </p><p>可以得到：左子的 $siz_0 = p$，右子的 $siz_1 = siz - p - 1$</p><p>改点要的答案减去左子的答案减去右子的答案便是 </p><p>$\sum\limits_{i=1}^{siz}i(siz - i + 1)a_i - \sum\limits_{i=1}^{p}i(p-i+1)a_i-\sum\limits_{i=p+2}^{siz} (i-p-1)(siz - i + 1)a_i$</p><p>$=\sum\limits_{i=1}^{p} i(siz-p)a_i+a_{p+1}(p+1)(siz-p)+\sum\limits_{i=p+2}^{siz}(p+1)(siz-i+1)a_i$</p><p>根据上面得到的 $siz_0=p,siz_1=siz-p-1$ 简单化简一下可以得到</p><p>$=(siz_1+1)\sum\limits_{i=1}^{siz_0}i\cdot a_i+a_{siz_0+1}(siz_0+1)(siz_1+1)+(siz_0+1)\sum\limits_{i=p+2}^{siz}(siz - i +1)a_i$</p><p>到这里应该你已经知道怎么做了..</p><p>为了清楚，再令 </p><p>$b_1, b_2, \cdots,b_{siz_b}$ 是左子的， $c_1, c_2, \cdots,c_{siz_c}$ 是右子的，$d$ 是这个点本身的值。那么可以化简成简单清楚对称的形式：</p><p>$=(siz_c+1)\sum\limits_{i=1}^{siz_b}i\cdot b_i+d(siz_b+1)(siz_c+1)+(siz_b+1)\sum\limits_{i=1}^{siz_c}(siz_c-i+1)c_i$</p><p>你只需要每个点再维护两个值：</p><p>$ls=\sum\limits_{i=1}^{siz}i\cdot a_i$ 和 $rs=\sum\limits_{i=1}^{siz}(siz - i +1)a_i$ </p><p>就可以从左右两个儿子得到自己的值</p><p>这两个东西维护还是比较简单的..具体的话就是再维护一个 $s$ 为子树里所有数的和然后令 $b,c$ 是左右两个儿子，那么有</p><p>$ls = ls_b+d\cdot(siz_b+1)+ls_c+s_c (siz_b+1)$</p><p>和</p><p>$rs=rs_c+d\cdot(siz_c+1)+rs_b+s_b(siz_c+1)$ </p><p>就这样维护</p><p>以上是如何用左右儿子的信息得到自己，再来考虑链加的问题</p><p>一条链加上一个数 $x$ ，那么会如何影响我们维护的值？</p><ul><li>对于 $s$：$s = s + siz\cdot x$</li><li>对于 $ls$：$ls = ls + \sum\limits_{i=1}^{siz}i \cdot x = ls + \frac{siz(siz+1)}{2}\cdot x$</li><li>对于 $rs$：和 ls 一样 $rs = rs+\frac{siz(siz+1)}{2}\cdot x$</li><li>对于最后的答案 $S$：$S = S + \sum\limits_{i=1}^{siz} i \cdot (siz - i +1)\cdot x$ 通过简单计算可得 $S= S+\frac{siz(siz+1)(siz+2)}{6}\cdot x$</li><li>对于自己的值：直接加上 $x$ （废话）</li></ul><p>然后 LCT 板子套一套就做完了</p><p>注意事项：</p><ul><li>翻转的时候需要 swap(ls, rs)</li><li>两个点之间是联通的时候才执行链加操作（坑死我了）</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Author: AcFunction</span></span><br><span class="line"><span class="hljs-comment"> * Date:   2019-02-17 11:17:08</span></span><br><span class="line"><span class="hljs-comment"> * Email:  3486942970@qq.com</span></span><br><span class="line"><span class="hljs-comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200200</span>; </span><br><span class="line"><span class="hljs-keyword">const</span> ll INF = (ll)<span class="hljs-number">1e18</span>; </span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, m;</span><br><span class="line">ll a[N]; </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">int</span> rev; </span><br><span class="line">  ll d, s, ls, rs, s1, add, siz; </span><br><span class="line">  node *ch[<span class="hljs-number">2</span>], *prt;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isr</span><span class="hljs-params">()</span> </span>&#123; </span><br><span class="line">    <span class="hljs-keyword">return</span> (!prt) || ( prt-&gt;ch[<span class="hljs-number">0</span>] != (<span class="hljs-keyword">this</span>) &amp;&amp; prt-&gt;ch[<span class="hljs-number">1</span>] != (<span class="hljs-keyword">this</span>) ); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dir</span><span class="hljs-params">()</span> </span>&#123; </span><br><span class="line">    <span class="hljs-keyword">return</span> prt-&gt;ch[<span class="hljs-number">1</span>] == (<span class="hljs-keyword">this</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setc</span><span class="hljs-params">(node *p, <span class="hljs-keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    (<span class="hljs-keyword">this</span>)-&gt;ch[k] = p; </span><br><span class="line">    <span class="hljs-keyword">if</span>(p) p-&gt;prt = (<span class="hljs-keyword">this</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setr</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    rev ^= <span class="hljs-number">1</span>; </span><br><span class="line">    swap(ls, rs);</span><br><span class="line">    swap(ch[<span class="hljs-number">0</span>], ch[<span class="hljs-number">1</span>]); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seta</span><span class="hljs-params">(ll x)</span> </span>&#123;</span><br><span class="line">    d += x, add += x; s += siz * x; </span><br><span class="line">    ls += siz * (siz + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * x; </span><br><span class="line">    rs += siz * (siz + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * x; </span><br><span class="line">    s1 += siz * (siz + <span class="hljs-number">1</span>) * (siz + <span class="hljs-number">2</span>) / <span class="hljs-number">6</span> * x; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">()</span> </span>&#123; </span><br><span class="line">    siz = <span class="hljs-number">1</span>, s = d; </span><br><span class="line">    <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]) siz += ch[<span class="hljs-number">0</span>]-&gt;siz, s += ch[<span class="hljs-number">0</span>]-&gt;s; </span><br><span class="line">    <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">1</span>]) siz += ch[<span class="hljs-number">1</span>]-&gt;siz, s += ch[<span class="hljs-number">1</span>]-&gt;s; </span><br><span class="line">    <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>] &amp;&amp; ch[<span class="hljs-number">1</span>]) &#123;</span><br><span class="line">      ls = ch[<span class="hljs-number">0</span>]-&gt;ls + d * (ch[<span class="hljs-number">0</span>]-&gt;siz + <span class="hljs-number">1</span>) + ch[<span class="hljs-number">1</span>]-&gt;ls + ch[<span class="hljs-number">1</span>]-&gt;s * (ch[<span class="hljs-number">0</span>]-&gt;siz + <span class="hljs-number">1</span>); </span><br><span class="line">      rs = ch[<span class="hljs-number">1</span>]-&gt;rs + d * (ch[<span class="hljs-number">1</span>]-&gt;siz + <span class="hljs-number">1</span>) + ch[<span class="hljs-number">0</span>]-&gt;rs + ch[<span class="hljs-number">0</span>]-&gt;s * (ch[<span class="hljs-number">1</span>]-&gt;siz + <span class="hljs-number">1</span>);</span><br><span class="line">      s1 = ch[<span class="hljs-number">0</span>]-&gt;s1 + ch[<span class="hljs-number">1</span>]-&gt;s1;</span><br><span class="line">      s1 += ch[<span class="hljs-number">0</span>]-&gt;ls * (ch[<span class="hljs-number">1</span>]-&gt;siz + <span class="hljs-number">1</span>);</span><br><span class="line">      s1 += ch[<span class="hljs-number">1</span>]-&gt;rs * (ch[<span class="hljs-number">0</span>]-&gt;siz + <span class="hljs-number">1</span>); </span><br><span class="line">      s1 += d * (ch[<span class="hljs-number">0</span>]-&gt;siz + <span class="hljs-number">1</span>) * (ch[<span class="hljs-number">1</span>]-&gt;siz + <span class="hljs-number">1</span>);  </span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]) &#123;</span><br><span class="line">      ls = ch[<span class="hljs-number">0</span>]-&gt;ls + d * (ch[<span class="hljs-number">0</span>]-&gt;siz + <span class="hljs-number">1</span>); </span><br><span class="line">      rs = d + ch[<span class="hljs-number">0</span>]-&gt;rs + ch[<span class="hljs-number">0</span>]-&gt;s; </span><br><span class="line">      s1 = ch[<span class="hljs-number">0</span>]-&gt;s1 + ch[<span class="hljs-number">0</span>]-&gt;ls + d * (ch[<span class="hljs-number">0</span>]-&gt;siz + <span class="hljs-number">1</span>); </span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">1</span>]) &#123;</span><br><span class="line">      ls = d + ch[<span class="hljs-number">1</span>]-&gt;ls + ch[<span class="hljs-number">1</span>]-&gt;s; </span><br><span class="line">      rs = d * (ch[<span class="hljs-number">1</span>]-&gt;siz + <span class="hljs-number">1</span>) + ch[<span class="hljs-number">1</span>]-&gt;rs; </span><br><span class="line">      s1 = ch[<span class="hljs-number">1</span>]-&gt;s1 + ch[<span class="hljs-number">1</span>]-&gt;rs + d * (ch[<span class="hljs-number">1</span>]-&gt;siz + <span class="hljs-number">1</span>); </span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      ls = rs = s1 = d; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(rev) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]) ch[<span class="hljs-number">0</span>]-&gt;setr();</span><br><span class="line">      <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">1</span>]) ch[<span class="hljs-number">1</span>]-&gt;setr(); </span><br><span class="line">      rev = <span class="hljs-number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(add) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]) ch[<span class="hljs-number">0</span>]-&gt;seta(add);</span><br><span class="line">      <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">1</span>]) ch[<span class="hljs-number">1</span>]-&gt;seta(add); </span><br><span class="line">      add = <span class="hljs-number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; pool[N * <span class="hljs-number">2</span>], *P[N], *cur = pool;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">node *<span class="hljs-title">New</span><span class="hljs-params">(ll d)</span> </span>&#123; </span><br><span class="line">  node *p = cur++; </span><br><span class="line">  p-&gt;d = d, p-&gt;ls = p-&gt;rs = d; </span><br><span class="line">  p-&gt;s = p-&gt;s1 = d; </span><br><span class="line">  p-&gt;prt = p-&gt;ch[<span class="hljs-number">0</span>] = p-&gt;ch[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; </span><br><span class="line">  p-&gt;siz = <span class="hljs-number">1</span>; </span><br><span class="line">  <span class="hljs-keyword">return</span> p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(node *p)</span> </span>&#123;</span><br><span class="line">  node *prt = p-&gt;prt; <span class="hljs-keyword">int</span> k = p-&gt;dir(); </span><br><span class="line">  <span class="hljs-keyword">if</span>(!prt-&gt;isr()) prt-&gt;prt-&gt;setc(p, prt-&gt;dir()); </span><br><span class="line">  <span class="hljs-keyword">else</span> p-&gt;prt = prt-&gt;prt; prt-&gt;setc(p-&gt;ch[!k], k); </span><br><span class="line">  p-&gt;setc(prt, !k); prt-&gt;upd(); p-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node *sta[N]; <span class="hljs-keyword">int</span> top; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(node *p)</span> </span>&#123;</span><br><span class="line">  node *q = p;</span><br><span class="line">  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123; </span><br><span class="line">    sta[++top] = q; </span><br><span class="line">    <span class="hljs-keyword">if</span>(q-&gt;isr()) <span class="hljs-keyword">break</span> ;  </span><br><span class="line">    q = q-&gt;prt; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="hljs-keyword">while</span>(top) </span><br><span class="line">    (sta[top--])-&gt;push(); </span><br><span class="line">  <span class="hljs-keyword">while</span>(!p-&gt;isr()) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(p-&gt;prt-&gt;isr()) rotate(p); </span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;dir() == p-&gt;prt-&gt;dir()) rotate(p-&gt;prt), rotate(p); </span><br><span class="line">    <span class="hljs-keyword">else</span> rotate(p), rotate(p); </span><br><span class="line">  &#125; p-&gt;upd(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function">node *<span class="hljs-title">access</span><span class="hljs-params">(node *p)</span> </span>&#123;</span><br><span class="line">  node *q = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(; p; p = p-&gt;prt) &#123;</span><br><span class="line">    splay(p); </span><br><span class="line">    p-&gt;ch[<span class="hljs-number">1</span>] = q; </span><br><span class="line">    (q = p)-&gt;upd(); </span><br><span class="line">  &#125; <span class="hljs-keyword">return</span> q; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mkroot</span><span class="hljs-params">(node *p)</span> </span>&#123; access(p); splay(p); p-&gt;setr(); p-&gt;push(); &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span> <span class="hljs-params">(node *p, node *q)</span> </span>&#123; mkroot(p); access(q); splay(p); &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span>  <span class="hljs-params">(node *p, node *q)</span> </span>&#123; mkroot(p); mkroot(q); q-&gt;prt = p; &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cut</span>   <span class="hljs-params">(node *p, node *q)</span> </span>&#123; split(p, q); p-&gt;ch[<span class="hljs-number">1</span>] = q-&gt;prt = <span class="hljs-number">0</span>; &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> node *<span class="hljs-title">find</span><span class="hljs-params">(node *p)</span> </span>&#123; access(p); splay(p); <span class="hljs-keyword">while</span>(p-&gt;ch[<span class="hljs-number">0</span>]) p = p-&gt;ch[<span class="hljs-number">0</span>]; <span class="hljs-keyword">return</span> p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> !b ? a : gcd(b, a % b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>, &amp;a[i]); </span><br><span class="line">    P[i] = New(a[i]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> u, v; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">    link(P[u], P[v]); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> op, u, v; ll d;  </span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;op, &amp;u, &amp;v); </span><br><span class="line">    <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span>(find(P[u]) == find(P[v])) cut(P[u], P[v]);</span><br><span class="line">    <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span>(find(P[u]) != find(P[v])) link(P[u], P[v]); </span><br><span class="line">    <span class="hljs-keyword">if</span>(op == <span class="hljs-number">3</span>) &#123;</span><br><span class="line">      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>, &amp;d); </span><br><span class="line">      <span class="hljs-keyword">if</span>(find(P[u]) != find(P[v])) <span class="hljs-keyword">continue</span> ; <span class="hljs-comment">// important!</span></span><br><span class="line">      split(P[u], P[v]), P[u]-&gt;seta(d); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(op == <span class="hljs-number">4</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span>(find(P[u]) != find(P[v])) &#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>); </span><br><span class="line">        <span class="hljs-keyword">continue</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">      split(P[u], P[v]); </span><br><span class="line">      ll ans = P[u]-&gt;s1; </span><br><span class="line">      ll t = P[u]-&gt;siz * (P[u]-&gt;siz + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; </span><br><span class="line">      ll g = gcd(ans, t); </span><br><span class="line">      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld/%lld\n"</span>, ans / g, t / g); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给一颗以 $1$ 为根的有根树，维护以下操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接 $(u,v)$ 这条边&lt;/li&gt;
&lt;li&gt;删除 $(u,v)$ 这条边&lt;/li&gt;
&lt;li&gt;给 $u$ 到 $v$ 的链上每个点加上一个数&lt;/li&gt;
&lt;li&gt;求在 $(u,v)$ 上任意选两个点它们之间的权值和的期望&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$n, m \leq 50000, a_i \leq 10^6$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="LCT" scheme="http://yoursite.com/tags/LCT/"/>
    
  </entry>
  
  <entry>
    <title>CF1110E Magic Stones</title>
    <link href="http://yoursite.com/2019/02/09/CF1110E/"/>
    <id>http://yoursite.com/2019/02/09/CF1110E/</id>
    <published>2019-02-09T01:52:27.000Z</published>
    <updated>2019-02-09T02:00:53.168Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给出一个初始序列 $a$ 和一个目标序列 $b$，你可以对 $a$ 中的除去第一个和最后一个点之外的任意一个点 $i$ ，让 $a_i$ 变成 $a_{i-1}+a_{i+1}-a_i$ 。问是否能够通过若干次操作使得 a 变成 b</p><p>序列长度 $n \leq 10^5$ </p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><del>我觉得这个题应该放在 A</del> </p><p>考虑一个序列 : a|b|c</p><p>对 b 进行操作：a|a+c-b|c</p><p>他的差分序列原来是：a-b | b-c</p><p>现在变成了：b-c | a-b</p><p>所以一次操作相当于是把差分数组里的相邻两个数给交换了位置</p><p>所以只用判断目标序列的差分数组排序后是否等于初始序列的差分数组</p><p>还有第一个数相不相等（比赛的时候没考虑这个 wa 了一发…）</p><p>时间复杂度瓶颈在排序（或者说判断相同）</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100100</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> n, a[N], b[N]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;b[i]);</span><br><span class="line">  <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>] != b[<span class="hljs-number">1</span>]) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) a[i] = a[i + <span class="hljs-number">1</span>] - a[i];</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) b[i] = b[i + <span class="hljs-number">1</span>] - b[i];</span><br><span class="line">  sort(a + <span class="hljs-number">1</span>, a + n), sort(b + <span class="hljs-number">1</span>, b + n);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)</span><br><span class="line">    <span class="hljs-keyword">if</span>(a[i] != b[i]) &#123;</span><br><span class="line">      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yes\n"</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给出一个初始序列 $a$ 和一个目标序列 $b$，你可以对 $a$ 中的除去第一个和最后一个点之外的任意一个点 $i$ ，让 $a_i$ 变成 $a_{i-1}+a_{i+1}-a_i$ 。问是否能够通过若干次操作使得 a 变成 b&lt;/p&gt;
&lt;p&gt;序列长度 $n \leq 10^5$ &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>CF1110F Nearest Leaf</title>
    <link href="http://yoursite.com/2019/02/09/CF1110F/"/>
    <id>http://yoursite.com/2019/02/09/CF1110F/</id>
    <published>2019-02-09T00:59:23.000Z</published>
    <updated>2019-02-09T01:42:55.597Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给你一颗满足编号 = dfs 序的带边权的有根树。$m$ 次询问，每次给出 $v,l,r$ 求编号在 $[l,r]$ 中的叶子到 $v$ 节点的最短距离</p><p>$n,m \leq 5\times10^5,w \leq 10^9$ </p><a id="more"></a> <h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>如果我们知道 $u$ 节点到所有叶子的最短路，如何求出他的某一个儿子 $v$ 到所有叶子的最短路呢？</p><p>不妨设 $(u,v)$ 的边权是 $w$ 。那么在 $v$ 这颗子树内的叶子到 $v$ 的距离较 $u$ 要减少 $w$ ； $v$ 这颗子树外的叶子到 $v$ 的距离较 $u$ 要增加 $w$ 。</p><p>又良心出题人给的树是满足那个性质的，所以子树内的编号是连续的。</p><p>所以最开始 dfs 一遍。求出每个点到根的距离。把询问离线，进行一次先序遍历。</p><p>每次进入到一颗子树，就用线段树把该子树内的叶子减少 w 外面的增加 w</p><p>当回溯的父亲的时候，就用线段树把该子树内的叶子增加 w 外面的减少 w</p><p>然后遍历到一个节点就把和他有关的询问全都用线段树里的信息处理掉就行了</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>我的实现貌似有点麻烦…我直接用线段树维护叶子，所以每次给出的左右端点还要在叶子序列里二分一下</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI pair</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Fi first</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Se second</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 1000000000000000000</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">500500</span>; </span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, m, siz[N]; ll dis[N], ans[N];</span><br><span class="line"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; lea;  </span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> v; ll w; </span><br><span class="line">  edge *next; </span><br><span class="line">&#125; pol[N * <span class="hljs-number">2</span>], *head[N], *cu = pol;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">  edge *p = cu++, *q = cu++;</span><br><span class="line">  p-&gt;v = v, p-&gt;w = w, p-&gt;next = head[u], head[u] = p;</span><br><span class="line">  q-&gt;v = u, q-&gt;w = w, q-&gt;next = head[v], head[v] = q; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  siz[u] = <span class="hljs-number">1</span>; <span class="hljs-keyword">bool</span> fla = <span class="hljs-number">1</span>; </span><br><span class="line">  <span class="hljs-keyword">for</span>(edge *p = head[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> v = p-&gt;v; <span class="hljs-keyword">if</span>(v == pre) <span class="hljs-keyword">continue</span> ; </span><br><span class="line">    fla = <span class="hljs-number">0</span>; dis[v] = dis[u] + p-&gt;w;  </span><br><span class="line">    dfs(v, u); siz[u] += siz[v]; </span><br><span class="line">  &#125; <span class="hljs-keyword">if</span>(fla) lea.push_back(u); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ST</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> l, r; </span><br><span class="line">  ll tag, mn; </span><br><span class="line">  ST *ch[<span class="hljs-number">2</span>]; </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">seta</span><span class="hljs-params">(ll d)</span> </span>&#123;</span><br><span class="line">    tag += d; mn += d; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    mn = min(ch[<span class="hljs-number">0</span>]-&gt;mn, ch[<span class="hljs-number">1</span>]-&gt;mn); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(tag) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]) ch[<span class="hljs-number">0</span>]-&gt;seta(tag);</span><br><span class="line">      <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">1</span>]) ch[<span class="hljs-number">1</span>]-&gt;seta(tag); </span><br><span class="line">      tag = <span class="hljs-number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; pool[N * <span class="hljs-number">2</span>], *cur = pool, *rt; </span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ST *p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  p-&gt;l = l, p-&gt;r = r; </span><br><span class="line">  <span class="hljs-keyword">if</span>(l == r) &#123;</span><br><span class="line">    p-&gt;mn = dis[lea[l - <span class="hljs-number">1</span>]]; </span><br><span class="line">    <span class="hljs-keyword">return</span> ; </span><br><span class="line">  &#125;</span><br><span class="line">  ST *ls = cur++, *rs = cur++;</span><br><span class="line">  p-&gt;ch[<span class="hljs-number">0</span>] = ls, p-&gt;ch[<span class="hljs-number">1</span>] = rs;</span><br><span class="line">  <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;  </span><br><span class="line">  build(ls, l, mid);</span><br><span class="line">  build(rs, mid + <span class="hljs-number">1</span>, r); </span><br><span class="line">  p-&gt;upd(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ST *p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, ll d)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> ; </span><br><span class="line">  <span class="hljs-keyword">if</span>(p-&gt;l == l &amp;&amp; p-&gt;r == r) </span><br><span class="line">    <span class="hljs-keyword">return</span> p-&gt;seta(d); </span><br><span class="line">  p-&gt;push(); </span><br><span class="line">  <span class="hljs-keyword">if</span>(p-&gt;ch[<span class="hljs-number">0</span>]-&gt;r &gt;= r) modify(p-&gt;ch[<span class="hljs-number">0</span>], l, r, d);</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;ch[<span class="hljs-number">1</span>]-&gt;l &lt;= l) modify(p-&gt;ch[<span class="hljs-number">1</span>], l, r, d); </span><br><span class="line">  <span class="hljs-keyword">else</span> modify(p-&gt;ch[<span class="hljs-number">0</span>], l, p-&gt;ch[<span class="hljs-number">0</span>]-&gt;r, d), </span><br><span class="line">       modify(p-&gt;ch[<span class="hljs-number">1</span>], p-&gt;ch[<span class="hljs-number">1</span>]-&gt;l, r, d);</span><br><span class="line">  p-&gt;upd(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">Qmin</span><span class="hljs-params">(ST *p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> INF; p-&gt;push(); </span><br><span class="line">  <span class="hljs-keyword">if</span>(p-&gt;l == l &amp;&amp; p-&gt;r == r) </span><br><span class="line">    <span class="hljs-keyword">return</span> p-&gt;mn; </span><br><span class="line">  <span class="hljs-keyword">if</span>(p-&gt;ch[<span class="hljs-number">0</span>]-&gt;r &gt;= r) <span class="hljs-keyword">return</span> Qmin(p-&gt;ch[<span class="hljs-number">0</span>], l, r); </span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;ch[<span class="hljs-number">1</span>]-&gt;l &lt;= l) <span class="hljs-keyword">return</span> Qmin(p-&gt;ch[<span class="hljs-number">1</span>], l, r);</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> min(Qmin(p-&gt;ch[<span class="hljs-number">0</span>], l, p-&gt;ch[<span class="hljs-number">0</span>]-&gt;r), </span><br><span class="line">                  Qmin(p-&gt;ch[<span class="hljs-number">1</span>], p-&gt;ch[<span class="hljs-number">1</span>]-&gt;l, r)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">vector</span> &lt; PI &lt;<span class="hljs-keyword">int</span>, PI &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; &gt; Q[N]; </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// emm 我还不太会用  lower_bound / upper_bound  所以就只能手写了..</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, ret = <span class="hljs-number">0</span>; </span><br><span class="line">  <span class="hljs-keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span>(lea[mid] &lt;= x) </span><br><span class="line">      l = mid + <span class="hljs-number">1</span>, ret = mid;</span><br><span class="line">    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; </span><br><span class="line">  &#125; <span class="hljs-keyword">return</span> ret + <span class="hljs-number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lw</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, ret = n - <span class="hljs-number">1</span>; </span><br><span class="line">  <span class="hljs-keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; </span><br><span class="line">    <span class="hljs-keyword">if</span>(lea[mid] &gt;= x)</span><br><span class="line">      r = mid - <span class="hljs-number">1</span>, ret = mid; </span><br><span class="line">    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>; </span><br><span class="line">  &#125; <span class="hljs-keyword">return</span> ret + <span class="hljs-number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Q[u].size(); i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> id = Q[u][i].Fi; </span><br><span class="line">    <span class="hljs-keyword">int</span> l = Q[u][i].Se.Fi;</span><br><span class="line">    <span class="hljs-keyword">int</span> r = Q[u][i].Se.Se; </span><br><span class="line">    <span class="hljs-comment">// printf("***%d %d %d\n", id, up(l), lw(r)); </span></span><br><span class="line">    ans[id] = Qmin(rt, lw(l), up(r));  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span>(edge *p = head[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> v = p-&gt;v; <span class="hljs-keyword">if</span>(v == pre) <span class="hljs-keyword">continue</span> ; </span><br><span class="line">    <span class="hljs-keyword">int</span> L = lw(v), R = up(v + siz[v] - <span class="hljs-number">1</span>); </span><br><span class="line">    ll w = p-&gt;w; </span><br><span class="line">    <span class="hljs-comment">// printf("%d %d %d\n", v, L, R);</span></span><br><span class="line">    modify(rt, L, R, -w);</span><br><span class="line">    modify(rt, <span class="hljs-number">1</span>, L - <span class="hljs-number">1</span>, w);</span><br><span class="line">    modify(rt, R + <span class="hljs-number">1</span>, n, w); </span><br><span class="line">    solve(v, u); </span><br><span class="line">    modify(rt, L, R, w);</span><br><span class="line">    modify(rt, <span class="hljs-number">1</span>, L - <span class="hljs-number">1</span>, -w); </span><br><span class="line">    modify(rt, R + <span class="hljs-number">1</span>, n, -w); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> p; ll w; </span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %lld"</span>, &amp;p, &amp;w);</span><br><span class="line">    addedge(p, i, w); </span><br><span class="line">  &#125; dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); n = lea.size(); </span><br><span class="line">  sort(lea.begin(), lea.end()); </span><br><span class="line">  build(rt = cur++, <span class="hljs-number">1</span>, n);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> v, l, r; </span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;v, &amp;l, &amp;r);</span><br><span class="line">    Q[v].push_back(MP(i, MP(l, r))); </span><br><span class="line">  &#125; solve(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans[i]); </span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给你一颗满足编号 = dfs 序的带边权的有根树。$m$ 次询问，每次给出 $v,l,r$ 求编号在 $[l,r]$ 中的叶子到 $v$ 节点的最短距离&lt;/p&gt;
&lt;p&gt;$n,m \leq 5\times10^5,w \leq 10^9$ &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="dfs序" scheme="http://yoursite.com/tags/dfs%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>「云玩家拯救计划」小题单</title>
    <link href="http://yoursite.com/2019/02/02/Cloud-Player-Rescue-Plan/"/>
    <id>http://yoursite.com/2019/02/02/Cloud-Player-Rescue-Plan/</id>
    <published>2019-02-02T06:20:23.000Z</published>
    <updated>2019-02-09T01:14:32.656Z</updated>
    
    <content type="html"><![CDATA[<p>云玩家拯救计划（雾</p><a id="more"></a><hr><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><p><strong>A(CF1009G)</strong>：直接贪心，用二分图里的一个霍尔定理来判断合法性。实现上可以简单一点。</p><p><strong>B(CF808F)</strong>：先二分答案，观察到除了 2 以外所有质数由偶数+奇数得来。于是 check 就可以特判 1 + 1 的情况，建图最小割即可。</p><p><strong>C(CF164C)</strong>：把任务按照开始时间排序，S -&gt; 最小的开始时间 -&gt;  第二个 -&gt; .. -&gt; 第 n 个 -&gt; T 连流量 m 费用 0 ，再对于每个任务连一条从起点到终点加 1，流量 1 费用 -c 的边。然后最小费用最大流就好了。<del>我还是不会输出方案（捂脸</del> </p><p><strong>D(CF277E)</strong>：以前做过…写过<a href="https://acfcacfca.blog.luogu.org/solution-cf277e" target="_blank" rel="noopener">题解</a>…</p><p><strong>E(CF1082G)</strong>：把每个点和每条边算成一个点，边的权值是负的，然后最大权闭合子图</p><p><strong>F(BZOJ3158)</strong>： 考虑 % 4 可以证明奇数方+奇数方不等于完全平方，同时偶数的最大公约数 &gt; 1 所以奇数一边偶数一边建二分图然后就是套路的最小割了<br><strong>G(CF863F)</strong>：可以求出每个点的可行区间，然后那个平方的条件就可以拆边。就是 (1,1), (3,1), (5,1), (7,1) …. 然后最小费用最大流</p><p><strong>H(CF498C)</strong>：显然除质因子答案最大 &amp;&amp; 质因子之间相互独立。对于每一个出现过的质因子跑最大流就行了</p><hr><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><p><strong>A(BZOJ2154)</strong> ：不妨设 $n \leq m$ </p><p>$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} lcm(i, j)$</p><p>$=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} \frac{ij}{\gcd(i,j)}$</p><p>$=\sum\limits_{d=1}^{n}\sum\limits_{i’=1}^{\lfloor \frac{n}{d} \rfloor}\sum\limits_{j’=1}^{\lfloor \frac{m}{d} \rfloor} i’j’d [\gcd(i’,j’)=1]$  </p><p>$=\sum\limits_{d=1}^{n}d \sum\limits_{i’=1}^{\lfloor \frac{n}{d} \rfloor} i’ \sum\limits_{j’=1}^{\lfloor \frac{m}{d} \rfloor} j’ [gcd(i’,j’)=1]$  </p><p>$ =\sum\limits_{d=1}^{n} d \sum\limits_{i’=1}^{\lfloor \frac{n}{d} \rfloor} i’ \sum\limits_{j’=1}^{\lfloor \frac{m}{d} \rfloor} j’ \sum\limits_{d’|i’,d’|j’}\mu(d’)$  </p><p>$=\sum\limits_{d=1}^{n}\sum\limits_{d’=1}^{n}\mu(d’)d \sum\limits_{i’=1}^{\lfloor \frac{n}{d’d} \rfloor} i’ \sum\limits_{j’=1}^{\lfloor \frac{m}{d’d} \rfloor} j’ $ </p><p>令 $dd’=T, F(T)=\sum\limits_{d | T}\mu(d)\frac{T}{d}$ 。F 可以线性筛出来，就做完了 ）</p><p>然后这个题连分块都不用（</p><p>好像有需要分块的加强版被权限了（</p><p><strong>B(BZOJ2440)</strong>：<a href="https://acfcacfca.blog.luogu.org/solution-p4318" target="_blank" rel="noopener">题解</a> </p><p><strong>C(BZOJ3529)</strong>：<a href="https://acfunction.github.io/2019/01/14/bzoj3529/" target="_blank" rel="noopener">题解</a></p><p><strong>D(HDU6053)：</strong> 待填坑</p><p><strong>E(BZOJ2956)</strong>：</p><p>$\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m} <a href="n\%i">i\not= j</a>(m\%j)$</p><p>$=\sum\limits_{i=1}^{n}n\%i\sum\limits_{j=1}^{m}m\%j-\sum\limits_{i=1}^{n}(n\%i)(m\%i)$</p><p>然后把 $n\%i$ 搞成 $n -i \lfloor\frac{n}{i}\rfloor $ ，$m\%i$ 同理，然后推推式子分个块就做完了</p><p><strong>F(HDU4947)</strong>：待填坑</p><p><strong>G(BZOJ2005)</strong>：有点简单懒得写hhh</p><p><strong>H(HDU4473)</strong>：把题目要求转化为有多少个有序对 (a,b,c) 满足 abc = n。然后分三类 a,b,c;a,a,b;a,a,a 讨论下就行了（优秀的暴力…</p><p><strong>I(HDU5942)</strong>：有点难啊…看的 <a href="https://www.cnblogs.com/clrs97/p/6012285.html" target="_blank" rel="noopener">这个题解</a> </p><hr><h1 id="线段树主席树"><a href="#线段树主席树" class="headerlink" title="线段树主席树"></a>线段树主席树</h1><p><strong>A(HDU4578)</strong>：线段树维护加标记乘标记以及三个值分别表示和，平方的和，立方的和。加标记更新就用二项式展开一下倒序更新；乘标记就是和乘上d，平方乘上d^2，立方同理…然后覆盖操作拆成先乘 0 再加 。</p><p><strong>B(BZOJ1818)</strong>：先把题目条件转化成所有由这些点组成的平行于坐标轴的线段之间有几个交点（端点也算）。然后就直接把坐标离散化一下然后扫描线扫过去中间用树状数组维护一下就行了。</p><p><strong>C(COT)</strong>：板子再见</p><p><strong>D(BZOJ3261)</strong>：搞个可持久化 0/1 trie 维护前缀异或和然后就做完了（板子）</p><p><strong>E(CF484E)</strong>：二分答案下，然后对于一个值是否合法只需要把 &gt; 该数的变成 1 ，小于该数的变成 0 然后用线段树维护这个区间内的最长的 1 序列。由于不能开一堆线段树，所以用主席数的思想就行了（我都觉得我说的不清楚…）</p><p><strong>F()</strong>：</p><p>G：线段树合并裸题</p><p>H：kruskal 重构树上主席树</p><p>I：对每一位维护线段树就行了</p><p>J：压个位然后维护区间或就行了</p><p>K：模板题再见</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云玩家拯救计划（雾&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CF757F Team Rocket Rises Again</title>
    <link href="http://yoursite.com/2019/02/01/CF757F/"/>
    <id>http://yoursite.com/2019/02/01/CF757F/</id>
    <published>2019-02-01T11:41:04.000Z</published>
    <updated>2019-02-01T12:15:18.513Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个 $n$ 个点 $m$ 条边的无向图，给出起点 $S$ 。求删除掉一个不是 $S$ 的点后最多能改变多少个点到 $S$ 的最短路。输出这个最大值。</p><p>$n \leq 200000, m \leq \min(\frac{n(n-1)}{2},300000)$ </p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>在飞机上写的题解 2333</p><p>定义 $d_u$ 是 $S$ 到 $u$ 的最短路；最短路 DAG 为所有有向边 $(u,v)$ 满足 $d_u+w(u,v)=d_v$ 组成的 DAG .</p><p>那么显然删这个 DAG 上的点才是对答案有贡献的。</p><p>考虑如何求出删完一个点会使得有多少个点的最短路有改变。</p><p>把这个 DAG 的支配树建出来然后对于一个点它在支配树上的子树大小就是答案。</p><p>注：支配树是啥？</p><p>在一个有向图中有一个节点是 $S$ ；对于节点 $u$ 从 $S$ 到 $u$ 上的路径必到的点称之为 $u$ 的支配点</p><p>对于每一个 $u$ ，从离他最近的一个点向他连一条边。这些边组成的便是原图的支配树。其中 $S$ 为根节点</p><p>对于一个 DAG 如何建出他的支配树？即对于一个点怎么求出离他最近的支配点？</p><p>可以考虑用拓扑排序的顺序更新。对于节点 $u$ ，它的所有前驱在支配树上的 LCA便是它在支配树上的父亲；即离他最近的支配点。</p><p>这个过程需要维护的就是 加点 和 维护 LCA 。可以用倍增用 $O(n \log n)$ 的时间复杂度解决</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long <span class="hljs-comment">// don't think I use int ! </span></span></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">300300</span>; </span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = (<span class="hljs-keyword">int</span>)<span class="hljs-number">4e18</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> n, m, S, dis[N], U[N], V[N], W[N], ind[N], fa[N][<span class="hljs-number">25</span>], dep[N], siz[N]; </span><br><span class="line"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; g[N]; </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> v, w; edge *next; </span><br><span class="line">&#125; *h1[N], *h2[N], *h3[N], pool[N * <span class="hljs-number">6</span>], *cur = pool; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++; p-&gt;w = w; </span><br><span class="line">  p-&gt;v = v, p-&gt;next = h1[u], h1[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++;</span><br><span class="line">  p-&gt;v = v, p-&gt;next = h2[u], h2[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++;</span><br><span class="line">  p-&gt;v = v, p-&gt;next = h3[u], h3[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  fa[x][<span class="hljs-number">0</span>] = f;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++)</span><br><span class="line">    fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>]; </span><br><span class="line">  dep[x] = dep[f] + <span class="hljs-number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">    <span class="hljs-keyword">if</span>(dep[fa[u][i]] &gt;= dep[v] &amp;&amp; fa[u][i])</span><br><span class="line">      u = fa[u][i]; </span><br><span class="line">  <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span> u; </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">    <span class="hljs-keyword">if</span>(fa[u][i] != fa[v][i])</span><br><span class="line">      u = fa[u][i], v = fa[v][i];</span><br><span class="line">  <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> d, id; </span><br><span class="line">  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;x) <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> d &gt; x.d; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; tmp; </span><br><span class="line">priority_queue &lt;node&gt; Q; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">    dis[i] = INF;</span><br><span class="line">  tmp.id = S, tmp.d = <span class="hljs-number">0</span>; Q.push(tmp); dis[S] = <span class="hljs-number">0</span>; </span><br><span class="line">  <span class="hljs-keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    tmp = Q.top(); Q.pop();</span><br><span class="line">    <span class="hljs-keyword">int</span> u = tmp.id;</span><br><span class="line">    <span class="hljs-keyword">if</span>(dis[u] &lt; tmp.d) <span class="hljs-keyword">continue</span> ; </span><br><span class="line">    <span class="hljs-keyword">for</span>(edge *p = h1[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> v = p-&gt;v; </span><br><span class="line">      <span class="hljs-keyword">if</span>(dis[v] &gt; dis[u] + p-&gt;w) &#123;</span><br><span class="line">        dis[v] = dis[u] + p-&gt;w; </span><br><span class="line">        tmp.id = v, tmp.d = dis[v];</span><br><span class="line">        Q.push(tmp); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  siz[u] = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(edge *p = h3[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> v = p-&gt;v; <span class="hljs-keyword">if</span>(v == pre) <span class="hljs-keyword">continue</span> ; </span><br><span class="line">    dfs(v, u); siz[u] += siz[v]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld %lld %lld"</span>, &amp;n, &amp;m, &amp;S);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> u, v, w;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld %lld %lld"</span>, &amp;u, &amp;v, &amp;w); </span><br><span class="line">    U[i] = u, V[i] = v, W[i] = w; </span><br><span class="line">    add1(u, v, w), add1(v, u, w); </span><br><span class="line">  &#125;</span><br><span class="line">  dijkstra(); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(dis[U[i]] == dis[V[i]] + W[i])</span><br><span class="line">      add2(V[i], U[i]), ind[U[i]]++, g[U[i]].push_back(V[i]);</span><br><span class="line">    <span class="hljs-keyword">if</span>(dis[V[i]] == dis[U[i]] + W[i])</span><br><span class="line">      add2(U[i], V[i]), ind[V[i]]++, g[V[i]].push_back(U[i]); </span><br><span class="line">  &#125; <span class="hljs-built_in">queue</span> &lt;<span class="hljs-keyword">int</span>&gt; Q; Q.push(S); dep[S] = <span class="hljs-number">1</span>; </span><br><span class="line">  <span class="hljs-keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">    <span class="hljs-comment">// printf("%d\n", u); </span></span><br><span class="line">    <span class="hljs-keyword">if</span>(g[u].size()) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> lca = g[u][<span class="hljs-number">0</span>];</span><br><span class="line">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; g[u].size(); i++) &#123;</span><br><span class="line">       <span class="hljs-comment">// printf("%d\n", g[u][i]); </span></span><br><span class="line">        lca = LCA(g[u][i], lca);</span><br><span class="line">      &#125; </span><br><span class="line">      add(u, lca); add3(lca, u); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(edge *p = h2[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> v = p-&gt;v; ind[v]--;</span><br><span class="line">      <span class="hljs-keyword">if</span>(ind[v] == <span class="hljs-number">0</span>) Q.push(v); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;  </span><br><span class="line">  dfs(S, <span class="hljs-number">0</span>); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="hljs-keyword">if</span>(i != S) ans = max(ans, siz[i]); </span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans); </span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;一个 $n$ 个点 $m$ 条边的无向图，给出起点 $S$ 。求删除掉一个不是 $S$ 的点后最多能改变多少个点到 $S$ 的最短路。输出这个最大值。&lt;/p&gt;
&lt;p&gt;$n \leq 200000, m \leq \min(\frac{n(n-1)}{2},300000)$ &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="支配树" scheme="http://yoursite.com/tags/%E6%94%AF%E9%85%8D%E6%A0%91/"/>
    
      <category term="倍增" scheme="http://yoursite.com/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="LCA" scheme="http://yoursite.com/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>趣题「红眼睛与蓝眼睛」</title>
    <link href="http://yoursite.com/2019/01/23/Red-And-Blue-Eye/"/>
    <id>http://yoursite.com/2019/01/23/Red-And-Blue-Eye/</id>
    <published>2019-01-23T13:35:50.000Z</published>
    <updated>2019-01-23T14:27:49.329Z</updated>
    
    <content type="html"><![CDATA[<p>一道有趣的题目。</p><a id="more"></a> <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个岛上有 $n$ 个人，其中有 $m$ 个红眼睛，$n -  m$ 个蓝眼睛。这个岛有三个规则</p><ol><li>他们不能照镜子，不能看自己眼睛的颜色。</li><li>他们不能告诉别人对方的眼睛是什么颜色。</li><li>一旦有人知道了自己是红眼睛，他就会在当天夜里自杀。</li></ol><p>如果有一天，一个外来人来到这里对他们所有人说「你们这里有红眼睛的人」</p><p>假设每一个人都有着极强的逻辑推理能力。 </p><p>求证：在这句话公布后地第 $m$ 天晚上这 $m$ 个红眼睛会一起自杀。</p><p>注：每一个人是不知道岛上有多少个红眼睛的人的</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>乍一看，这题毫无头绪。告诉了一句「你们这里有红眼睛的人」又能怎么样呢？</p><p>先来看一个数学归纳法的证明：</p><ol><li><p>如果这个岛上只有一个红眼睛，听到这句话后看到其他人都不是红眼睛，便意识到自己是红眼睛，当天自杀。</p></li><li><p>假设当这个岛上有 $m$ 个红眼睛，他们会在第 $m$ 天自杀成立</p><p>当有 $m + 1$ 个红眼睛的时候，在每个红眼睛看来，都有 $m$ 个红眼睛，这个红眼睛能够推理出如果他不是红眼睛，那么他看到的 $m$ 个红眼睛都会在第 $m$ 天自杀 。而在第 $m$ 天，没有人自杀。一到第 $m + 1$ 天，每个红眼睛都意识到他是红眼睛。于是都在第 $m + 1$ 天自杀了</p></li></ol><p>命题得证。看似没有问题，实际上，除了 $m = 1$  的情况，这句话就相当于废话。因为没有任何用</p><p>要么在这之前红眼睛早就死光了，要么根本就不会死人。</p><p>但这并不是一个错误的事情。一个大神的回答说出来了 <a href="https://www.zhihu.com/question/21262930/answer/17690897" target="_blank" rel="noopener">戳这里</a> </p><p>这句话的作用就在于，让 <strong>每个人都知道每个人都知道这里有红眼睛的人</strong> </p><p>进一步地，这句话让  <strong>每个人都每个人都知道每个人都知道这里有红眼睛的人</strong>  等等</p><p>引用这位大神的话，就是：</p><blockquote><p>简单说，「岛上有红眼睛」这件事本来只是一项「<strong>共有知识</strong>」（<a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Mutual_knowledge_%2528logic%2529" target="_blank" rel="noopener">Mutual knowledge</a>），公开宣告使它变成了一项「<strong>公共知识</strong>」（<a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Common_knowledge_%2528logic%2529" target="_blank" rel="noopener">Common knowledge</a>）。这两种知识的区分在认知逻辑里面非常重要，在博弈论中有广泛的应用。</p></blockquote><blockquote><p>用不严谨的话粗略介绍一下这两个概念：对于一个给定的命题P和一群给定的人，共有知识只需要满足一个条件：这群人中所有人都知道P，那么P就是这群人的共有知识。<br>公共知识则需要满足以下所有条件：<br>这群人中<br>1、所有人都知道P；<br>2、所有人都知道所有人都知道P；<br>3、所有人都知道所有人都知道所有人都知道P；<br>4、所有人都知道所有人都知道所有人都知道所有人都知道P；<br>5、……</p></blockquote><p>共有知识 转化成 公共知识 的影响是很大的，就像这个例子一样</p><p>共有知识 转化成 公共知识 也是很难的，所以累次这个例子不太可能实现</p><hr><p>同时这句话也统一了所有人的<strong>时间起点</strong>，时间在推理中扮演者重要的角色。这句话也让每一个人知道别人也知道这个时间起点 ，这样才有 “第 $m$ 天” 这种说法能够统一（就像人的出生时间不同，自然不能做出有效的推理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道有趣的题目。&lt;/p&gt;
    
    </summary>
    
      <category term="趣题" scheme="http://yoursite.com/categories/%E8%B6%A3%E9%A2%98/"/>
    
    
      <category term="博弈论" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2653 middle</title>
    <link href="http://yoursite.com/2019/01/20/BZOJ2653/"/>
    <id>http://yoursite.com/2019/01/20/BZOJ2653/</id>
    <published>2019-01-20T05:31:24.000Z</published>
    <updated>2019-02-01T12:15:07.166Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给你一个序列，每次询问给出四个数 $a,b,c,d$，求所有区间 $[l,r]$ 满足 $l \in [a,b], r \in [c,d]$ 的中位数的最大值。强制在线。</p><p>$n \leq 20000, Q \leq 25000,a_i \leq 10^9$</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑二分答案。假设现在二分出来的是 $x$ ，那么把 $\ge x$ 的位置设成 $1$ ，$&lt; x$ 的设为 $-1$ 。那么一个区间的中位数 $\ge x$ 等价于这个区间的和 $\ge 0$</p><p>如何处理题目给的左右端点的限制？</p><p>可以发现 $[l,r]$ 必然包含 $[b+1,c-1]$ (如果 $b+1 \leq c+1$ 的话）所以 $[l, r]$ 的和必然包含 $[b+1, c-1]$ 的和</p><p>显然让 $[l,r]$ 的和最大的方案是取 $[a,b]$ 的最大右段和 和 $[c,d]$ 的最大左段和</p><p>这些都可以用线段树维护。但这样需要每个数都开一颗线段树，空间爆炸。</p><p>把数组排序，这样每个数的线段树显然只是由前一个数的线段树把一个点的权值从 $1$ 改为 $-1$ 。可以使用主席树的思想（貌似就是主席树</p><p>然后就做完了。复杂度 $O(m \log^2 n)$ </p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2000</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> n, m; <span class="hljs-keyword">int</span> q[<span class="hljs-number">4</span>]; </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> d, id; </span><br><span class="line">&#125; a[N]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node x, Node y)</span> </span>&#123; </span><br><span class="line">  <span class="hljs-keyword">return</span> x.d &lt; y.d; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> left, right; </span><br><span class="line">  <span class="hljs-keyword">int</span> sm, lm, rm; </span><br><span class="line">  node *ch[<span class="hljs-number">2</span>]; </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sm = ch[<span class="hljs-number">0</span>]-&gt;sm + ch[<span class="hljs-number">1</span>]-&gt;sm; </span><br><span class="line">    lm = max(ch[<span class="hljs-number">0</span>]-&gt;lm, ch[<span class="hljs-number">0</span>]-&gt;sm + ch[<span class="hljs-number">1</span>]-&gt;lm);</span><br><span class="line">    rm = max(ch[<span class="hljs-number">1</span>]-&gt;rm, ch[<span class="hljs-number">1</span>]-&gt;sm + ch[<span class="hljs-number">0</span>]-&gt;rm); </span><br><span class="line">  &#125;</span><br><span class="line">&#125; *rt[N], pool[N * <span class="hljs-number">50</span>], *cur = pool, *ans; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B</span> <span class="hljs-params">(node *r, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123; </span><br><span class="line">  r-&gt;left = left, r-&gt;right = right; </span><br><span class="line">  <span class="hljs-keyword">if</span>(left == right) &#123; r-&gt;sm = r-&gt;lm = r-&gt;rm = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> ; &#125;</span><br><span class="line">  node *lson = cur++, *rson = cur++; </span><br><span class="line">  <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">  r-&gt;ch[<span class="hljs-number">0</span>] = lson, r-&gt;ch[<span class="hljs-number">1</span>] = rson;</span><br><span class="line">  B(lson, left, mid), B(rson, mid + <span class="hljs-number">1</span>, right);  r-&gt;upd(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">I</span> <span class="hljs-params">(node *pre, node *now, <span class="hljs-keyword">int</span> pos)</span> </span>&#123; </span><br><span class="line">  now-&gt;left = pre-&gt;left, now-&gt;right = pre-&gt;right; </span><br><span class="line">  <span class="hljs-keyword">if</span>(now-&gt;left == now-&gt;right) &#123;</span><br><span class="line">    now-&gt;sm = now-&gt;lm = now-&gt;rm = <span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span> ; </span><br><span class="line">  &#125; <span class="hljs-keyword">int</span> mid = (pre-&gt;left + pre-&gt;right) &gt;&gt; <span class="hljs-number">1</span>; </span><br><span class="line">  <span class="hljs-keyword">if</span>(pos &lt;= mid) now-&gt;ch[<span class="hljs-number">1</span>] = pre-&gt;ch[<span class="hljs-number">1</span>], I(pre-&gt;ch[<span class="hljs-number">0</span>], now-&gt;ch[<span class="hljs-number">0</span>] = cur++, pos); </span><br><span class="line">  <span class="hljs-keyword">if</span>(pos &gt;  mid) now-&gt;ch[<span class="hljs-number">0</span>] = pre-&gt;ch[<span class="hljs-number">0</span>], I(pre-&gt;ch[<span class="hljs-number">1</span>], now-&gt;ch[<span class="hljs-number">1</span>] = cur++, pos); </span><br><span class="line">  now-&gt;upd(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> node* <span class="hljs-title">Q</span> <span class="hljs-params">(node *now, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(now-&gt;left == l &amp;&amp; now-&gt;right == r) <span class="hljs-keyword">return</span> now; </span><br><span class="line">  <span class="hljs-keyword">if</span>(now-&gt;ch[<span class="hljs-number">0</span>]-&gt;right &gt;= r) <span class="hljs-keyword">return</span> Q(now-&gt;ch[<span class="hljs-number">0</span>], l, r);</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(now-&gt;ch[<span class="hljs-number">1</span>]-&gt;left &lt;= l) <span class="hljs-keyword">return</span> Q(now-&gt;ch[<span class="hljs-number">1</span>], l, r); </span><br><span class="line">  <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    node *ret = cur++, *L, *R;</span><br><span class="line">    L = Q(now-&gt;ch[<span class="hljs-number">0</span>], l, now-&gt;ch[<span class="hljs-number">0</span>]-&gt;right);</span><br><span class="line">    R = Q(now-&gt;ch[<span class="hljs-number">1</span>], now-&gt;ch[<span class="hljs-number">1</span>]-&gt;left, r);</span><br><span class="line">    ret-&gt;sm = L-&gt;sm + R-&gt;sm; </span><br><span class="line">    ret-&gt;lm = max(L-&gt;lm, L-&gt;sm + R-&gt;lm);</span><br><span class="line">    ret-&gt;rm = max(R-&gt;rm, R-&gt;sm + L-&gt;rm); </span><br><span class="line">    <span class="hljs-keyword">return</span> ret; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span>(q[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span> &lt;= q[<span class="hljs-number">3</span>] - <span class="hljs-number">1</span>) sum += Q (rt[id - <span class="hljs-number">1</span>], q[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>, q[<span class="hljs-number">3</span>] - <span class="hljs-number">1</span>)-&gt;sm; </span><br><span class="line">  sum += Q (rt[id - <span class="hljs-number">1</span>], q[<span class="hljs-number">1</span>], q[<span class="hljs-number">2</span>])-&gt;rm; </span><br><span class="line">  sum += Q (rt[id - <span class="hljs-number">1</span>], q[<span class="hljs-number">3</span>], q[<span class="hljs-number">4</span>])-&gt;lm; </span><br><span class="line">  <span class="hljs-keyword">return</span> sum &gt;= <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i].d); </span><br><span class="line">    a[i].id = i; </span><br><span class="line">  &#125; sort(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, cmp);</span><br><span class="line">  B(rt[<span class="hljs-number">0</span>] = cur++, <span class="hljs-number">1</span>, n); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    rt[i] = cur++; I(rt[i - <span class="hljs-number">1</span>], rt[i], a[i].id);  </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">4</span>; j++) &#123;</span><br><span class="line">      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;q[j]), </span><br><span class="line">      q[j] += ans, q[j] %= n; q[j]++; </span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="hljs-number">1</span>, q + <span class="hljs-number">4</span> + <span class="hljs-number">1</span>); </span><br><span class="line">    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n; </span><br><span class="line">    <span class="hljs-keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>; </span><br><span class="line">      <span class="hljs-keyword">if</span>(check(mid)) l = mid + <span class="hljs-number">1</span>, ans = a[mid].d; </span><br><span class="line">      <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; </span><br><span class="line">    &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给你一个序列，每次询问给出四个数 $a,b,c,d$，求所有区间 $[l,r]$ 满足 $l \in [a,b], r \in [c,d]$ 的中位数的最大值。强制在线。&lt;/p&gt;
&lt;p&gt;$n \leq 20000, Q \leq 25000,a_i \leq 10^9$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="主席树" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2174 「FJOI2016」神秘数</title>
    <link href="http://yoursite.com/2019/01/17/LOJ2174/"/>
    <id>http://yoursite.com/2019/01/17/LOJ2174/</id>
    <published>2019-01-17T08:32:40.000Z</published>
    <updated>2019-01-17T13:49:08.370Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>$n$ 个数的序列，每次询问一个区间，求最小的一个数使得不能用这个区间中的数之和表示。</p><p>$n \leq 10^5, \sum a_i \leq 10^9$</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><del>第一次用数组写数据结构真短啊</del></p><p>考虑只有一次询问怎么做</p><p>把给定的区间内的数排序，从小到大扫一遍。</p><p>如果一个数比他之前的数之和至少大了 $1$ ，那么答案就是和 + 1</p><p>否则就可以把$[1,\text{前缀和}]$ 都表示出来（感性理解很容易）</p><p>这道题怎么做也就显然了起来。只需要用主席树维护区间中小于等于某个数的数之和即可。流程如下</p><p>当前答案是 $a$，令 $S$ 是区间中 $\leq a$ 的数之和  </p><ol><li>如果 $S &lt; a$ 则 $a$ 就是最后的答案</li><li>否则 让 $a = S+1$ 然后重复此操作</li></ol><p>最开始的时候 $a=1$</p><p>这样做的话 $a$ 每次都会翻一倍，所以最后的总复杂度是  $O(m \log n \log \sum a_i)$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50000500</span>; </span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> L = <span class="hljs-number">1000000000</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> n, m, a[N], cnt; </span><br><span class="line"><span class="hljs-keyword">int</span> root[N], ch[N][<span class="hljs-number">2</span>]; ll sum[N]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">I</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  ch[now][<span class="hljs-number">0</span>] = ch[pre][<span class="hljs-number">0</span>], ch[now][<span class="hljs-number">1</span>] = ch[pre][<span class="hljs-number">1</span>]; </span><br><span class="line">  <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; sum[now] = sum[pre] + val; <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> ; </span><br><span class="line">  <span class="hljs-keyword">if</span>(val &lt;= mid) ch[now][<span class="hljs-number">0</span>] = ++cnt, I(ch[pre][<span class="hljs-number">0</span>], ch[now][<span class="hljs-number">0</span>], l, mid, val);</span><br><span class="line">  <span class="hljs-keyword">else</span> ch[now][<span class="hljs-number">1</span>] = ++cnt, I(ch[pre][<span class="hljs-number">1</span>], ch[now][<span class="hljs-number">1</span>], mid + <span class="hljs-number">1</span>, r, val); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Q</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> sum[now] - sum[pre]; <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span>(val &lt;= mid) <span class="hljs-keyword">return</span> Q(ch[pre][<span class="hljs-number">0</span>], ch[now][<span class="hljs-number">0</span>], l, mid, val);</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> sum[ch[now][<span class="hljs-number">0</span>]] - sum[ch[pre][<span class="hljs-number">0</span>]] + Q(ch[pre][<span class="hljs-number">1</span>], ch[now][<span class="hljs-number">1</span>], mid + <span class="hljs-number">1</span>, r, val); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]); root[i] = ++cnt; </span><br><span class="line">    I(root[i - <span class="hljs-number">1</span>], root[i], <span class="hljs-number">1</span>, L, a[i]); </span><br><span class="line">  &#125; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> l, r; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;l, &amp;r); </span><br><span class="line">    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>; </span><br><span class="line">    <span class="hljs-keyword">int</span> S; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;</span><br><span class="line">      S = Q(root[l - <span class="hljs-number">1</span>], root[r], <span class="hljs-number">1</span>, L, ans); </span><br><span class="line">      <span class="hljs-keyword">if</span>(S &lt; ans) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans); <span class="hljs-keyword">break</span> ; &#125;</span><br><span class="line">      <span class="hljs-keyword">else</span> ans = S + <span class="hljs-number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;$n$ 个数的序列，每次询问一个区间，求最小的一个数使得不能用这个区间中的数之和表示。&lt;/p&gt;
&lt;p&gt;$n \leq 10^5, \sum a_i \leq 10^9$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="主席树" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3529 「SDOI2014」数表</title>
    <link href="http://yoursite.com/2019/01/14/bzoj3529/"/>
    <id>http://yoursite.com/2019/01/14/bzoj3529/</id>
    <published>2019-01-14T12:42:52.000Z</published>
    <updated>2019-01-20T05:28:09.946Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>$T$ 组询问，定义 $F(n)=\sum\limits_{d|n}d$。每次给出 $n,m,a$ 求  </p><p>$$\sum\limits_{i=1,j=1,F(\gcd(i,j)) \leq a}^{i\leq n, j \leq m} F (\gcd(i,j))$$</p><p>$T \leq 20000;n,m,a\leq 10^5$</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先 $F$ 可以直接暴力地 $O(n \log n)$ 筛出来。</p><p>考虑 $a$ 的限制不是很好处理，假设没有这个 $a$ 的限制，则所求为</p><p>$$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} F (\gcd(i,j))$$</p><p>令 $G(i)=\sum\limits_{x=1}^{n}\sum\limits_{y=1}^{m}[\gcd(x,y)=i]$。这个东西是什么呢？在 <a href="https://www.cnblogs.com/acfunction/p/10127599.html" target="_blank" rel="noopener">这里</a> 有它的推导过程。根据里面的过程，可以得到 $G(i) = \sum\limits_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)\lfloor\frac{n}{id}\rfloor\lfloor\frac{m}{id}\rfloor$（默认 $n \leq m$）<br>令下面的过程中$t = id$，则所求的是 </p><p>$$\sum\limits_{i=1}^{n}F(i)G(i)$$</p><p> $$= \sum\limits_{i=1}^{n}F(i)\sum\limits_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)\lfloor\frac{n}{id}\rfloor\lfloor\frac{m}{id}\rfloor $$</p><p>$$=\sum\limits_{i=1}^{n}F(i)\sum\limits_{i | t}\mu(\frac{t}{i})\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor$$</p><p>$$=\sum\limits_{t=1}^{n}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum\limits_{i | t}F(i)\mu(\frac{t}{i})$$</p><p>观察后面的式子，正好是一个狄利克雷卷积的形式。这种样子的都可以类似于那种 $O(n \log n)$ 地质数筛法在调和级数内求出来，再结合分块就可以做完这个没有 $a$ 的题。</p><p>现在有了 $a$ 的限制之后，离线。把询问按照 $a$ 从小到大排序，然后按照 $F(i)$ 从小到大加入。每当有一个新的 $a$ ，就可以移动指针，将一些 $F$ 用处理 $\sum\limits_{i | t}F(i)\mu(\frac{t}{i})$ 的方式加入到这个里面。然后加入完之后用分块计算就行。</p><p>现在需要维护单点操作，查询前缀和，树状数组是不错的选择。</p><p>由于取模是 $2^{32} - 1$ ，可以直接 int 自然溢出最后和 $2147483647$ 取一个 &amp; 就行了。</p><p>时间复杂度：$O(n + n \log n +  n \log ^ 2 (n) + T \log (n)\sqrt n)$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> T, cnt, flag[N + <span class="hljs-number">5</span>], p[N + <span class="hljs-number">5</span>], F[N + <span class="hljs-number">5</span>], mu[N + <span class="hljs-number">5</span>], ans[N + <span class="hljs-number">5</span>]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  flag[<span class="hljs-number">1</span>] = mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(!flag[i]) &#123; p[++cnt] = i, mu[i] = <span class="hljs-number">-1</span>; &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= N; j++) &#123;</span><br><span class="line">      flag[i * p[j]] = <span class="hljs-number">1</span>; <span class="hljs-keyword">if</span>(i % p[j] == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        mu[i * p[j]] = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span> ;</span><br><span class="line">      &#125; mu[i * p[j]] = mu[i] * <span class="hljs-number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt;= N; j += i) F[j] += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> c[N + <span class="hljs-number">5</span>]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lb</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i &lt;= N; i += lb(i)) c[i] += d; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i; i -= lb(i)) </span><br><span class="line">    ret += c[i]; <span class="hljs-keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r; l &lt;= min(n, m); l = r + <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    r = min(n / (n / l), m / (m / l)); </span><br><span class="line">    ret += (n / l) * (m / l) * (sum(r) - sum(l - <span class="hljs-number">1</span>)); </span><br><span class="line">  &#125; <span class="hljs-keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Query</span> &#123;</span> </span><br><span class="line">  <span class="hljs-keyword">int</span> n, m, a, id;</span><br><span class="line">  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Query &amp;x) <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a &lt; x.a; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;Q[N + <span class="hljs-number">5</span>]; </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> id, d; </span><br><span class="line">  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;x) <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> d &lt; x.d; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;A[N + <span class="hljs-number">5</span>]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  prework(); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;Q[i].n, &amp;Q[i].m, &amp;Q[i].a), Q[i].id = i; </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) A[i].d = F[i], A[i].id = i; </span><br><span class="line">  sort(Q + <span class="hljs-number">1</span>, Q + T + <span class="hljs-number">1</span>); sort(A + <span class="hljs-number">1</span>, A + N + <span class="hljs-number">1</span>); <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>; </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">while</span>(pos &lt; N &amp;&amp; A[pos + <span class="hljs-number">1</span>].d &lt;= Q[i].a) &#123;</span><br><span class="line">      ++pos;</span><br><span class="line">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; A[pos].id * j &lt;= N; j++)</span><br><span class="line">        add(j * A[pos].id, A[pos].d * mu[j]);</span><br><span class="line">        </span><br><span class="line">    &#125; ans[Q[i].id] = calc(Q[i].n, Q[i].m); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans[i] &amp; <span class="hljs-number">2147483647</span>); </span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;$T$ 组询问，定义 $F(n)=\sum\limits_{d|n}d$。每次给出 $n,m,a$ 求  &lt;/p&gt;
&lt;p&gt;$$\sum\limits_{i=1,j=1,F(\gcd(i,j)) \leq a}^{i\leq n, j \leq m} F (\gcd(i,j))$$&lt;/p&gt;
&lt;p&gt;$T \leq 20000;n,m,a\leq 10^5$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://yoursite.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
