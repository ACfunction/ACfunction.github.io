{"meta":{"title":"AcF's Blog","subtitle":null,"description":"向来心是看客心，乃何人是剧中人","author":"AcFunction","url":"http://yoursite.com"},"pages":[{"title":"友链","date":"2019-01-19T05:33:17.000Z","updated":"2019-08-15T13:37:46.764Z","comments":true,"path":"Links/index.html","permalink":"http://yoursite.com/Links/index.html","excerpt":"","text":"常用 OJ Luogu | BZOJ | LOJ | UOJ | CodeForces | AtCoder | CodeChef 常用网站Github | Graph Editor | OEIS | OIerDb 友链欢迎交换友链=w= 我的博客园 戳这里 同学 P_Wang 戳这里 WZL 大佬 戳这里 书海扬帆 戳这里 大佬 Siyuan 小姐姐 Orz 戳这里 LiM_817 神仙 Orz 戳这里 blunt-axe 神仙 Orz 戳这里"},{"title":"categories","date":"2019-10-17T12:21:32.000Z","updated":"2019-10-17T12:21:32.691Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"「AGC036B」Do Not Duplicate","slug":"AGC036B","date":"2019-09-06T12:48:10.000Z","updated":"2019-10-17T12:47:00.003Z","comments":true,"path":"2019/09/06/AGC036B/","link":"","permalink":"http://yoursite.com/2019/09/06/AGC036B/","excerpt":"Description给一个长度为 $n$ 的序列 $a_i$ 和一个数 $k$ 。现在把 $a$ 序列重复 $k$ 次生成一个数列 $b$ ，然后从第一位开始往一个栈中加入 $b_i$ 。如果这个栈里存在元素与 $b_i$ 相等那么一直 $\\text{pop}$ 直到把那个数弹掉然后不加入新数；否则 $\\text{push}$ $b_i$ 入栈。求全部操作完之后栈中的元素。 数据范围：$n \\leq 2 \\times 10^5, k \\leq 10^{12}, a_i \\leq 2 \\times 10^5$","text":"Description给一个长度为 $n$ 的序列 $a_i$ 和一个数 $k$ 。现在把 $a$ 序列重复 $k$ 次生成一个数列 $b$ ，然后从第一位开始往一个栈中加入 $b_i$ 。如果这个栈里存在元素与 $b_i$ 相等那么一直 $\\text{pop}$ 直到把那个数弹掉然后不加入新数；否则 $\\text{push}$ $b_i$ 入栈。求全部操作完之后栈中的元素。 数据范围：$n \\leq 2 \\times 10^5, k \\leq 10^{12}, a_i \\leq 2 \\times 10^5$ Solution把 $a_i$ 排在一个圆周上，定义 $nxt_i = j$ 表示沿着顺时针方向第一个 $j$ 使得 $a_i=a_j$ 。 可以发现，假设目前栈中第一个元素是 $a_x = y$ ，那么下一次这个栈被整体清空是加入了$nxt_x$ 之后。特别的，如果 $nxt_x = x$ ，那么就是再加一遍整个 $a_i$ 之后再次清空。 自然地可以想象 $x$ 向 $nxt_x +1$ 加一条边，表示 $x$ 之后下一个第一个下标会是 $nxt_x + 1$。这样的得到的图会形成一个一个环。也就是说，加了若干次 $a$ 后，全部都被清空，回到原点，也就是循环节。 我们可以把 $k$ 模上循环节，然后再对余下的不完整的部分直接模拟跳环的过程。如果一个时刻所加的数总数超出了 $k$ 就直接能够模拟一遍得到答案。 由于最后跳环每次最多会跳出去 $n+1$ 个点，并且循环节长度不会超过 $n(n+1)$ ，所以最后最多跳 $n$ 次以及统计答案时最多只需要考虑 $n$ 个点。所以时间复杂度为 $O(n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * Author: AcFunction * Date: 2019-09-04 21:48:14 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define ldb long double #define fi first#define se second#define MP make_pair#define pii pair &lt;int, int&gt;#define pil pair &lt;int, ll&gt; #define pli pair &lt;ll, int&gt;#define pll pair &lt;ll, ll&gt; #define All(x) x.begin(), x.end()#define pb push_back#define pf push_front#define ms0(x) memset(x, 0, sizeof(x))#define ms1(x) memset(x, -1, sizeof(x))#define oiu cerr &lt;&lt; \"Yes!\" &lt;&lt; endl; #define O(x) cerr &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl; template &lt;typename T&gt; void printarr(T a[], int b, int e) &#123; if(b &gt; e) return ; for(int i = b; i &lt; e; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; a[e] &lt;&lt; \" \" &lt;&lt; endl; &#125; template &lt;typename T&gt; int chkmax(T &amp;x, const T &amp;y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;template &lt;typename T&gt; int chkmin(T &amp;x, const T &amp;y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;const int N = 5001000; int n;int nxt[N], fir[N], pos[N], a[N], ans[N], cnt, len[N];ll k; int main() &#123; scanf(\"%d %lld\", &amp;n, &amp;k); k *= n; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); if(!fir[a[i]]) &#123; fir[a[i]] = i; pos[a[i]] = i; &#125; else &#123; nxt[pos[a[i]]] = i; pos[a[i]] = i; &#125; nxt[i] = fir[a[i]]; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(nxt[i] &gt; i) &#123; len[i] = nxt[i] - i + 1; &#125; else len[i] = n - (i - nxt[i] - 1); &#125; int u = 1; ll num = 0; while(1) &#123; num += len[u]; u = nxt[u] + 1; if(u &gt; n) u -= n; if(u == 1) break ; &#125; k = k % num; if(!k) return 0; u = 1; num = 0; // k *= n; while(1) &#123; num += len[u]; if(num &gt;= k) &#123; num -= len[u]; for(int j = u; j &lt;= u + k - num - 1; j++) &#123; int t = j; if(t &gt; n) t -= n; ans[++cnt] = a[t]; &#125; for(int i = 1; i &lt;= cnt; i++) pos[ans[i]] = fir[ans[i]] = nxt[i] = 0; for(int i = 1; i &lt;= cnt; i++) &#123; if(!fir[ans[i]]) &#123; fir[ans[i]] = i; pos[ans[i]] = i; &#125; else &#123; nxt[pos[ans[i]]] = i; pos[ans[i]] = i; &#125; nxt[i] = fir[ans[i]]; &#125; int p = 1; while(p &lt;= cnt) &#123; if(nxt[p] &gt; p) &#123; p = nxt[p] + 1; &#125; else &#123; printf(\"%d \", ans[p]); p++; &#125; &#125; return 0; &#125; u = nxt[u] + 1; if(u &gt; n) u -= n; &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"思维题","slug":"思维题","permalink":"http://yoursite.com/tags/思维题/"}]},{"title":"「AGC037B」RGB Balls","slug":"AGC037B","date":"2019-09-06T12:47:58.000Z","updated":"2019-09-07T02:45:12.290Z","comments":true,"path":"2019/09/06/AGC037B/","link":"","permalink":"http://yoursite.com/2019/09/06/AGC037B/","excerpt":"Description有 $3n$ 个球摆成一列，其中有 $\\text{RGB}$ 每种颜色各 $n$ 个。现在第 $i$ 个人有三个颜色互不相同的球，并且在序列中的位置从小到大是 $a_i &lt;b_i &lt; c_i$ 。求在保证 $\\sum c_i - a_i$ 最小的情况下有多少种分球方案。答案对 $998244353$ 取模。 数据范围：$n \\leq 10^5$","text":"Description有 $3n$ 个球摆成一列，其中有 $\\text{RGB}$ 每种颜色各 $n$ 个。现在第 $i$ 个人有三个颜色互不相同的球，并且在序列中的位置从小到大是 $a_i &lt;b_i &lt; c_i$ 。求在保证 $\\sum c_i - a_i$ 最小的情况下有多少种分球方案。答案对 $998244353$ 取模。 数据范围：$n \\leq 10^5$ Solution自然地第一步要想的是如何满足 $\\sum c_i - a_i$ 最小。 我们换一个角度来分析它。把问题看成从前往后把每一个球给一个人。那么对于每一个人，他对答案产生的贡献是他手中已经分了球但是还没有凑全三个球的时刻数。 于是便可以贪心的最小化每一个时刻手中拿了球但是没有拿全三个的人数。 对于一个时刻，不妨设目前球数最多的是 $\\text{R}$ ，其次是 $\\text{G}$ ，然后是 $\\text{B}$ 。那么此时最优的情况一定是若干组 $\\text{RGB}$ 加上若干组 $\\text{RG}$ 再加上若干组 $\\text{R}$ 。于是便可以解决 $\\sum c_i - a_i$ 最小的问题。 方案数也能够求出。每次新加一个球的时候看他是原来的第几大和现在的第几大。方案数相应的乘上能够放进的组的个数即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define ldb long double #define fi first#define se second#define MP make_pair#define pii pair &lt;int, int&gt;#define pil pair &lt;int, ll&gt; #define pli pair &lt;ll, int&gt;#define pll pair &lt;ll, ll&gt; #define All(x) x.begin(), x.end()#define pb push_back#define pf push_front#define ms0(x) memset(x, 0, sizeof(x))#define ms1(x) memset(x, -1, sizeof(x))#define oye cerr &lt;&lt; \"Yes!\" &lt;&lt; endl; #define O(x) cerr &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl; template &lt;typename T&gt; void printarr(T a[], int b, int e) &#123; if(b &gt; e) return ; for(int i = b; i &lt; e; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; a[e] &lt;&lt; endl; &#125; template &lt;typename T&gt; int chkmax(T &amp;x, const T &amp;y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;template &lt;typename T&gt; int chkmin(T &amp;x, const T &amp;y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;const int N = 1001000; const int mod = 998244353; int addp(int x, int y) &#123; return (x += y) &gt;= mod ? x - mod : x; &#125;char s[N]; int n; int ans = 1;int cnt[3]; int main() &#123; scanf(\"%d\", &amp;n); n *= 3; scanf(\"%s\", s + 1); for(int i = 1; i &lt;= n; i++) &#123; int x[3], y[3]; x[0] = cnt[0]; x[1] = cnt[1], x[2] = cnt[2]; sort(x, x + 3); int op = 0; if(s[i] == 'R') op = 0; if(s[i] == 'G') op = 1; if(s[i] == 'B') op = 2; cnt[op]++; y[0] = cnt[0]; y[1] = cnt[1], y[2] = cnt[2]; sort(y, y + 3); if(y[2] != x[2]) &#123; ; // ans = 1ll * ans * x[2] % mod; &#125; else if(y[0] != x[0]) &#123; ans = 1ll * ans * (x[1] - x[0]) % mod; &#125; else &#123; ans = 1ll * ans * (x[2] - x[1]) % mod; &#125; &#125; for(int i = 1; i &lt;= n / 3; i++) ans = 1ll * ans * i % mod; printf(\"%d\\n\", ans); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"思维题","slug":"思维题","permalink":"http://yoursite.com/tags/思维题/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"CF547E Mike and Friends","slug":"CF547E","date":"2019-08-23T04:40:18.000Z","updated":"2019-08-23T04:44:11.624Z","comments":true,"path":"2019/08/23/CF547E/","link":"","permalink":"http://yoursite.com/2019/08/23/CF547E/","excerpt":"Description给定 $ n $ 个串 $ s_1, s_2, \\cdots, s_n $ 和 $q$ 个询问，每次查询 $ s_i $ 一共在 $ s_l, s_{l+1}, \\cdots, s_r $ 出现了多少次。 $ n, q, \\sum \\limits_{i=1}^{n} |s_i| \\leq 2 \\times 10^5 $。","text":"Description给定 $ n $ 个串 $ s_1, s_2, \\cdots, s_n $ 和 $q$ 个询问，每次查询 $ s_i $ 一共在 $ s_l, s_{l+1}, \\cdots, s_r $ 出现了多少次。 $ n, q, \\sum \\limits_{i=1}^{n} |s_i| \\leq 2 \\times 10^5 $。 Solution这里有一个后缀数组的做法。 把 $ n $ 个串依次连在一起，相邻两个之间用一个 # 隔开。得到一个大串 $ \\mathtt{S} $ 。 我们可以简单地求出第 $ i $ 个串 $ s_i $ 的长度 $len_i$，在 $ \\mathtt{S} $ 中第一个字母所在的位置 $pos_i$ 以及 $ \\mathtt{S} $ 的后缀数组。 对于一个询问，假设询问串是 $s_k$，他在一个位置 $p$ 出现当且仅当从 $p$ 开始的后缀与从 $pos_k$ 开始的后缀的 $\\mathtt{LCP} $ 的长度 $\\ge len_k $ 。 众所周知，两个后缀 $i, j (\\mathtt{rk[i]} &lt; \\mathtt{rk[j]})$ 的 $ \\mathtt{LCP} $ 就是 $\\min\\limits_{\\mathtt{rk[i] + 1} \\le x \\le \\mathtt{rk[j]}} \\{\\mathtt{height[x]}\\}$ ，也就是一段区间的最小值。 对于每个 $k$ ，我们可以简单地通过二分来找到最长的一段包含 $\\mathtt{rk[k]}$ 的区间 $[L_k, R_k]$ 使得这一段区间中的 $\\mathtt{height[i]}$ 最小值 $ \\ge len_i$ 。 那么如果一个后缀的前缀是 $s_k$ ，那么他的 $ \\mathtt{rk} $ 必须要在 $[L_k, R_k]$ 中。 而我们想要的是 $s_l, s_{l+1}, \\cdots, s_r$ 中出现了多少次 $s_k$ ，所以这个后缀的出现位置 $i$ 要满足 $pos_l \\le i \\le pos_{r+1}-1$ 。为了方便，我们假设 $pos_{n+1} = |S|+1$ 。 做法已经比较显然：如果把后缀 $i$ 对应成平面直角坐标系中的点 $(i, rk_i)$ ，那么对于一个询问 $l, r, k$ ，答案便是左下角为 $(pos_l, L_k)$ ，右上角为 $(pos_{r+1}-1, R_k)$ 的矩形中点的个数。 这便是一个经典问题。只需要把一个询问拆成四个，拿出来按照第一关键字排序，按照顺序扫一遍，对于每个新的询问把满足第一维限制的点的第二维坐标加一，询问就查询前缀和即可。可以用一个简单的树状数组维护。 时间复杂度 $O(n \\log n)$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * Author: AcFunction * Date: 2019-08-20 12:57:11 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long long#define db double#define PII pair &lt;int, int&gt; #define pb push_back #define fi first#define se second #define MP make_pairusing namespace std;const int N = 1002000; int n, qq, m, rk[N], sa[N], cnt[N], c[N]; int len[N], pos[N], h[N], st[N][25], lg2[N], ans[N];char s[N]; string S; char A[N]; int Lp[N], Rp[N], tot; struct node &#123; int x, y, id; &#125; a[N], b[N]; struct Query &#123; int x, y, id, typ; bool operator &lt; (const Query &amp;t) const &#123; return x == t.x ? y &lt; t.y : x &lt; t.x; &#125;&#125; Q[N * 4]; int lcp(int l, int r) &#123; if(l &gt; r) return -1; int k = lg2[r - l + 1]; return min(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]); &#125;int lb(int x) &#123; return x &amp; (-x); &#125;int add(int x, int d) &#123; for(int i = x; i &lt;= m; i += lb(i)) c[i] += d;&#125;int sum(int x) &#123; int ret = 0; for(int i = x; i; i -= lb(i)) ret += c[i]; return ret; &#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;qq); int nowlen = 1; for(int i = 1; i &lt;= n; i++) &#123; pos[i] = nowlen; scanf(\"%s\", s + 1); len[i] = strlen(s + 1); for(int j = 1; j &lt;= len[i]; j++) S += s[j]; nowlen += len[i] + 1; S += '#'; &#125; m = S.length(); pos[n + 1] = m + 1; A[0] = '#'; for(int i = 0; i &lt; m; i++) A[i + 1] = S[i]; for(int i = 1; i &lt;= m; i++) cnt[A[i]]++; for(int i = 1; i &lt;= 256; i++) cnt[i] += cnt[i - 1]; for(int i = 1; i &lt;= m; i++) rk[i] = cnt[A[i]]; for(int L = 1; L &lt;= m; L &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= m; i++) &#123; a[i].x = rk[i], a[i].y = rk[i + L]; a[i].id = i; &#125; for(int i = 1; i &lt;= m; i++) cnt[i] = 0; for(int i = 1; i &lt;= m; i++) cnt[a[i].y]++; for(int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for(int i = 1; i &lt;= m; i++) b[cnt[a[i].y]--] = a[i]; for(int i = 1; i &lt;= m; i++) cnt[i] = 0; for(int i = 1; i &lt;= m; i++) cnt[b[i].x]++; for(int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for(int i = m; i &gt;= 1; i--) a[cnt[b[i].x]--] = b[i]; for(int i = 1; i &lt;= m; i++) &#123; if(a[i].x == a[i - 1].x &amp;&amp; a[i].y == a[i - 1].y) rk[a[i].id] = rk[a[i - 1].id]; else rk[a[i].id] = rk[a[i - 1].id] + 1; &#125; &#125; for(int i = 2; i &lt;= m; i++) lg2[i] = lg2[i &gt;&gt; 1] + 1; for(int i = 1; i &lt;= m; i++) sa[rk[i]] = i; int k = 0; for(int i = 1; i &lt;= m; i++) &#123; if(k) k--; int j = sa[rk[i] - 1]; while(i + k &lt;= m &amp;&amp; j + k &lt;= m &amp;&amp; A[i + k] == A[j + k]) k++; h[rk[i]] = k; &#125; for(int i = 1; i &lt;= m; i++) st[i][0] = h[i]; for(int j = 1; (1 &lt;&lt; j) &lt;= m; j++) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= m; i++) st[i][j] = min(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); for(int i = 1; i &lt;= n; i++) &#123; int pp = pos[i]; int l = rk[pp] + 1, r = m; Lp[i] = Rp[i] = rk[pp]; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(lcp(rk[pp] + 1, mid) &gt;= len[i]) &#123; Rp[i] = mid; l = mid + 1; &#125; else r = mid - 1; &#125; l = 1, r = rk[pp]; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(lcp(mid + 1, rk[pp]) &gt;= len[i]) &#123; Lp[i] = mid; r = mid - 1; &#125; else l = mid + 1; &#125; &#125; for(int i = 1; i &lt;= qq; i++) &#123; int l, r, k; scanf(\"%d %d %d\", &amp;l, &amp;r, &amp;k); Q[++tot] = &#123;pos[l] - 1, Lp[k] - 1, i, 1&#125;; Q[++tot] = &#123;pos[r + 1] - 1, Lp[k] - 1, i, -1&#125;; Q[++tot] = &#123;pos[l] - 1, Rp[k], i, -1&#125;; Q[++tot] = &#123;pos[r + 1] - 1, Rp[k], i, 1&#125;; &#125; int P = 1; sort(Q + 1, Q + tot + 1); for(int i = 1; i &lt;= tot; i++) &#123; while(P &lt;= Q[i].x &amp;&amp; P &lt;= m) &#123; add(rk[P], 1); P++; &#125; // cout &lt;&lt; Q[i].x &lt;&lt; \" \" &lt;&lt; Q[i].y &lt;&lt; endl; // cout &lt;&lt; P &lt;&lt; endl; ans[Q[i].id] += Q[i].typ * sum(Q[i].y); &#125; for(int i = 1; i &lt;= qq; i++) printf(\"%d\\n\", ans[i]); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://yoursite.com/tags/后缀数组/"}]},{"title":"CF886E Maximum Element","slug":"CF886E","date":"2019-08-02T12:56:48.000Z","updated":"2019-08-02T13:49:45.916Z","comments":true,"path":"2019/08/02/CF886E/","link":"","permalink":"http://yoursite.com/2019/08/02/CF886E/","excerpt":"Description​ 有一个排列 $a_1, a_2,\\cdots, a_n$。已知一种求最大值的方式：遍历一遍序列，如果一个数比他后面的 $k$ 个值都要大，则直接返回该值。求有多少个排列使得这种方式返回的答案是错误的。 ​ $n, k \\leq 10^6$ 。","text":"Description​ 有一个排列 $a_1, a_2,\\cdots, a_n$。已知一种求最大值的方式：遍历一遍序列，如果一个数比他后面的 $k$ 个值都要大，则直接返回该值。求有多少个排列使得这种方式返回的答案是错误的。 ​ $n, k \\leq 10^6$ 。 Solution​ 考虑如何求正确的排列个数。可以发现，如果一个序列在求最大值时还没有遍历到 $n$ 就中途退出了，那么他返回的一定不会是正确的值。 ​ 于是可以设计出 $dp$ 状态：$dp_i$ 表示遍历完前 $i$ 个数依然没有返回的 $1,2,\\cdots, i$ 的排列个数 。 ​ 注意，这里只考虑 $1, 2, \\cdots, i$ 的排列个数，即他们的相对大小关系。 ​ 转移时，我们可以枚举前 $i - 1$ 个数的最大值所在的位置 $j$。显然有几个性质。一是 $j$ 要在 $[i - k + 1, i]$ 内，否则就会退出；二是在遍历到这个最大值之前不能退出；三是这个最大值之后的 $i - j$ 个位置可以随便交换位置，原因是他们不会对退出这件事造成任何影响。 ​ 于是，我们可以列出转移方程： dp_i = \\sum\\limits_{j=i-k+1}^{i} \\binom{i-1}{j-1} \\cdot dp_{j-1} \\cdot (i-j)!​ 暴力 dp 是 $O(n^2)$ 的，考虑把组合数拆开，简单推导可得： dp_i = (i-1)!\\cdot \\sum\\limits_{j=i-k}^{i-1} \\frac{dp_j}{j!}​ 直接维护 $\\sum\\limits_{j=i-k}^{i-1} \\frac{dp_j}{j!}$ 即可。 ​ 最后的答案如何计算？考虑最大值的位置 $i​$ ，有： \\begin{aligned} ans &= n!- \\sum\\limits_{i=1}^{n} dp_{i-1} \\cdot \\binom{n-1}{i-1} \\cdot (n-i)! \\\\ &= n!-(n-1)!\\cdot \\sum\\limits_{i=1}^{n} \\frac{dp_{i-1}}{(i-1)!} \\end{aligned}​ 时间复杂度 $O(n)$。 Code代码中可以考虑直接维护 $\\frac{dp_i}{i!}$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N = (int)1e6 + 10; const int mod = 1000000007;int n, k, f[N], g[N], dp[N]; int add(int x, int y) &#123; return (x += y) &gt;= mod ? x - mod : x; &#125;int fpw(int x, int k, int p) &#123; int ret = 1; while(k) &#123; if(k &amp; 1) ret = 1ll * ret * x % p; x = 1ll * x * x % p; k &gt;&gt;= 1; &#125; return ret; &#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;k); f[0] = 1; for(int i = 1; i &lt;= n; i++) f[i] = 1ll * f[i - 1] * i % mod; g[n] = fpw(f[n], mod - 2, mod); for(int i = n - 1; i &gt;= 0; i--) g[i] = 1ll * g[i + 1] * (i + 1) % mod; int s = 0; dp[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; s = add(s, dp[i - 1]); if(i &gt; k) s = add(s, mod - dp[i - k - 1]); dp[i] = 1ll * g[i] * f[i - 1] % mod * s % mod; &#125; s = 0; for(int i = 1; i &lt;= n; i++) s = add(s, dp[i - 1]); printf(\"%lld\\n\", 1ll * f[n - 1] * add(n, mod - s) % mod); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"CF848C Goodbye Souvenir","slug":"CF848C","date":"2019-07-07T14:00:36.000Z","updated":"2019-07-07T14:28:13.250Z","comments":true,"path":"2019/07/07/CF848C/","link":"","permalink":"http://yoursite.com/2019/07/07/CF848C/","excerpt":"Description给出一个长度为 $n$ 的序列 $a_i$，$1 \\le a_i \\le n$ 。有 $m$ 个操作，每次操作输入三个数 $o,x,y$ 表示 $o=1$ ，此时表示令 $a_x=y$ $o=2$ ，此时表示询问 $\\sum_{i=1}^n v(i)$ 。其中 $v(i)$ 是数字 $i$ 在 $[x,y]$ 中最后一次出现的位置减去第一次出现的位置。如果没有出现，则 $v(i) = 0$ $n, m \\leq 10^5$","text":"Description给出一个长度为 $n$ 的序列 $a_i$，$1 \\le a_i \\le n$ 。有 $m$ 个操作，每次操作输入三个数 $o,x,y$ 表示 $o=1$ ，此时表示令 $a_x=y$ $o=2$ ，此时表示询问 $\\sum_{i=1}^n v(i)$ 。其中 $v(i)$ 是数字 $i$ 在 $[x,y]$ 中最后一次出现的位置减去第一次出现的位置。如果没有出现，则 $v(i) = 0$ $n, m \\leq 10^5$ Solution我们令 $pre_i$ 表示最大的 $j$ 满足 $j &lt; i$ 且 $a_j = a_i$ （若不存在这样的 $j$ 则 $j = 0$） 同样的 $nxt_i$ 表示最小的 $j$ 满足 $j &gt; i$ 且 $a_j = a_i$ （若不存在这样的 $j$ 则 $j = n+1$） 如果没有修改操作，那么我们把每一个 $(i, pre_i)$ 这样的二元组看成坐标上的一个点，他的值为 $i - pre_i$ ，那么每次询问 $[l, r]$ 的答案就是一个左下角为 $(l,l)$ 右上角为 $(r,r)$ 的矩（正方）形内的所有点值之和（包括边）。 这样做的原因在于，对于一个值，如果他最后一次出现在 $e$ 这个位置，第一次出现在 $s$ 这个位置，那么他对答案的贡献就是 $s-e = (s - pre_s) + (pre_s - pre_{pre_s})+ \\cdots+(nxt_s - s)$ 即把 $[s, e]$ 这个区间拆分成若干个 $[pre_i, i]$ 的区间。如果把 $(i, pre_i)$ 看成一个坐标系上的点，那么他的两个维度都满足在 $[l, r]$ 中，那么他会对答案产生贡献；反之，$[l, r]$ 内的答案也是由这些点的贡献所组成的。 有了修改操作，直接用 $n$ 个 set 维护一下 $nxt$ 和 $pre$ 。对于每一个 $a[x] = y$ 修改，会减少 $(x, pre_{a_x}), (nxt_{a_x}, x), (nxt_y, pre_y)$ 三个点，增加了 $(nxt_{a_x}, pre_{a_x}), (x, pre_y), (nxt_y, x)$ 三个点。（注意这里的 $nxt_a, pre_a$ 表示的是对于 $a$ 这个值在 $x$ 这个位置之前/之后第一次出现的位置）。于是问题转化成一个加点删点求矩形内部值之和，可以以时间为第一维，$i$ 为第二维，$pre_i$ 为第三维用CDQ分治做三维偏序就做完了。（询问矩阵再用一个差分） 时间复杂度：$O(n \\log^2 n)$ （由于点数可能很多所以参与 CDQ 分治的点有大概 $6n$ 个所以很慢） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * Author: AcFunction * Date: 2019-07-06 17:01:34 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 500500; int n, m, a[N], nxt[N], pre[N], po[N]; int tot, fla[N]; ll ans[N], c[N]; set &lt;int&gt; s[100001]; struct Query &#123; int op, y, z, v, id; &#125; Q[N * 2]; void mk (int op, int y, int z, int v, int id) &#123; Q[++tot].y = y, Q[tot].z = z; Q[tot].id = id; Q[tot].op = op; Q[tot].v = v; &#125;int lb(int x) &#123; return x &amp; (-x); &#125;void add(int x, int d) &#123; for(int i = x; i &lt;= 100005; i += lb(i)) c[i] += d; &#125;ll sum(int x) &#123; ll ret = 0; for(int i = x; i; i -= lb(i)) ret += c[i]; return ret; &#125;bool cmp(Query x, Query y) &#123; return x.y &lt; y.y; &#125;void CDQ(int l, int r) &#123; if(l == r) return ; int mid = (l + r) &gt;&gt; 1; CDQ(l, mid); CDQ(mid + 1, r); sort(Q + l, Q + mid + 1, cmp); sort(Q + mid + 1, Q + r + 1, cmp); int pos = l; for(int i = mid + 1; i &lt;= r; i++) &#123; while(pos &lt;= mid &amp;&amp; Q[pos].y &lt;= Q[i].y) &#123; if(Q[pos].op == 0) add(Q[pos].z + 1, Q[pos].v); pos++; &#125; if(Q[i].op == 1) &#123; ans[Q[i].id] += sum(Q[i].z + 1); &#125; &#125; for(int i = l; i &lt; pos; i++) &#123; if(Q[i].op == 0) add(Q[i].z + 1, -(Q[i].v)); &#125;&#125; int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; s[i].insert(0), s[i].insert(n + 1); scanf(\"%d\", &amp;a[i]); pre[i] = po[a[i]]; po[a[i]] = i; mk(0, i, pre[i], i - pre[i], 0); s[a[i]].insert(i); &#125; for(int i = 1; i &lt;= n; i++) po[i] = n + 1; for(int i = n; i &gt;= 1; i--) &#123; nxt[i] = po[a[i]]; po[a[i]] = i; &#125; for(int i = 1; i &lt;= m; i++) &#123; int op, x, y; scanf(\"%d %d %d\", &amp;op, &amp;x, &amp;y); if(op == 1) &#123; if(a[x] == y) continue ; mk(0, x, pre[x], pre[x] - x, 0); mk(0, nxt[x], x, x - nxt[x], 0); mk(0, nxt[x], pre[x], nxt[x] - pre[x], 0); nxt[pre[x]] = nxt[x]; pre[nxt[x]] = pre[x]; s[a[x]].erase(x); a[x] = y; s[y].insert(x); set &lt; int &gt; :: iterator Nw = s[y].find(x); int Pr = *(--Nw), Nx = *(++(++(Nw))); mk(0, Nx, Pr, Pr - Nx, 0); mk(0, x, Pr, x - Pr, 0); mk(0, Nx, x, Nx - x, 0); pre[Nx] = nxt[Pr] = x; pre[x] = Pr, nxt[x] = Nx; &#125; else &#123; mk(1, x - 1, x - 1, 0, i * 4 - 3); mk(1, x - 1, y, 0, i * 4 - 2); mk(1, y, x - 1, 0, i * 4 - 1); mk(1, y, y, 0, i * 4); fla[i] = 1; &#125; &#125; CDQ(1, tot); for(int i = 1; i &lt;= m; i++) &#123; if(fla[i]) &#123; printf(\"%lld\\n\", ans[i * 4 - 3] - ans[i * 4 - 2] - ans[i * 4 - 1] + ans[i * 4]); &#125; &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://yoursite.com/tags/CDQ分治/"}]},{"title":"BZOJ4828 「HNOI2017」大佬","slug":"BZOJ4828","date":"2019-06-21T10:34:44.000Z","updated":"2019-06-21T11:48:44.227Z","comments":true,"path":"2019/06/21/BZOJ4828/","link":"","permalink":"http://yoursite.com/2019/06/21/BZOJ4828/","excerpt":"Description你现在要怼 $m$ 个大佬，第 $i$ 个大佬的自信值是 $C_i$ 。每次怼大佬之前，你的自信值是 $mc$，等级 $L=0$，嘲讽值 $F = 1$。对于每一个大佬，你都有 $n$ 天时间来怼大佬。无论哪个大佬，他们都会在第 $i$ 天使你的的自信值下降 $a_i$ 如果你的自信值为负数，那么你失败了。在第 $i$ 天，你可以干一下事情中的恰好一件： 使得大佬自信值下降 $1$ 使得自己的自信值增加 $w_i$ 把自己的等级 $+1$ 把自己的 $F$ 乘上 $L$ 怼大佬，使得大佬的自信值下降 $F$，之后$L=0$ ，$F=1$ 如果中途大佬自信值为负数，你失败了。若大佬自信值恰好为 $0​$ ，则你成功了。 对于每个大佬求你能否成功。","text":"Description你现在要怼 $m$ 个大佬，第 $i$ 个大佬的自信值是 $C_i$ 。每次怼大佬之前，你的自信值是 $mc$，等级 $L=0$，嘲讽值 $F = 1$。对于每一个大佬，你都有 $n$ 天时间来怼大佬。无论哪个大佬，他们都会在第 $i$ 天使你的的自信值下降 $a_i$ 如果你的自信值为负数，那么你失败了。在第 $i$ 天，你可以干一下事情中的恰好一件： 使得大佬自信值下降 $1$ 使得自己的自信值增加 $w_i$ 把自己的等级 $+1$ 把自己的 $F$ 乘上 $L$ 怼大佬，使得大佬的自信值下降 $F$，之后$L=0$ ，$F=1$ 如果中途大佬自信值为负数，你失败了。若大佬自信值恰好为 $0​$ ，则你成功了。 对于每个大佬求你能否成功。 Solution首先，可以发现，怼大佬和活下来两件事是互相独立的。并且怼大佬只与天数相关。显然天数越多越有可能。 所以先用一遍简单 dp 得出最多能剩下多少天来怼大佬并且保证自己活下来。设最多天数是 $D$ 。 然后用一遍 BFS 的出所有二元组 $(d, f)$ 表示用了 $d(&lt;D)$ 天并且此时 $F = f$ 。注意去重。 你能怼死大佬有三种情况： 不怼大佬。只执行 $1$ 操作。此时需要满足 $C_i \\leq D$ 只怼一次大佬。这时能怼死大佬需要满足存在一个二元组 $(d’,f’)$ 使得 $f’ \\leq C_i$ 并且 $f’+D - d \\ge C_i$ （一次不能怼死，用 $1$ 操作耗死） 怼两次。可以发现，若两次分别是 $(d_1,f_1), (d_2, f_2)$ 则类似于第二种情况，有 $f_1+f_2\\leq C_i$ 并且 $f_1+f_2+(D-d_1-d_2) \\ge C_i$ 。显然，对于一个 $f_i$ ，只有最小的那个 $d_i$ 才是最优的。所以我们对每个 $f$ 只保存最小的 $d$ ，并且按照 $f$ 排序。由于需要满足$f_1+f_2\\leq C_i$， 就可以直接用双指针扫一遍，中途判断是否存在 $f_1+f_2+(D-d_1-d_2) \\ge C_i$ 即可。 由于 $f$ 增长的很快，导致二元组不会特别多，于是可以通过此题。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Author: AcFunction * Date: 2019-06-21 14:35:24 * Email: 3486942970@qq.com**/ #include &lt;bits/stdc++.h&gt;#define PII pair &lt;int, int&gt; #define fi first #define se second #define MP make_pair using namespace std; const int N = 105; const int NN = (int)3e6 + 10; const int INF = (int)1e9; int n, m, mc, mxc, cnt, tot; int a[N], w[N], dp[N][N], D, C[22]; pair &lt;int, PII&gt; Q[NN]; PII A[NN], B[NN]; map &lt;PII, int&gt; mp; map &lt;int, int&gt; mmp; void getday() &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = a[i]; j &lt;= mc; j++) &#123; dp[i][j - a[i]] = max(dp[i][j - a[i]], dp[i - 1][j] + 1); int t = min(j - a[i] + w[i], mc); dp[i][t] = max(dp[i][t], dp[i - 1][j]); &#125; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= mc; j++) D = max(D, dp[i][j]); &#125; void getst() &#123; int h = 1, t = 0; // fi : day // se.fi : level // se.se : att Q[++t] = MP(1, MP(0, 1)); mp[MP(1, 1)] = 1; while(h &lt;= t) &#123; pair &lt;int, PII&gt; tmp = Q[h++]; if(tmp.fi &gt;= D) continue ; int d = tmp.fi, l = tmp.se.fi, f = tmp.se.se; Q[++t] = MP(d + 1, MP(l + 1, f)); mp[MP(d + 1, f)] = 1; if(l &gt; 1 &amp;&amp; 1ll * l * f &lt;= mxc &amp;&amp; !mp[MP(d + 1, l * f)]) &#123; int nf = l * f; Q[++t] = MP(d + 1, MP(l, nf)); mp[MP(d + 1, nf)] = 1; A[++cnt] = MP(d + 1, nf); &#125; &#125;&#125; bool cmp(PII a, PII b) &#123; return a.se == b.se ? a.fi &lt; b.fi : a.se &lt; b.se; &#125; int main() &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;mc); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;w[i]); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;C[i]); mxc = max(mxc, C[i]); &#125; getday(); getst(); sort(A + 1, A + cnt + 1, cmp); for(int i = 1; i &lt;= cnt; i++) &#123; if(!mmp[A[i].se]) &#123; mmp[A[i].se] = 1; B[++tot] = A[i]; &#125; &#125; for(int _ = 1; _ &lt;= m; _++) &#123; if(C[_] &lt;= D) &#123; puts(\"1\"); continue ; &#125; int ok = 0, pos = 1; for(int i = tot; i &gt;= 1; i--) &#123; int d = B[i].fi, f = B[i].se; if(f &lt;= C[_] &amp;&amp; D - d + f &gt;= C[_]) &#123; ok = 1; break ; &#125; int mx = -INF; while(pos &lt;= tot &amp;&amp; f + B[pos].se &lt;= C[_]) &#123; mx = max(mx, B[pos].se - B[pos].fi); pos++; &#125; if(f - d + mx &gt;= C[_] - D) &#123; ok = 1; break ; &#125; &#125; printf(\"%d\\n\", ok); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://yoursite.com/tags/two-pointers/"}]},{"title":"BZOJ4784 「ZJOI2017」仙人掌","slug":"BZOJ4784","date":"2019-06-21T10:33:51.000Z","updated":"2019-06-21T11:48:53.640Z","comments":true,"path":"2019/06/21/BZOJ4784/","link":"","permalink":"http://yoursite.com/2019/06/21/BZOJ4784/","excerpt":"Description给定一张 $n$ 个点 $m$ 条边的无向简单连通图，问有多少种加边方法使其是一颗仙人掌。 $n \\leq 5\\cdot 10^5, m \\leq \\min\\{\\frac{n\\cdot(n+1)}{2}, 10^6\\}$","text":"Description给定一张 $n$ 个点 $m$ 条边的无向简单连通图，问有多少种加边方法使其是一颗仙人掌。 $n \\leq 5\\cdot 10^5, m \\leq \\min\\{\\frac{n\\cdot(n+1)}{2}, 10^6\\}$ Solution若原图不是一颗仙人掌，直接输出 $0​$ 即可。 若其是一颗仙人掌，其中的环对答案没有贡献（既不能在其中加边，也不能向外连边），可以直接把与这个环相关的边删掉。剩下的即是一颗森林。求出每棵树的方案数将其直接累乘即可。 如果图是树的情况下怎么做？发现如果在一颗树找出若干个不相交的链，每个链的首尾连一条边，那么这个图一定是仙人掌；反之，最后加完边的图，加上的每一条边都对应一条链，每一条边也只会属于至多一个环即至多属于一个树链加上加上的边。所以问题转化成在一棵树中找出若干不相交的链的方案数。 这样还是不是特别好做，如果我们把那些没有在任何一个环的树边看成在他与他自己的环里，那么问题就转化成了 用若干条不相交的链覆盖整颗树的方案数 。 考虑树形dp。令 $dp_u​$ 为 $u​$ 的子树中所有边加上他到父亲的一条边的方案数。令 $f_x​$ 表示一个点的度数为 $x​$，把所有与它相连的边用长度不超过 $2​$ 的链全部覆盖的方案数，则 $dp_u = f_{deg_u}\\Pi _vdp_{v}​$ 。其中 $v​$ 是 $u​$ 的子节点，$deg_u​$ 是 $u​$ 的度数。 $f$ 考虑用递推求。每次新加入一条边，他可以自己是一条链，也可以与之前的一条匹配成一条链。易得 $f_n = f_{n-1}+(n-1)\\cdot f_{n-2}$ 并且 $f_0 = f_1= 1$ 。 复杂度 $O(n+m)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * Author: AcFunction * Date: 2019-05-20 22:37:18 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500500;const int M = 1000010; const int mod = 998244353; int T;int n, m;int vis[N], C[N], fa[N], dep[N];int dp[N], x[N]; struct Edge &#123; int u, v; &#125; E[M]; struct edge &#123; int v; edge *next; &#125; pool[M * 2], *h1[N], *h2[N], *h3[N], *cur = pool; // h1 : pre ; h2 : tree// h3 : delete circle// int add(int x, int y) &#123; return (x += y) &gt;= mod ? x - mod : x; &#125;void prework() &#123; x[0] = x[1] = 1; for(int i = 2; i &lt;= 500000; i++) x[i] = add(x[i - 1], 1ll * (i - 1) * x[i - 2] % mod); &#125;void ade1(int u, int v) &#123; edge *p = cur++; p-&gt;v = v; p-&gt;next = h1[u], h1[u] = p;&#125;void ade2(int u, int v) &#123; edge *p = cur++; p-&gt;v = v; p-&gt;next = h2[u], h2[u] = p; &#125;void ade3(int u, int v) &#123; edge *p = cur++; p-&gt;v = v; p-&gt;next = h3[u], h3[u] = p; &#125;void GetTree(int u, int pre) &#123; vis[u] = 1; for(edge *p = h1[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(v == pre) continue ; if(vis[v]) continue ; fa[v] = u; dep[v] = dep[u] + 1; GetTree(v, u); &#125;&#125;void GetC(int u, int pre) &#123; for(edge *p = h2[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(v == pre) continue ; GetC(v, u); C[u] += C[v]; &#125;&#125;void solve(int u, int pre) &#123; vis[u] = 1; dp[u] = 1; int cl = 0; for(edge *p = h3[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(v == pre) continue ; if(vis[v]) continue ; solve(v, u); dp[u] = 1ll * dp[u] * dp[v] % mod; ++cl; &#125; if(u == pre) dp[u] = 1ll * dp[u] * x[cl] % mod; else dp[u] = 1ll * dp[u] * x[cl + 1] % mod; &#125;int main() &#123; prework(); scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; vis[i] = C[i] = dp[i] = dep[i] = 0; h1[i] = h2[i] = h3[i] = 0; &#125; cur = pool; for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d %d\", &amp;E[i].u, &amp;E[i].v); ade1(E[i].u, E[i].v), ade1(E[i].v, E[i].u); &#125; dep[1] = 1; GetTree(1, 0); for(int i = 1; i &lt;= m; i++) &#123; if(dep[E[i].u] &lt; dep[E[i].v]) swap(E[i].u, E[i].v); int u = E[i].u, v = E[i].v; if(fa[u] == v || fa[v] == u) &#123; ade2(u, v), ade2(v, u); &#125; else C[u]++, C[v]--; &#125; GetC(1, 0); bool isc = 1; for(int i = 1; i &lt;= n; i++) if(C[i] &gt;= 2) &#123; isc = 0; break ; &#125; if(isc == 0) &#123; puts(\"0\"); continue ; &#125; for(int i = 1; i &lt;= n; i++) vis[i] = 0; for(int i = 1; i &lt;= m; i++) &#123; int u = E[i].u, v = E[i].v; if(fa[u] == v || fa[v] == u) if(!C[u]) ade3(u, v), ade3(v, u); &#125; int ans = 1; for(int i = 1; i &lt;= n; i++) &#123; if(!vis[i]) &#123; solve(i, i); ans = 1ll * ans * dp[i] % mod; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"仙人掌","slug":"仙人掌","permalink":"http://yoursite.com/tags/仙人掌/"}]},{"title":"HDU6061 RXD and functions","slug":"hdu6061","date":"2019-05-27T10:06:03.000Z","updated":"2019-05-28T13:44:34.019Z","comments":true,"path":"2019/05/27/hdu6061/","link":"","permalink":"http://yoursite.com/2019/05/27/hdu6061/","excerpt":"Description已知 $f(x) = \\sum\\limits_{i=0}^{n}c_ix^i$ ，求 $g(x) = f(x+a) = \\sum\\limits_{i=0}^{n} c_i(x+a)^i$ 的各项系数。","text":"Description已知 $f(x) = \\sum\\limits_{i=0}^{n}c_ix^i$ ，求 $g(x) = f(x+a) = \\sum\\limits_{i=0}^{n} c_i(x+a)^i$ 的各项系数。 Solution （写了半天的公式忘保存还好我留了一张图片） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N = (int)1e5 + 10; const int mod = 998244353;const int G = 3; int n, c[N], rev[1 &lt;&lt; 21], fac[N]; int fpw(int x, int k, int p) &#123; int ret = 1; while(k) &#123; if(k &amp; 1) ret = 1ll * ret * x % p; x = 1ll * x * x % p; k &gt;&gt;= 1; &#125; return ret; &#125;int add(int x, int y) &#123; return (x += y) &gt;= mod ? x - mod : x; &#125;void NTT(int *a, int L, int op) &#123; for(int i = 0; i &lt; L; i++) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(int i = 1, l = 0; i &lt; L; i &lt;&lt;= 1, l++) &#123; int w = fpw(G, (mod - 1) &gt;&gt; (l + 1), mod); if(op == -1) w = fpw(w, mod - 2, mod); for(int j = 0; j &lt; L; j += (i &lt;&lt; 1)) &#123; int wn = 1; for(int k = j; k &lt; i + j; k++) &#123; int t = (1ll * wn * a[i + k] % mod); a[i + k] = add(a[k], mod - t); a[k] = add(a[k], t); wn = (1ll * wn * w) % mod; &#125; &#125; &#125; if(op == -1) &#123; int invL = fpw(L, mod - 2, mod); for(int i = 0; i &lt; L; i++) a[i] = (1ll * a[i] * invL % mod); &#125;&#125;int f[1 &lt;&lt; 21], g[1 &lt;&lt; 21]; int main() &#123; fac[0] = 1; for(int i = 1; i &lt;= (int)1e5; i++) fac[i] = 1ll * fac[i - 1] * i % mod; while(scanf(\"%d\", &amp;n) != EOF) &#123; int A = 0; for(int i = 0; i &lt;= n; i++) scanf(\"%d\", &amp;c[i]); int L = 1, l = 0; while(L &lt;= 2 * (n + 1)) L &lt;&lt;= 1, l++; for(int i = 0; i &lt; L; i++) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | (i &amp; 1) &lt;&lt; (l - 1)); memset(f, 0, sizeof(int) * L); memset(g, 0, sizeof(int) * L); int m; scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int t; scanf(\"%d\", &amp;t); A -= t; A %= mod; &#125; A = (A + mod) % mod; for(int i = 0; i &lt;= n; i++) f[i] = 1ll * c[i] * fac[i] % mod, g[n - i] = 1ll * fpw(A, i, mod) * fpw(fac[i], mod - 2, mod) % mod; NTT(f, L, 1), NTT(g, L, 1); for(int i = 0; i &lt; L; i++) f[i] = 1ll * f[i] * g[i] % mod; NTT(f, L, -1); for(int i = n; i &lt;= 2 * n; i++) &#123; printf(\"%d \", 1ll * f[i] * fpw(fac[i - n], mod - 2, mod) % mod); &#125; putchar('\\n'); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"http://yoursite.com/tags/NTT/"}]},{"title":"一些 dp 的优化方式","slug":"一些-dp-的优化方式","date":"2019-05-14T08:57:49.000Z","updated":"2019-05-14T14:09:22.513Z","comments":true,"path":"2019/05/14/一些-dp-的优化方式/","link":"","permalink":"http://yoursite.com/2019/05/14/一些-dp-的优化方式/","excerpt":"简单总结了一下","text":"简单总结了一下 决策单调性一些时候 dp 转移方程是这个样子 dp_i = \\min\\limits_{0 \\leq j \\leq i - 1} (dp_j + w(i, j))这个时候暴力是 $O(n^2)$ 的。如果 $w(i, j)$ 满足一些特殊的性质，那么就可以优化他了。 决策单调性： 对于 $i$ ，他的决策 $opt(i)$ 就是所有的 $j$ 中使得转移式子达到最值的那个 $j$ 。 如果对于任意的 $i, j$ 使得 $i \\leq j$ 都有 $opt(i) \\leq opt(j)$ 那么就有决策单调性。 它的用处放到后面。 四边形不等式： 如果对于任意的 $1 \\leq a \\leq b \\leq c \\leq d \\leq n$ 都有 $w(a, c) + w(b, d) \\leq w(a, d) + w(b, c)$ ，那么 $w$ 就满足四边形不等式。 一个重要的事情是：如果 $w$ 满足四边形不等式，那么就有决策单调性 一个好理解的证明方式：如果没有决策单调性，那么我们可以找到不降的四个数 $a, b, c, d$ ，这四个点满足 $a = opt(d), b = opt(c)$ 即 $a, b$ 分别是 $c, d$ 的决策点。由于不满足决策单调性所以肯定能找到。此时 $dp_c + dp_d = dp_i + dp_j + w(a, d) + w(b, c)$ 。如果我们把决策点互换，即让 $b = opt(d), a = opt(c)$ ，此时 $dp_c + dp_d = dp_i + dp_j + w(a, c) + w(b, d)$ 。由于满足四边形不等式，下面的总和根据定义一定 $ \\leq $ 上面的总和。就能推出决策点交换后 $c, d$ 至少有一个要更优。所以他是满足决策单调性的。（不是很严谨） 如果看到一个题，dp式子长成上面那个样子，没有什么很好的办法搞，就要考虑决策单调性。一般都是满足四边形不等式，不放心就证一下。 有了决策单调性，然后该如何优化？ 再先看一个问题：给定一个 $n * n$ 表格，告诉你每行的最小值所在的列是单调不减的，找出每行每列的最小值及其所在的位置。 对于这个问题，我们可以利用分治来解决。用 solve(l, r, L, R) 来求解行在 $[l, r]$ 中列在 $[L, R]$ 中的子问题。每次我找到最中间的行 $mid$，暴力从 L 到 R for 找出最小值的列 $pos$，然后由于最小值位置不减，分成 solve(l, mid - 1, L, pos) 和 solve(mid + 1, r, pos, R) 继续求解。这样做的复杂度是 $O(n \\log n)$ 。 所以这和决策单调性有什么关系？如果你把最小值所在的列看成决策点所在的位置，那么是否就成功的转化成了这个问题？所以我们找出了一种 $O(n \\log n)$ 的方法。代码也十分好写。 另外一种处理决策单调性的方法在例题2中出现。 [例题1] CF 321E 题面 设 $dp[i][k]$ 表示前 $i$ 个人分了 $k$ 段的最小值。 先可以写出状态转移方程 dp[i][k] = \\min\\limits_{0 \\leq j \\leq i - 1} (dp[j][k - 1] + w(i, j))其中 $w(i, j)$ 表示把 $[j + 1, i]$ 中所有人分成一组的代价。就是一个矩阵的元素和。 由于它是矩阵的元素和，所以很显然满足四边形不等式。于是就有决策单调性。 但是有一个 $k$ 的限制。这又应该如何处理？这里可以 按层分治 。可以发现，如果有了所有的 $dp[i][k]$ ，那么通过上面的方法就可以求出所有的 $dp[i][k + 1]$。于是，预处理 $k = 1$ 的情况，然后枚举 $k$，每次分治求出下一层的信息。 复杂度 $O(n k \\log n)$ 。 [例题2] NOI2009 诗人小G 题面 方程很显然。设 $dp_i$ 表示前 $i$ 句诗的最小代价。 dp_i = \\min\\limits_{0 \\leq j \\leq i - 1} (dp_j + w(i, j))$w(i, j) = (sum_i - sum_j - L - 1) ^ P$ (这里的 $sum_i$ 是带上空格之后的，最后的减一是末位不能加空格)。 可以证明 $w$ 满足四边形不等式。分治的做法在这里行不通了。为什么之前可以？因为他是按层分治，而这里没有这个条件，你就没法及时的得到信息了。你在找最小值的时候这个地方的数可能根本没有填上。我们考虑寻找另外的方法。 当我们一个 dp 值都没有的时候，考虑目前的 $opt(i)$ 一定是： 00000000000000000000000000000000000000000000000000000000000000000000 当我们有了第一个 $dp$ 值，那么可能有一些 opt 产生变化。由于决策单调性，所以一定变化了一个后缀比如： 00000000000000000000011111111111111111111111111111111111111111111111 然后有了第二个 $dp$ 值，会有一些 opt 变成 2 。比如 00000000000000000000011111111111111111111111111111111222222222222222 如此类推，我们试图从中找出一些性质。显然，每个决策形成一个区间。 我们考虑用一个栈来维护决策。用 $l_i$ 和 $r_i$ 来表示 $i$ 这个决策所形成的的区间的左右端点。 每次加入一个新的决策 $i$，与栈顶的决策点 $t$ 比较。有两种情况： 如果在 $l_t$ 处 $t$ 的转移没有 $i$ 的优，那么这个决策整个就没有用了。即 $i$ 会把 $t$ 这一整段区间都覆盖住。此时把栈顶弹掉，继续。 不满足上述情况，那么 $i$ 的覆盖终止于 $t$ 。此时由于决策单调性，直接二分转折点 $pos$（即这个区间在转折点前是 $t$ ，后半部分是 $i$ ）。让 $r[t] = pos - 1, l[i] = pos, r[i] = n$ 这样做的复杂度是 $O(n \\log n)$ 这一部分的代码还有一些细节问题，我直接贴出 123456789101112131415161718// 注意这里的 w(i, j) 表示的是 dp[j] + 文中的 w(i, j) int h = 1, t = 0; l[0] = 1, r[0] = n;Q[++t] = 0; // 要把 0 先放进去 for(int i = 1; i &lt;= n; i++) &#123; while(h &lt;= t &amp;&amp; r[Q[h]] &lt; i) h++; // 把栈底的没用的元素弹掉。 dp[i] = w(i, Q[h]); pre[i] = Q[h]; // 更新 dp 以及 i 处的决策点 if(w(n, Q[t]) &lt; w(n, i)) continue ; // 根本不会覆盖住任何一个区间直接弹掉 while(h &lt;= t &amp;&amp; w(l[Q[t]], Q[t]) &gt; w(l[Q[t]], i)) t--; // 弹掉没用的 int lp = l[Q[t]], rp = n, pos = n; while(lp &lt;= rp) &#123; int mid = (lp + rp) &gt;&gt; 1; if(w(mid, Q[t]) &gt; w(mid, i)) &#123; pos = mid, rp = mid - 1; &#125; else lp = mid + 1; &#125; // 二分 pos l[i] = pos; r[i] = n; r[Q[t]] = pos - 1; Q[++t] = i; &#125; 斜率优化转移方程形如 $dp_i = \\min(a[j] + b[j] + c[i] \\cdot d[j])$ 。$a[i]$ 表示和 $i$ 相关的部分，其他类似。 直接用题目讲 [例题3] HNOI2008 玩具装箱TOY 题面 令$dp[i]$为前$i$个装箱的最小花费。转移方程如下： dp[i]=\\min\\limits_{0 \\leq j < i} \\{ dp[j]+( \\sum \\limits_{k = j + 1}^{i}{C_k} + i - j - 1 - L) ^ 2\\}用$sum[i]$表示前$i$个容器的长度之和（即$C$的前缀和），方程简化为： dp[i]=\\min\\limits_{0 \\leq j < i} \\{ dp[j]+( sum[i]-sum[j] + i - j - 1 - L) ^ 2\\}又令$f[i]$为$sum[i]+i$，继续简化方程为： dp[i]=\\min\\limits_{0 \\leq j < i} \\{ dp[j]+( f[i]-f[j] - 1 - L) ^ 2\\}暴力dp是$O(n^2)$，考虑优化。如何优化，就是用前面所提到的斜率优化。这玩意到底是什么？我们先来继续对状态转移方程进行进一步的推导。 对于每个$dp[i]$可以知道都是由一个$j_0$推过来的。这个$j_0$对于当前的$i$是最优的决策。假设现在有两个决策$j_1,j_2 (1 \\leq j_1 &lt; j_2 &lt; i)$，且决策$j_2$优于$j_1$，则有： dp[j_1]+( f[i]-f[j_1] - 1 - L) ^ 2 \\geq dp[j_2]+( f[i]-f[j_2] - 1 - L) ^ 2拆开可得： dp[j_1]+f[i]^2-2f[i](f[j_1]+1+L)+(f[j_1]+L+1)^2 \\geq dp[j_2]+f[i]^2-2f[i](f[j_2]+1+L)+(f[j_2]+L+1)^2化简可得： 2f[i](f[j_2] + 1 + L)-2f[i](f[j_1] + 1 + L) \\geq dp[j_2]+(f[j_2]+1+L)^2 - (dp[j_1]+(f[j_1]+1+L)^2)即： 2f[i] \\geq \\frac{dp[j_2]+(f[j_2]+1+L)^2 - (dp[j_1]+(f[j_1]+1+L)^2)}{f[j_2]-f[j_1]}令$g[i] = (f[i]+L+1)^2$，可得： 2f[i] \\geq \\frac{dp[j_2]+g[j_2] - (dp[j_1]+g[j_1])}{f[j_2]-f[j_1]}也就是说，若$j1,j2$满足上面这个式子，那么$j2$一定比$j1$优。 为什么叫斜率优化？因为上面这个式子可以把看作$dp[i]+g[i]$看做纵坐标，$f[i]$看做横坐标，上面的等式右侧就相当于 $\\frac{\\Delta y}{\\Delta x}=k$ 也就是一个一次函数的斜率。当这个斜率$k \\leq 2f[i]$则$j_2$优于$j_1$。 假如我们有三个决策$j_1,j_2,j_3$（如下图） 容易证明：$j_2$不可能是最优的。这样一来，每两个决策间的斜率便是单调上升的。 所以有两种做法： 对于$dp[i]$，有了斜率单调上升这个条件，就可以去二分最优的决策点（也就是斜率小于$2f[i]$的）。复杂度$O(n \\log n)$。 又因为$f[i]$是单调递增的，可以用单调队列来维护。具体实现就是，把决策放进一个单调队列里，如果队首和当前的$i$间的斜率 $&lt;f[i]$，就把队首删掉（即h++）。对于队尾，就每次把加入$i$后不满足斜率单调上升的队尾全部删掉（即t—），最后把$i$放进单调队列就好了。 带权二分先挖个坑。","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://yoursite.com/categories/算法笔记/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"http://yoursite.com/tags/决策单调性/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://yoursite.com/tags/斜率优化/"},{"name":"带权二分","slug":"带权二分","permalink":"http://yoursite.com/tags/带权二分/"}]},{"title":"BZOJ4199 「NOI2015」品酒大会","slug":"BZOJ4199","date":"2019-05-03T08:26:54.000Z","updated":"2019-05-03T14:26:35.994Z","comments":true,"path":"2019/05/03/BZOJ4199/","link":"","permalink":"http://yoursite.com/2019/05/03/BZOJ4199/","excerpt":"Description给定字符串 $s$ ，和每个位置上的权值 $a_i$。对于每一个 $i \\in [0, n)$ 求出有多少对 $(i, j)$ 满足 $LCP(sa_i, sa_j) \\ge i$ 以及在这些 $(i, j)$ 中 $a_i \\times a_j$ 最大是多少。$sa_i$ 表示从 $i$ 开始的后缀。","text":"Description给定字符串 $s$ ，和每个位置上的权值 $a_i$。对于每一个 $i \\in [0, n)$ 求出有多少对 $(i, j)$ 满足 $LCP(sa_i, sa_j) \\ge i$ 以及在这些 $(i, j)$ 中 $a_i \\times a_j$ 最大是多少。$sa_i$ 表示从 $i$ 开始的后缀。 Solution将原串反过来建 SAM 求得后缀树。考虑后缀树上一个节点 $u$ ，这个节点代表的子串是他的任意后代的后缀 。所以每两个在其子树中的点都会对第一问的答案造成贡献。只需要维护 right 集合的大小即可。 对于第二问，乘积最大有两种可能：一个是最大的两个相乘，一个是最小的两个相乘（负负得正）。所以只需要在 dfs 的时候顺便维护子树中的最大值和最小值，与子树合并的时候维护处答案。 最后再从后往前更新一遍答案。因为小的肯定包含在大的中，对第一问做加法，第二问取 max 具体看代码 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * Author: AcFunction * Date: 2019-05-02 09:10:52 * Email: 3486942970@qq.com**/ #include &lt;bits/stdc++.h&gt;#define ll long long using namespace std; const int N = (int)1e6 + 10; const int INF = (int)1e9; int n, siz[N], o[N], w[N], mx[N], mn[N], dep[N]; char s[N];ll ans1[N], ans2[N]; struct sam &#123; int ch[26], len, fa; &#125; a[N]; struct edge &#123; int v; edge *next; &#125; pool[N * 2], *h[N], *cur = pool; void addedge(int u, int v) &#123; edge *p = cur++; p-&gt;v = v; p-&gt;next = h[u], h[u] = p; &#125; int last = 1, tot = 1; void add(int c, int x) &#123; int p = last, tp = ++tot; last = tp; w[tp] = o[x]; a[tp].len = a[p].len + 1; siz[tot] = 1; for(; p &amp;&amp; !a[p].ch[c]; p = a[p].fa) a[p].ch[c] = tp; if(!p) &#123; a[tp].fa = 1; &#125; else &#123; int q = a[p].ch[c]; if(a[q].len == a[p].len + 1) &#123; a[tp].fa = q; &#125; else &#123; int cl = ++tot; a[cl] = a[q]; a[cl].len = a[p].len + 1; a[q].fa = a[tp].fa = cl; for(; p &amp;&amp; a[p].ch[c] == q; p = a[p].fa) a[p].ch[c] = cl; &#125; &#125;&#125; void dfs(int u, int pre) &#123; if(siz[u] == 1) &#123; mx[u] = mn[u] = w[u]; &#125; for(edge *p = h[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(v == pre) continue ; dep[v] = dep[u] + 1; dfs(v, u); if(mx[u] != INF &amp;&amp; mn[u] != INF) ans2[a[u].len] = max(ans2[a[u].len], max(1ll * mx[u] * mx[v], 1ll * mn[u] * mn[v])); ans1[a[u].len] += 1ll * siz[u] * siz[v]; siz[u] += siz[v]; mx[u] = max(mx[u], mx[v]); mn[u] = min(mn[u], mn[v]); &#125;&#125; int main() &#123; scanf(\"%d\", &amp;n); scanf(\"%s\", s + 1); for(int i = 0; i &lt;= n; i++) ans1[i] = 0, ans2[i] = -(ll)9e18; for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;o[i]); for(int i = n; i &gt;= 1; i--) add(s[i] - 'a', i); for(int i = 1; i &lt;= tot; i++) mx[i] = -INF, mn[i] = INF; for(int i = 2; i &lt;= tot; i++) addedge(a[i].fa, i); dep[1] = 1, dfs(1, 0); for(int i = n - 1; i &gt;= 0; i--) ans1[i] += ans1[i + 1], ans2[i] = max(ans2[i], ans2[i + 1]); for(int i = 0; i &lt; n; i++) &#123; if(ans1[i] == 0) ans2[i] = 0; printf(\"%lld %lld\\n\", ans1[i], ans2[i]); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://yoursite.com/tags/后缀自动机/"}]},{"title":"Do geese see god?","slug":"Do-geese-see-god","date":"2019-04-30T12:32:40.000Z","updated":"2019-04-30T14:50:35.138Z","comments":true,"path":"2019/04/30/Do-geese-see-god/","link":"","permalink":"http://yoursite.com/2019/04/30/Do-geese-see-god/","excerpt":"Description给一个字符串 $s$ 和一个整数 $k$ 。求所有最短的满足 $s$ 是他的一个子序列并且是一个回文串的字符串中字典序第 $k$ 大的。","text":"Description给一个字符串 $s$ 和一个整数 $k$ 。求所有最短的满足 $s$ 是他的一个子序列并且是一个回文串的字符串中字典序第 $k$ 大的。 Solution令 $f[i][j]$ 表示 $s$ 中 $i$ 到 $j$ 所构成的字符串至少还要再添加几个字符使得其变成回文串。 令 $g[i][j]$ 表示满足最短的条件的前提下的添加字符的方案数。 这两个数组都可以通过简单的 $O(n^2)$ 的 dp 完成。 接下来便是求第 $k$ 大的字符串。如果 $k &gt; g[1][n]$ 直接输出无解。接下来处理有解的情况。 用 solve(l, r, k) 表示从 $s_l$ 到 $s_r$ 构成的字符串满足添加字符最少的前提下所构成的字典序第 $k$ 大的回文串。 $l=r$ 时，直接返回 $s_l$ $s_l = s_r$ 时，返回 s[l] + solve(l + 1, r - 1, k) + s[r] （这里加法 = 按顺序拼接 = string 加法） $s_l \\not= s_r$ 时，我们有两种方法 把字符串变成 s[l] + solve(l + 1, r) + s[l] 即在后面添加一个 $s_l$ 并且把中间变成回文 把字符串变成 s[r] + solve(l, r - 1) + s[r] 即在前面添加一个 $s_r$ 并且把中间变成回文 此时，我们显然会贪心的走字典序小的那一边，这取决于 $s_l$ 和 $s_r$ 的大小。 不妨设 $s_l &lt; s_r$ 那么如果 $g[l+1][r] &gt;= k$ 我们就直接往第一种情况递归。否则把 $k$ 减掉 $g[l+1][r]$ 放到第二种情况递归。对于 $s_l &gt; s_r$ 也是同理。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 2005; const int INF = (int)1e9; int n; ll k; char s[N]; int f[N][N]; ll g[N][N]; string solve(int l, int r, ll k) &#123; if(l &gt; r) return \"\"; if(l == r) &#123; string t = \"\"; t += s[l]; return t; &#125; if(s[l] == s[r]) return s[l] + solve(l + 1, r - 1, k) + s[r]; if(f[l + 1][r] &lt; f[l][r - 1]) return s[l] + solve(l + 1, r, k) + s[l]; if(f[l + 1][r] &gt; f[l][r - 1]) return s[r] + solve(l, r - 1, k) + s[r]; if(s[l] &lt; s[r]) &#123; if(g[l + 1][r] &gt;= k) return s[l] + solve(l + 1, r, k) + s[l]; else return s[r] + solve(l, r - 1, k - g[l + 1][r]) + s[r]; &#125; else &#123; if(g[l][r - 1] &gt;= k) return s[r] + solve(l, r - 1, k) + s[r]; else return s[l] + solve(l + 1, r, k - g[l][r - 1]) + s[l]; &#125;&#125;int main() &#123; scanf(\"%s %lld\", s + 1, &amp;k); n = strlen(s + 1); for(int i = 1; i &lt;= n; i++) f[i][i] = 0, g[i][i] = 1; for(int l = 2; l &lt;= n; l++) &#123; for(int i = 1; i &lt;= n - l + 1; i++) &#123; if(l == 2) &#123; if(s[i] == s[i + 1]) &#123; f[i][i + 1] = 0, g[i][i + 1] = 1; &#125; else &#123; f[i][i + 1] = 1; g[i][i + 1] = 2; &#125; continue ; &#125; int L = i, R = (i + l - 1); int mn = INF; if(s[L] == s[R]) &#123; f[L][R] = f[L + 1][R - 1]; g[L][R] = g[L + 1][R - 1]; continue ; &#125; mn = min(mn, 1 + min(f[L][R - 1], f[L + 1][R])); f[L][R] = mn; if(mn == f[L + 1][R] + 1) &#123; g[L][R] += g[L + 1][R]; &#125; if(mn == f[L][R - 1] + 1) &#123; g[L][R] += g[L][R - 1]; &#125; if(g[L][R] &gt; k) g[L][R] = k + 1; &#125; &#125; if(k &gt; g[1][n]) &#123; puts(\"NONE\"); return 0; &#125; cout &lt;&lt; solve(1, n, k) &lt;&lt; endl; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"CodeChef RIN","slug":"CodeChef-RIN","date":"2019-04-30T12:32:27.000Z","updated":"2019-05-03T08:29:43.545Z","comments":true,"path":"2019/04/30/CodeChef-RIN/","link":"","permalink":"http://yoursite.com/2019/04/30/CodeChef-RIN/","excerpt":"Description你有 $m$ 个学期来完成 $n$ 个课程，每个学期能上任意多课程，每个课程恰好被学一遍。有些课程有前置条件，必须先学 $a$ 课程才能学 $b$ 课程。在第 $i$ 个学期完成第 $j$ 这个课程能够获得 $A[i][j]$ 的分数（$A[i][j]=-1$ 说明 $i$ 学期不教授 $j$ 课程）。求最大的平均分数。","text":"Description你有 $m$ 个学期来完成 $n$ 个课程，每个学期能上任意多课程，每个课程恰好被学一遍。有些课程有前置条件，必须先学 $a$ 课程才能学 $b$ 课程。在第 $i$ 个学期完成第 $j$ 这个课程能够获得 $A[i][j]$ 的分数（$A[i][j]=-1$ 说明 $i$ 学期不教授 $j$ 课程）。求最大的平均分数。 Solution类似于切糕的建图方式，把每个课程拆成 $m + 1$ 个点。令第 $i$个课程拆出来的第 $j$ 个点事 $(i, j)$ 对于一个课程 $i$ ，有以下的建图方式： $(i, j) \\to (i,j+1)$ 连流量 $100 - A[i][j]$ 的边 $S \\to (i,1)$ 和 $(i,m+1) \\to T$ 都连一条流量为 INF 的边 如果已知两个课程 $a,b$ 必须使得 $a$ 是 $b$ 的前置课程，那么对于 $1 \\leq i \\leq m-1$ 连一条 $(a,i) \\to (b,i+1)$ 的流量为 INF 的边 然后跑出最大流，再用 $100 - \\frac{\\text{最大流}}{n}$ 为什么这是对的呢？首先，总分最大就是使得减分最小，所以把每个分数用最大值($\\leq 100$) 减一下跑出最小割然后用总和减掉。此时 $A[i][j]$ 就变成了 $i$ 课程在 $j$ 学期的扣分。 对于每一条学期，我们必须上一次课，在最小割中体现就是对这个学期建立一条链，割了第 $j$ 个点和第 $j+1$ 个点之间的边表示在 $j$ 这个学期上了这个课。每条链显然只会恰好割一次。 对于前置条件的限制，在最小割中的体现便是 $a$ 学期的割边在 $b$ 学期之前。那么按照第三种连边使得如果不在 $b$ 前面那么必然会有一条通路（画图理解）。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10010000; const int INF = (int)2e9; int n, m, k; int S, T, vis[N]; struct edge &#123; int v, f; edge *next, *rev; &#125; pool[N * 2], *h[N], *cu = pool, *cur[N]; void addedge(int u, int v, int f) &#123; edge *p = cu++, *q = cu++; p-&gt;v = v, p-&gt;next = h[u], h[u] = p, p-&gt;f = f, p-&gt;rev = q; q-&gt;v = u, q-&gt;next = h[v], h[v] = q, q-&gt;f = 0, q-&gt;rev = p; &#125;int dep[N], Q[N];bool bfs() &#123; for(int i = S; i &lt;= T; i++) cur[i] = h[i], dep[i] = 0; int s = 1, t = 0; dep[S] = 1, Q[++t] = S; while(s &lt;= t) &#123; int u = Q[s++]; for(edge *p = h[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(p-&gt;f &amp;&amp; !dep[v]) &#123; Q[++t] = v, dep[v] = dep[u] + 1; if(v == T) return 1; &#125; &#125; &#125; return 0; &#125;int dfs(int u, int lim) &#123; if(u == T || !lim) return lim; int ret = 0; for(edge *p = cur[u]; p; p = p-&gt;next) &#123; cur[u] = p; int v = p-&gt;v; if(p-&gt;f &amp;&amp; dep[v] == dep[u] + 1) &#123; int tmp = dfs(v, min(lim, p-&gt;f)); p-&gt;f -= tmp, p-&gt;rev-&gt;f += tmp; ret += tmp, lim -= tmp; &#125; &#125; if(!ret) dep[u] = -1; return ret; &#125;int dinic() &#123; int ret = 0; while(bfs()) ret += dfs(S, INF); return ret; &#125;int a[1005][1005]; int dx[8] = &#123;1, 1, 2, 2, -1, -1, -2, -2&#125;; int dy[8] = &#123;2, -2, 1, -1, 2, -2, 1, -1&#125;; int id(int x, int y) &#123; return (x - 1) * (m + 1) + y; &#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; S = 0; T = n * (m + 1) + 1; for(int i = 1; i &lt;= n; i++) &#123; addedge(S, id(i, 1), INF); for(int j = 1; j &lt;= m; j++) &#123; if(a[i][j] != -1) addedge(id(i, j), id(i, j + 1), 100 - a[i][j]); else addedge(id(i, j), id(i, j + 1), INF); &#125; addedge(id(i, m + 1), T, INF); &#125; for(int i = 1; i &lt;= k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; for(int j = 1; j &lt;= m; j++) addedge(id(x, j), id(y, j + 1), INF); &#125; printf(\"%.2lf\\n\", 1.0 * 100 - 1.0 * dinic() / (1.0 * n)); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"BZOJ4585 「APIO2016」烟火表演","slug":"BZOJ4585","date":"2019-04-05T09:37:11.000Z","updated":"2019-04-05T10:42:55.877Z","comments":true,"path":"2019/04/05/BZOJ4585/","link":"","permalink":"http://yoursite.com/2019/04/05/BZOJ4585/","excerpt":"Description给定一棵以 $1$ 为根的 $n$ 个节点的树，每条边有一个边权。有 $m$ 个叶子。将一条边的边权从 $x$ 修改至 $y$ 需要的代价是 $|x-y|$ 。求将所有叶子到根节点的距离修改成相同的最小代价。","text":"Description给定一棵以 $1$ 为根的 $n$ 个节点的树，每条边有一个边权。有 $m$ 个叶子。将一条边的边权从 $x$ 修改至 $y$ 需要的代价是 $|x-y|$ 。求将所有叶子到根节点的距离修改成相同的最小代价。 Solution神仙题。参考：https://blog.csdn.net/u014609452/article/details/52347062；洛谷题解第一篇。 定义 $f_x(y)$ 表示将以 $x$ 为根的子树中所有叶子结点到 $x$ 节点的距离都修改成 $y$ 所需要的代价。我们得到的结论是：$f_x$ 是个分段函数，每一段为一个一次函数，并且下凸（即一个凸壳）。 这个结论的证明要用到数学归纳法，不多赘述。 考虑维护这个凸壳。即现在已知每个儿子的凸壳，应该如何合并出这个节点的凸壳。 儿子节点的凸壳首先需要往其中加入父亲到他的这一条边。可以证明有了这一条边后依然是一个凸壳。 对每个儿子都这么做，得到的所有凸壳相加即为父亲节点的凸壳。 于是问题变为如何维护 ”往上增加一条边“ 后凸壳的变化。 设增加这条边的边权是 $w$ ，要增加的这个函数是 $f$ ，新的函数是 $g$ ，最小值在 $L$ 到 $R$ 取到。 对于 $x \\leq L$ ，此时要把新加的这条边减成 $0$ ，代价 $w$ 即 $g(x) = f(x) + w$ 对于 $L \\leq x \\leq L + w$ ，此时先将原来的子树里的每个叶子到根的距离修改成 $L$ ，加上 $w$ 后要再修改成 $x$ 需要 $L + w - x$ 的代价 （先把 $w$ 的边干掉然后用 $L - x$ 的代价从 $L$ 到 $x$ ）。即 $g(x) = f(x) + w + L -x$ 对于 $L + w \\leq x \\leq R + w$ ，此时 $g(x) = f(x - w)$ 。又因为 $x - w \\in [L, R]$ 都是最小值，所以 $g(x) = f(L)$ 对于 $R+w \\leq x$ ，此时先将原来的子树里的每个叶子到根的距离修改成 $R$ ，加上 $w$ 再修改成 $x$ 需要 $|R + w - x| = x - w - R$ （其实和 2 差不多只是正负的问题）。即 $g(x) = f(x) + x - w - R$ 容易看出，$g$ 的最小值在 $[L + w, R + w]$ 取到。 得到这些性质后，我已经自闭了… 我们可以分析它的几何意义。 第一段（$x \\leq L$） 相当于是往上做了一个平移。 第二段（$L \\leq x \\leq L + w$）你会发现，$g(x) = f(x) + w - L - x$ 中有一个 $-x$ 。这说明这一段的斜率是 $-1$ 第三段（$L + w \\leq x \\leq R + w$）这一段其实就是一段平的（这也是为啥它是新函数取到最小值的段），斜率维 $0$ 第四段（$R + w \\leq x$ ）你会发现，$g(x) = f(x) + x - w - R$ 有一个 $+x$ 。这说明这一段的斜率是 $1$ 这样我们就知道了新凸壳与原来的凸壳的区别：将 $L$ 左边一段向上平移，删除右边，新增两个拐点 $L+w, R+w$ 并且 $L$ 到 $L+w$ 的斜率为 $-1$ ，$L+w$ 到 $R + w$ 的斜率是 $0$，$R + w$ 往右的斜率是 $1$ 。 有了这个结论，然后的做法其实还不是很显然（至少对我来说）。 这个凸壳还有一个可以证明的性质：（从左到右）每当经过一个拐点，那么斜率会增加 $1$ 我们可以对每个点存放凸壳的拐点（的横坐标）。 每次将儿子节点的凸壳弹出后面的（从大到小）拐点，然后加入两个新拐点。然后将儿子节点的拐点合并到该节点的凸壳中。 这个过程中，需要支持：删除（横坐标）最大的拐点；合并。自然想到可并堆。 还剩下几个小问题： 实现时，如何弹出拐点直到最小值的那一段？最右边的那一段的斜率是儿子数量。（因为每合并一次右端斜率 ++） 所以弹出儿子数量个拐点即可。 最后的答案如何计算？或：最小值那一段该如何计算？ $f_1(0)$ 很好计算，为所有边权的和。我们又知道，每一个拐点使得斜率++。于是可以先把右边的点弹掉（儿子个），然后计算即可 还有一个很骚的操作，即一种快乐的可并堆： 1234567int merge(int x, int y) &#123; if(!x || !y) return x + y; if(vx[x] &lt; vx[y]) swap(x, y); int d = rand() % 2; ch[x][d] = merge(ch[x][d], y); return x; &#125; 懒人专用，复杂度很对（426ms）。会证明复杂度的可以私信我，我太菜了不会证… Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Author: AcFunction * Date: 2019-03-19 21:45:47 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long long#define db double#define PII pair &lt;int, int&gt; #define pb push_back #define Fi first#define Se second #define MP make_pair#define RG register #define rep(i, l, r) for(RG int i = l; i &lt;= r; i++) #define per(i, r, l) for(RG int i = r; i &gt;= l; i--)using namespace std;void INIT() &#123; ios :: sync_with_stdio(false); cin.tie(0); &#125;template &lt; typename T &gt; void sc(T&amp; t) &#123; char c = getchar(); T x = 1; t = 0; while(!isdigit(c)) &#123;if(c == '-') x = -1; c = getchar();&#125; while(isdigit(c)) t = t * 10 + c - '0' , c = getchar();t *= x;&#125;template &lt; typename T , typename... Args &gt; void sc(T&amp; t , Args&amp;... args) &#123;sc(t); sc(args...);&#125;const int N = 600300; int n, m, fa[N], son[N];ll w[N], ans, vx[N]; int cnt, ch[N][2], rt[N]; int New(ll x) &#123; vx[++cnt] = x; ch[cnt][0] = ch[cnt][1] = 0; return cnt; &#125;int merge(int x, int y) &#123; if(!x || !y) return x + y; if(vx[x] &lt; vx[y]) swap(x, y); int d = rand() % 2; ch[x][d] = merge(ch[x][d], y); return x; &#125;int main() &#123; // INIT(); srand((unsigned long long)new char); sc(n, m); for(int i = 2; i &lt;= n + m; i++) &#123; sc(fa[i], w[i]); ans += w[i]; son[fa[i]]++; &#125; for(int i = n + m; i &gt;= 2; i--) &#123; for(int j = 1; j &lt;= son[i] - 1; j++) rt[i] = merge(ch[rt[i]][0], ch[rt[i]][1]); ll R = vx[rt[i]]; rt[i] = merge(ch[rt[i]][0], ch[rt[i]][1]); ll L = vx[rt[i]]; rt[i] = merge(ch[rt[i]][0], ch[rt[i]][1]); rt[i] = merge(rt[i], merge(New(L + w[i]), New(R + w[i]))); rt[fa[i]] = merge(rt[fa[i]], rt[i]); &#125; for(int j = 1; j &lt;= son[1]; j++) rt[1] = merge(ch[rt[1]][0], ch[rt[1]][1]); while(rt[1]) &#123; ans -= vx[rt[1]]; rt[1] = merge(ch[rt[1]][0], ch[rt[1]][1]); &#125; printf(\"%lld\\n\", ans); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"可并堆","slug":"可并堆","permalink":"http://yoursite.com/tags/可并堆/"}]},{"title":"HDU6203 ping ping ping","slug":"HDU6203","date":"2019-04-05T09:13:23.000Z","updated":"2019-04-05T09:29:36.945Z","comments":true,"path":"2019/04/05/HDU6203/","link":"","permalink":"http://yoursite.com/2019/04/05/HDU6203/","excerpt":"Description给你一颗以 $0$ 为根的有根树。现在有些节点坏掉了，与周围无法联通。已知 $m$ 对 $(u,v)​$ 无法联通，求最少坏了几个节点。","text":"Description给你一颗以 $0$ 为根的有根树。现在有些节点坏掉了，与周围无法联通。已知 $m$ 对 $(u,v)​$ 无法联通，求最少坏了几个节点。 Solution对于一对无法联通的节点 $(u,v)$，一般是贪心地删掉 $u, v$ 的 LCA。但如果这条链在之前删除其他链的 LCA 时已经不联通了，那么就可以直接跳过。 所以得到一个做法：求出每对 $(u,v)$ 的 LCA ，按照深度从大到小排序。依次处理。如果当前的链上已经有点被删除了，直接跳过；否则 ans++，将 LCA 打个标记表示已被删除。可以用树链剖分维护。 考虑更简单的做法。因为已经将 LCA 的深度从大到小排过序了，所以每次删除 LCA 可以直接把 LCA 这个子树里的所有点打上标记（加上1）与只打 LCA 一个标记是等价的。这个过程直接用树状数组维护 dfs 序就可以了。 时间复杂度 $O(m \\log n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010; int n, m, tot, dep[N], fa[N][19], dfn[N], siz[N]; struct edge &#123; int v; edge *next; &#125; pool[N * 2], *head[N], *cur = pool;void addedge(int u, int v) &#123; edge *p = cur++, *q = cur++; p-&gt;v = v, p-&gt;next = head[u], head[u] = p; q-&gt;v = u, q-&gt;next = head[v], head[v] = q; &#125;void dfs(int u, int pre) &#123; siz[u] = 1; dfn[u] = ++tot; for(edge *p = head[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(v == pre) continue ; dep[v] = dep[u] + 1; fa[v][0] = u; dfs(v, u); siz[u] += siz[v]; &#125;&#125;struct node &#123; int u, v, lca; &#125;E[N];int LCA(int u, int v) &#123; if(dep[u] &lt; dep[v]) swap(u, v); for(int i = 16; i &gt;= 0; i--) if(dep[fa[u][i]] &gt;= dep[v]) u = fa[u][i]; if(u == v) return u; for(int i = 16; i &gt;= 0; i--) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; return fa[u][0]; &#125;bool cmp(node x, node y) &#123; return dep[x.lca] &gt; dep[y.lca]; &#125;int c[N]; int lb(int x) &#123; return x &amp; (-x); &#125;void add(int x, int d) &#123; for(int i = x; i &lt;= n + 1; i += lb(i)) c[i] += d; &#125;int sum(int x) &#123; int ret = 0; for(int i = x; i; i -= lb(i)) ret += c[i]; return ret; &#125;void A(int l, int r) &#123; add(l, 1), add(r + 1, -1); &#125;int main() &#123; while(scanf(\"%d\", &amp;n) != EOF) &#123; n++; memset(dep, 0, sizeof(dep)); memset(fa, 0, sizeof(fa)); memset(dfn, 0, sizeof(dfn)); memset(c, 0, sizeof(c)); tot = 0; for(int i = 1; i &lt;= n; i++) head[i] = NULL; cur = pool; for(int i = 1; i &lt; n; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); u++, v++; addedge(u, v); &#125; scanf(\"%d\", &amp;m); dfs(1, 0); for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for(int i = 1; i &lt;= n; i++) fa[i][j] = fa[fa[i][j - 1]][j - 1]; for(int i = 1; i &lt;= m; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); u++, v++; E[i].u = u, E[i].v = v, E[i].lca = LCA(u, v); &#125; sort(E + 1, E + m + 1, cmp); int ans = 0; for(int i = 1; i &lt;= m; i++) &#123; int u = E[i].u, v = E[i].v, lca = E[i].lca; if(!sum(dfn[u]) &amp;&amp; !sum(dfn[v])) ans++, A(dfn[lca], dfn[lca] + siz[lca] - 1); &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"}]},{"title":"BJOI2019 游记","slug":"BJOI2019-游记","date":"2019-03-31T07:10:29.000Z","updated":"2019-05-28T13:27:54.259Z","comments":true,"path":"2019/03/31/BJOI2019-游记/","link":"","permalink":"http://yoursite.com/2019/03/31/BJOI2019-游记/","excerpt":"提前占坑。记录第一次省（bao）选（ling）","text":"提前占坑。记录第一次省（bao）选（ling） Day -n颓废 Day -m模拟赛（集训）爆零（严肃） AK大佬点这里 Day 0复习期中 打了些板子 准备迎接退役（雾 Day 1密码输错了几次..开题 T1 什么鬼…字符串匹配？…几何平均值？？ T2 emm感觉很可做 T3 什么鬼…看了下标题和题面长度，然后就几乎没看过…现在都不知道题意是啥（事实证明这决策非常对 T1 想了一会感觉这个15分很好拿，先放着，20min写得完。感觉下面可以搞个dp但是输出方案不好弄写起来性价比有点低放了去看 T2 T2 显然这个 2*n 就是求区间 C_{斐波数列}^{k} 的和。把组合数拆一下发现可以直接预处理出几次方的系数。然后问题转化成前缀和减一下。貌似能直接矩阵快速幂，写起来不算特别麻烦。算了下复杂度勉强能过 k &lt;= 50 突然发现 l, r 比较小的可以直接跑如果 k 太大反而不能用矩阵快速幂。于是就写写写。写了2个小时(3个小时?我还是太弱了码力不够)过了第一个样例（中间差点心态崩了）。最后写了一坨奇怪的代码 3*n 有点卡住，时间只剩 2h 了吧（记不清了）。然后回去写了一发 T2 的暴力。然后还剩 1.5h-。回去想 T2。手花了几种方格图发现是由这个 3 乘 奇数多一块 或者 3 乘偶数少一块递推而来的。设了个方程解出来是 4乘前面一项减去前面两项的数。也是一个二阶线性递推。还剩 1h+ 赶紧把前面的代码复制粘贴魔改了一番系数然后调了半天还剩 20min 的时候调出来了。过了两个样例心情舒坦。最后还发现 T3 有个无解输出个 -1 。检查了一番文件名就结束了。 中午（看大佬）颓废。等分真是漫长。 出分了。 15 + 65 + 0 丢了 5 分还行。rk16(17?)?!出人意料… 讲题，T1貌似听上去很套路？取个 log 变成平均数，然后二分，然后 AC自动机上dp？反正肯定是不会的。 T2正解要用什么奇怪的扩展整数域，听得很懵。。 T3全程掉线，我题意都不知道是啥（我还是太菜了 晚上还是要复习万恶的期中（（（ Day2 爆零预备","categories":[{"name":"游记","slug":"游记","permalink":"http://yoursite.com/categories/游记/"}],"tags":[{"name":"省选游记","slug":"省选游记","permalink":"http://yoursite.com/tags/省选游记/"},{"name":"爆零","slug":"爆零","permalink":"http://yoursite.com/tags/爆零/"}]},{"title":"BZOJ3143 「HNOI2013」游走","slug":"BZOJ3143","date":"2019-03-22T09:04:09.000Z","updated":"2019-03-22T11:24:56.217Z","comments":true,"path":"2019/03/22/BZOJ3143/","link":"","permalink":"http://yoursite.com/2019/03/22/BZOJ3143/","excerpt":"Description$n$ 个点 $m$ 条边的无向连通图，在上面从 $1$ 号点开始随机游走。现在你可以给每条边从 $1$ 到 $m$ 编号作为分数（经过就得分）。求如何编号使得总分的期望最小。输出这个最小值即可。 $n \\leq 500$","text":"Description$n$ 个点 $m$ 条边的无向连通图，在上面从 $1$ 号点开始随机游走。现在你可以给每条边从 $1$ 到 $m$ 编号作为分数（经过就得分）。求如何编号使得总分的期望最小。输出这个最小值即可。 $n \\leq 500$ Solution如果知道了每条边被经过的期望次数，那么根据排序不等式显然是逆序分配最小。 设 $f_u$ 是 $u$ 点被经过的期望次数，$deg_u$ 表示 $u$ 的度数。那么边 $(u, v)$ 被经过的期望次数是 \\frac{f_u}{deg_u}+\\frac{f_v}{deg_v}$f$ 的求法比较简单，即 f_u = \\sum\\limits_{(u,v) \\in E} \\frac{f_v}{deg_v}高斯消元一波再排个序就做完了。时间复杂度 $O(n^3)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * Author: AcFunction * Date: 2019-03-18 22:13:03 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long long#define db double#define PII pair &lt;int, int&gt; #define pb push_back #define Fi first#define Se second #define MP make_pair#define RG register #define rep(i, l, r) for(RG int i = l; i &lt;= r; i++) #define per(i, r, l) for(RG int i = r; i &gt;= l; i--)using namespace std;void INIT() &#123; ios :: sync_with_stdio(false); cin.tie(0); &#125;const int N = 505; int n, m, deg[N]; PII E[N * N]; db a[N][N], t[N]; db A[N * N], ans; vector &lt;int&gt; g[N]; void build(int n) &#123; rep(u, 1, n) &#123; a[u][u] = 1.0; for(auto v : g[u]) if(v != n) a[u][v] -= 1.0 / deg[v]; &#125; a[1][n + 1] = 1.0; a[n][n + 1] = -1.0; &#125;void gauss(int n) &#123; rep(i, 1, n) &#123; int p = i; rep(j, i + 1, n) if(fabs(a[j][i]) &gt; fabs(a[p][i] + 1e-13)) p = j; rep(j, i + 1, n) &#123; if(fabs(a[j][i]) &lt; 1e-13) continue ; db cof = a[j][i] / a[i][i]; rep(k, i, n + 1) a[j][k] -= a[i][k] * cof; &#125; &#125; per(i, n, 1) &#123; rep(j, i + 1, n) a[i][n + 1] -= a[i][j] * t[j]; t[i] = a[i][n + 1] / a[i][i]; &#125;&#125;int main() &#123; INIT(); cin &gt;&gt; n &gt;&gt; m; rep(i, 1, m) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; E[i] = MP(u, v); deg[u]++, deg[v]++; g[u].pb(v), g[v].pb(u); &#125; build(n), gauss(n); rep(i, 1, m) A[i] = 1.0 * t[E[i].Fi] / deg[E[i].Fi] + 1.0 * t[E[i].Se] / deg[E[i].Se]; sort(A + 1, A + m + 1); rep(i, 1, m) ans += A[i] * (m - i + 1); printf(\"%.3lf\\n\", ans); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"概率期望","slug":"概率期望","permalink":"http://yoursite.com/tags/概率期望/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://yoursite.com/tags/高斯消元/"}]},{"title":"BZOJ4008 「HNOI2015」亚瑟王","slug":"BZOJ4008","date":"2019-03-22T09:03:59.000Z","updated":"2019-03-22T11:52:32.141Z","comments":true,"path":"2019/03/22/BZOJ4008/","link":"","permalink":"http://yoursite.com/2019/03/22/BZOJ4008/","excerpt":"Description有 $n$ 张卡牌，$r$ 局游戏，每张卡牌有 $p_i$ 的概率发动技能，如果发动会造成 $d_i​$ 的伤害。每局游戏从第一张卡牌开始开始一个个遍历，如果发动过技能则忽略继续；否则如果这张卡牌现在发动了，则结束回合；没有发动则继续。求造成的总伤害的期望。","text":"Description有 $n$ 张卡牌，$r$ 局游戏，每张卡牌有 $p_i$ 的概率发动技能，如果发动会造成 $d_i​$ 的伤害。每局游戏从第一张卡牌开始开始一个个遍历，如果发动过技能则忽略继续；否则如果这张卡牌现在发动了，则结束回合；没有发动则继续。求造成的总伤害的期望。 Solution可以想象成把 $r$ 个机会分配给每一张卡牌。$dp[i][j]$ 表示前 $i$ 张还剩 $j$ 个机会的答案 dp[i][j] = dp[i-1][j] \\cdot (1-p[i])^j+dp[i-1][j+1]\\cdot (1-(1-p[i])^{j+1})前半部分可以理解成在 $j$ 轮没有一次触发，后半部分就是至少一次触发。并且后半部分因为出触发了所以对答案有贡献，所以在 dp 的时候顺便把 ans 加上后半部分 * $d_i$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Author: AcFunction * Date: 2019-03-17 15:45:54 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long long#define db double#define PII pair &lt;int, int&gt; #define pb push_back #define Fi first#define Se second #define MP make_pair#define RG register #define rep(i, l, r) for(RG int i = l; i &lt;= r; i++) #define per(i, r, l) for(RG int i = r; i &gt;= l; i--)using namespace std;void INIT() &#123; ios :: sync_with_stdio(false); cin.tie(0); &#125;const int N = 250; int T, n, r, d[N]; db f[N][N], p[N]; db fpw(db x, int k) &#123; db ret = 1.0; while(k) &#123; if(k &amp; 1) ret = ret * x; x = x * x; k &gt;&gt;= 1; &#125; return ret; &#125;int main() &#123; INIT(); cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n &gt;&gt; r; memset(f, 0, sizeof(f)); rep(i, 1, n) cin &gt;&gt; p[i] &gt;&gt; d[i]; f[0][r] = 1; db ans = 0; rep(i, 1, n) per(j, r, 0) f[i][j] = f[i - 1][j] * fpw(1 - p[i], j) + f[i - 1][j + 1] * (1 - fpw(1 - p[i], j + 1)), ans += d[i] * f[i - 1][j + 1] * (1 - fpw(1 - p[i], j + 1)); printf(\"%.6lf\\n\", ans); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"概率期望","slug":"概率期望","permalink":"http://yoursite.com/tags/概率期望/"}]},{"title":"BZOJ2134 单选错位","slug":"BZOJ2134","date":"2019-03-22T09:03:51.000Z","updated":"2019-03-22T09:14:05.103Z","comments":true,"path":"2019/03/22/BZOJ2134/","link":"","permalink":"http://yoursite.com/2019/03/22/BZOJ2134/","excerpt":"Description$n$ 道题，第 $i$ 道题有 $a_i$ 个选项。求将正确答案全部右移一位（第 $n$ 题移到第 $1$ 题）之后期望对的题数","text":"Description$n$ 道题，第 $i$ 道题有 $a_i$ 个选项。求将正确答案全部右移一位（第 $n$ 题移到第 $1$ 题）之后期望对的题数 Solution答案 = 期望多少个 $i$ 满足 $ans_i = ans_{i+1}$ 也 = sum $ans_i = ans_{i+1}$ 的期望也就是 $\\sum \\frac{\\min\\{a_i, a_{i+1}\\}}{a_ia_{i+1}}=\\sum\\frac{1}{\\max\\{a_i,a_{i+1}\\}}$ （为了方便设 $a_{n+1}=a_1$） 做完了 Code1234567891011121314151617181920212223/** * Author: AcFunction * Date: 2019-03-20 14:41:06 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;using namespace std;int n, A, B, C, a[10000002]; double ans; int main() &#123; scanf(\"%d%d%d%d%d\",&amp;n,&amp;A,&amp;B,&amp;C,a+1); for (int i = 2; i &lt;= n; i++) a[i] = ((long long)a[i - 1] * A + B) % 100000001; for (int i = 1; i &lt;= n; i++) a[i] = a[i] % C + 1; a[n + 1] = a[1]; for(int i = 1; i &lt;= n; i++) ans += 1.0 / max(a[i], a[i + 1]); printf(\"%.3lf\\n\", ans); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"概率期望","slug":"概率期望","permalink":"http://yoursite.com/tags/概率期望/"}]},{"title":"BZOJ4665 小w的喜糖","slug":"BZOJ4665","date":"2019-03-17T13:57:09.000Z","updated":"2019-03-17T14:59:28.533Z","comments":true,"path":"2019/03/17/BZOJ4665/","link":"","permalink":"http://yoursite.com/2019/03/17/BZOJ4665/","excerpt":"Description$n$ 颗糖发给了 $n$ 个人，每颗糖有一个种类。$n$ 个人相互交换手中的糖那么有多少种方案使得每个人手中的糖的种类都与原来不同。 两个方案不同当且仅当，存在一个人，他手中的糖的种类在两个方案中不一样。 答案对 $10^9 + 9$ 取模","text":"Description$n$ 颗糖发给了 $n$ 个人，每颗糖有一个种类。$n$ 个人相互交换手中的糖那么有多少种方案使得每个人手中的糖的种类都与原来不同。 两个方案不同当且仅当，存在一个人，他手中的糖的种类在两个方案中不一样。 答案对 $10^9 + 9$ 取模 答案对 $10^9 + 9$ 取模！！！！！ $10^9 + 9$ ！！！！ $10^9 + 9$ ！！！！！ $10^9 + 9$ ！！！！！ Solution可以暂时不考虑相同种类糖之间的关系，把它们当成不同的最后把答案乘上 $\\frac{1}{\\Pi_{i} a_i!}$ . $a_i$ 表示种类 $i$ 的糖数 设 $dp[i][j]$ 表示前 $i$ 种糖至少有 $j$ 个人不合法（即手中拿的糖和原来一样。那么有 dp[i][j] = \\sum\\limits_{k=0}^{\\min(a_i,j)} \\binom{a_i}{k} \\cdot dp[i-1][j-k] \\cdot a_i(a_i-1)\\cdots(a_i - k + 1)然后对于答案就可以直接容斥得到 ans = \\sum\\limits_{i=0}^{n} (-1)^{i}dp[n][i]\\cdot(n-i)!Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Author: AcFunction * Date: 2019-03-04 21:07:09 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long long#define RG register #define rep(i, l, r) for(RG int i = l; i &lt;= r; i++) #define per(i, r, l) for(RG int i = r; i &gt;= l; i--)using namespace std;void INIT() &#123; ios :: sync_with_stdio(false); cin.tie(0); &#125;const int N = 2005; const ll mod = (ll)1e9 + 9; ll fpw(ll x, ll k, ll p) &#123; ll ret = 1; while(k) &#123; if(k &amp; 1) ret = ret * x % p; x = x * x % p; k &gt;&gt;= 1; &#125; return ret; &#125;int n, a[N]; ll dp[N][N], inv[N], invf[N], fac[N]; void prework() &#123; inv[1] = fac[0] = fac[1] = invf[0] = invf[1] = 1; rep(i, 2, n) inv[i] = (mod - mod / i) * inv[mod % i] % mod, fac[i] = fac[i - 1] * i % mod, invf[i] = invf[i - 1] * inv[i] % mod; &#125;ll C(int n, int m) &#123; if(n &lt; m) return 0; return fac[n] * invf[m] % mod * invf[n - m] % mod; &#125;int main() &#123; INIT(); cin &gt;&gt; n; prework(); rep(i, 1, n) &#123; int t; cin &gt;&gt; t; a[t]++; &#125; ll ans = 0; dp[0][0] = 1; rep(i, 1, n) rep(j, 0, n) rep(k, 0, min(a[i], j)) dp[i][j] += 1ll * dp[i - 1][j - k] * C(a[i], k) % mod * fac[a[i]] % mod * invf[a[i] - k] % mod, dp[i][j] %= mod; // rep(i, 0, n) cout &lt;&lt; dp[n][i] &lt;&lt; \" \"; rep(i, 0, n) ans += 1ll * ((i &amp; 1) ? -1 : 1) * dp[n][i] % mod * fac[n - i] % mod, ans %= mod, ans += mod, ans %= mod; rep(i, 1, n) ans *= invf[a[i]], ans %= mod; cout &lt;&lt; ((ans % mod + mod) % mod); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://yoursite.com/tags/容斥/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"BZOJ4361 isn","slug":"BZOJ4361","date":"2019-03-17T13:57:00.000Z","updated":"2019-03-17T14:46:10.107Z","comments":true,"path":"2019/03/17/BZOJ4361/","link":"","permalink":"http://yoursite.com/2019/03/17/BZOJ4361/","excerpt":"Description给出一个长度为 $n$ 的序列 $A(A_1,A_2 \\cdot A_n)$。如果序列 $A$ 不是非降的，你必须从中删去一个数这一操作，直到 $A$ 非降为止。求有多少种不同的操作方案，答案模 $10^9+7$ 。","text":"Description给出一个长度为 $n$ 的序列 $A(A_1,A_2 \\cdot A_n)$。如果序列 $A$ 不是非降的，你必须从中删去一个数这一操作，直到 $A$ 非降为止。求有多少种不同的操作方案，答案模 $10^9+7$ 。 Solution设 $dp[i][j]$ 表示以 $i$ 这个点结尾，长度恰好为 $j$ 的非降子序列的个数 求法要用树状数组维护（还要离散化） 考虑怎么求出答案 令 $g[i]$ 为有多少个长度为 $i$ 的非降子序列即 g[i] = \\sum\\limits_{j=1}^{n} dp[j][i]那么有：将原序列删除到长度为 $i$ 的子序列的方案数是 g[i] \\cdot (n-i)!乍看很对，仔细一想其实这不是对的：因为并没有考虑在 (i+1) 的时候已经达到状态就不会再继续进行操作 如果当前不合法那么这个序列只有可能是从 $i+1$ 的状态选择了一个数删掉得到的。所以有 ans = \\sum\\limits_{i = 1} ^ {n} g[i] \\cdot (n - i)! - (i + 1) \\cdot g[i + 1] \\cdot (n - i - 1)!时间复杂度：$O(n^2 \\log n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Author: AcFunction * Date: 2019-03-04 19:04:32 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define int long long#define ll long long#define RG register #define rep(i, l, r) for(RG int i = l; i &lt;= r; i++) #define per(i, r, l) for(RG int i = r; i &gt;= l; i--)using namespace std;void INIT() &#123; ios :: sync_with_stdio(false); cin.tie(0); &#125;const int N = 2005; const ll mod = (ll)1e9 + 7; int n, a[N], f[N][N];ll fac[N], g[N]; int lb(int x) &#123; return x &amp; (-x); &#125;struct BIT &#123; int c[N]; void add(int x, int d) &#123; for(int i = x; i &lt;= N; i += lb(i)) c[i] += d, c[i] %= mod; &#125; int sum(int x) &#123; int ret = 0; for(int i = x; i; i -= lb(i)) ret += c[i], ret %= mod; return ret; &#125;&#125; b[N]; int aa[N]; map &lt;int, int&gt; mp; int cnt; signed main() &#123; INIT(); cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; aa[i], a[i] = aa[i]; sort(aa + 1, aa + n + 1); rep(i, 1, n) &#123; if(!mp[aa[i]]) mp[aa[i]] = ++cnt; &#125; rep(i, 1, n) a[i] = mp[a[i]]; rep(i, 1, n) f[i][1] = 1; rep(j, 2, n) &#123; rep(i, 1, n) &#123; f[i][j] = b[j - 1].sum(a[i]); b[j - 1].add(a[i], f[i][j - 1]); &#125; &#125; fac[0] = fac[1] = 1; ll ans = 0; rep(i, 2, n) fac[i] = fac[i - 1] * i % mod; rep(i, 1, n) rep(j, 1, n) g[i] += f[j][i], g[i] %= mod; rep(i, 1, n) &#123; ans += ((g[i] * fac[n - i] % mod) - ((i + 1) * g[i + 1] % mod * fac[n - i - 1]) % mod) % mod; ans %= mod; &#125; cout &lt;&lt; (ans + mod) % mod &lt;&lt; endl; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://yoursite.com/tags/容斥/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"}]},{"title":"BZOJ2839 集合计数","slug":"BZOJ2839","date":"2019-03-17T13:56:52.000Z","updated":"2019-03-17T14:32:14.547Z","comments":true,"path":"2019/03/17/BZOJ2839/","link":"","permalink":"http://yoursite.com/2019/03/17/BZOJ2839/","excerpt":"Description从大小为 $n$ 的集合中取出若干子集（至少一个），使得它们的交集的元素个数为 $K$ ，求取法的方案数，答案模$1000000007$","text":"Description从大小为 $n$ 的集合中取出若干子集（至少一个），使得它们的交集的元素个数为 $K$ ，求取法的方案数，答案模$1000000007$ Solution$ans$ = 先选出这 $k$ 个元素是哪些 * 让剩下的交集为空 让剩下的交集为空 =(容斥) 随便选 - 交集至少一个元素 + 交集至少两个元素 … 交集至少为 $i$ 的方案数是 $\\binom{n-k}{i} \\cdot (2^{2^{n-k-i}}-1)$ (从剩下的 $n - k$ 里选 $i$ 个 * (有这些元素的子集随便选 - 啥都不选的一组) ans = \\binom{n}{k}\\sum\\limits_{i=0}^{n-k}(-1)^i \\binom{n-k}{i}\\cdot (2^{2^{n-k-i}}-1)Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Author: AcFunction * Date: 2019-03-04 17:33:39 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long long#define RG register #define rep(i, l, r) for(RG int i = l; i &lt;= r; i++) #define per(i, r, l) for(RG int i = r; i &gt;= l; i--)using namespace std;void INIT() &#123; ios :: sync_with_stdio(false); cin.tie(0); &#125;const int N = 1000005;const ll mod = (ll)1e9 + 7; ll fac[N], ans; ll fpw(ll x, ll k, ll p) &#123; ll ret = 1ll; while(k) &#123; if(k &amp; 1) ret = ret * x % p; x = x * x % p; k &gt;&gt;= 1; &#125; return ret; &#125;void prework(int n) &#123; fac[0] = fac[1] = 1; rep(i, 2, n) fac[i] = fac[i - 1] * i % mod; &#125;ll C(int n, int m) &#123; if(m &gt; n) return 0; else return fac[n] * fpw(fac[n - m], mod - 2, mod) % mod * fpw(fac[m], mod - 2, mod) % mod; &#125;int main() &#123; INIT(); int n, k; cin &gt;&gt; n &gt;&gt; k; prework(n); ll pw1 = ((n - k) &amp; 1) ? -1 : 1, pw2 = 2; per(i, n - k, 0) &#123; ans += pw1 * (pw2 - 1) % mod * C(n - k, i) % mod; ans %= mod; pw1 *= -1; pw2 *= pw2; pw2 %= mod; &#125; ans = ans * C(n, k) % mod; ans = (ans + mod) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://yoursite.com/tags/容斥/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"BZOJ1042 「HNOI2008」硬币购物","slug":"BZOJ1042","date":"2019-03-09T08:21:03.000Z","updated":"2019-03-17T14:29:55.225Z","comments":true,"path":"2019/03/09/BZOJ1042/","link":"","permalink":"http://yoursite.com/2019/03/09/BZOJ1042/","excerpt":"Description一共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$ 。某人去商店买东西，去了 $tot$ 次。每次带 $d_i$ 枚 $c_i$ 硬币，买 $s$ 的价值的东西。请问每次有多少种付款方法。","text":"Description一共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$ 。某人去商店买东西，去了 $tot$ 次。每次带 $d_i$ 枚 $c_i$ 硬币，买 $s$ 的价值的东西。请问每次有多少种付款方法。 Solution考虑没有 $d$ 的限制，直接完全背包。$dp_i$ 表示 $i$ 这个面值用 $c_1…c_4$ 凑有多少种方法 加上限制就容斥枚举 $16$ 种情况表示哪几种面值的性质没有被满足。 然后可以观察到，如果对于 $i$ 不满足限制，方案数就是 $dp_{s-(d_i+1)c_i}$ 所以归纳一下就是 ans = \\sum\\limits_{S \\subseteq {1,2,3,4}}(-1)^{|S|}dp_{(s-\\sum\\limits_{x \\in S} (d_x+1)c_x)}Code1234567891011121314151617181920212223242526272829303132333435363738394041/** * Author: AcFunction * Date: 2019-03-04 17:57:01 * Email: 3486942970@qq.com**/ #include &lt;bits/stdc++.h&gt;#define int long long#define ll long long#define RG register #define rep(i, l, r) for(RG int i = l; i &lt;= r; i++) #define per(i, r, l) for(RG int i = r; i &gt;= l; i--) using namespace std; void INIT() &#123; ios :: sync_with_stdio(false); cin.tie(0); &#125; const int N = 100100; int n, c[5], d[5]; int dp[N]; signed main() &#123; INIT(); dp[0] = 1; rep(i, 1, 4) cin &gt;&gt; c[i]; cin &gt;&gt; n; rep(j, 1, 4) rep(i, 0, 100000) if(i + c[j] &lt;= 100000) dp[i + c[j]] += dp[i]; rep(i, 1, n) &#123; int s; int ans = 0; rep(j, 1, 4) cin &gt;&gt; d[j]; cin &gt;&gt; s; rep(j, 0, 15) &#123; int s1 = 0, s2 = s; rep(t, 1, 4) if(j &amp; (1 &lt;&lt; (t - 1))) &#123; s1++; s2 -= (d[t] + 1) * c[t]; &#125; ans += ((s1 &amp; 1) ? -1 : 1) * (s2 &gt;= 0 ? dp[s2] : 0); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://yoursite.com/tags/容斥/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"类欧几里得算法学习笔记","slug":"类欧几里得算法学习笔记","date":"2019-03-03T06:32:49.000Z","updated":"2019-03-03T07:40:28.370Z","comments":true,"path":"2019/03/03/类欧几里得算法学习笔记/","link":"","permalink":"http://yoursite.com/2019/03/03/类欧几里得算法学习笔记/","excerpt":"类欧几里得算法用来求诸如此类问题： f(a,b,c,n)=\\sum\\limits_{i=0}^{n} \\lfloor\\frac{ai + b}{c}\\rfloor","text":"类欧几里得算法用来求诸如此类问题： f(a,b,c,n)=\\sum\\limits_{i=0}^{n} \\lfloor\\frac{ai + b}{c}\\rfloor 分类讨论 第一种情况：$a=0​$ 。那么 f(a,b,c,n)= \\sum\\limits_{i=0}^{n} \\lfloor \\frac{b}{c} \\rfloor=(n+1)\\lfloor \\frac{b}{c} \\rfloor第二种情况：$a,b$ 中有一个大于等于 $c$ 。那么 \\begin{aligned} f(a,b,c,n) &= \\sum\\limits_{i=0}^{n} \\lfloor\\frac{ai + b}{c}\\rfloor \\\\\\ &= \\sum\\limits_{i = 0}^{n}(\\lfloor\\frac{a\\bmod c\\cdot i + b \\bmod c}{c}\\rfloor+i\\lfloor\\frac{a}{c} \\rfloor+\\lfloor \\frac{b}{c} \\rfloor) \\\\\\ &= \\sum\\limits_{i = 0}^{n}\\lfloor\\frac{a\\bmod c\\cdot i + b \\bmod c}{c}\\rfloor +\\frac{n(n+1)}{2} \\cdot \\lfloor\\frac{a}{c} \\rfloor + (n+1)\\lfloor \\frac{b}{c} \\rfloor \\\\\\ &= f(a\\bmod c, b \\bmod c , c, n) + \\frac{n(n+1)}{2} \\cdot \\lfloor\\frac{a}{c} \\rfloor + (n+1)\\lfloor \\frac{b}{c} \\rfloor \\end{aligned}第三种情况：$a&lt;c$ 且 $b &lt; c$ 。那么 \\begin{aligned} f(a,b,c,n) &= \\sum\\limits_{i=0}^{n} \\lfloor\\frac{ai + b}{c}\\rfloor \\\\\\ &= \\sum\\limits_{i=0}^{n} \\sum\\limits_{j=0}^{\\lfloor\\frac{an + b}{c}\\rfloor-1} [j+1 \\leq \\lfloor\\frac{ai + b}{c}\\rfloor] \\\\\\ &= \\sum\\limits_{j=0}^{\\lfloor\\frac{an + b}{c}\\rfloor-1}\\sum\\limits_{i=0}^{n} [c(j+1) \\frac{cj+c-b-1}{a}] \\\\\\ &= \\sum\\limits_{j=0}^{\\lfloor\\frac{an + b}{c}\\rfloor-1}(n - \\lfloor \\frac{cj+c-b-1}{a} \\rfloor) \\\\\\ &= n \\cdot \\lfloor\\frac{an + b}{c}\\rfloor - \\sum\\limits_{j=0}^{\\lfloor\\frac{an + b}{c}\\rfloor-1}\\lfloor \\frac{cj+c-b-1}{a} \\rfloor \\\\\\ &= n \\cdot \\lfloor\\frac{an + b}{c}\\rfloor - f(c, c - b - 1, a, \\lfloor\\frac{an + b}{c}\\rfloor-1) \\end{aligned}递归计算即可 复杂度一个 $\\log$","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://yoursite.com/categories/算法笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"},{"name":"类欧几里得算法","slug":"类欧几里得算法","permalink":"http://yoursite.com/tags/类欧几里得算法/"}]},{"title":"杜教筛学习笔记","slug":"杜教筛学习笔记","date":"2019-03-01T11:13:21.000Z","updated":"2019-03-01T11:42:31.618Z","comments":true,"path":"2019/03/01/杜教筛学习笔记/","link":"","permalink":"http://yoursite.com/2019/03/01/杜教筛学习笔记/","excerpt":"","text":"设现在要求积性函数 $f$ 的前缀和， 设 $\\sum \\limits_{i=1}^{n} f(i) = S(n)$。 再找一个积性函数 $g$ ，则考虑它们的狄利克雷卷积的前缀和 \\begin{aligned} \\sum\\limits_{i=1}^{n}(f*g)(i) &= \\sum\\limits_{i=1}^{n} \\sum \\limits _{d|i} f(d)g(\\frac{i}{d}) \\\\\\ &= \\sum \\limits _{d=1}^{n} g(d)\\sum\\limits _{i=1}^{\\lfloor \\frac{n}{d}\\rfloor } f(i) \\\\\\ &= \\sum \\limits _{d=1}^{n} g(d) S(\\lfloor \\frac{n}{d} \\rfloor) \\end{aligned}其中得到第一行是根据狄利克雷卷积的定义。 得到第二行则是先枚举 $d$ 提出 $g$ 。 得到第三行则是把 $\\sum\\limits _{i=1}^{\\lfloor \\frac{n}{d}\\rfloor } f(i) $ 替换为 $S(\\lfloor \\frac{n}{d} \\rfloor) $ 接着考虑 $g(1)S(n)$ 等于什么。 可以发现，他就等于 \\sum \\limits _{i=1}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor) - \\sum \\limits _{i=2}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor)（可以理解成从1开始的前缀和减去从2开始的前缀和就是第一项） 前面这个式子 $\\sum \\limits _{i=1}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor)$ 根据刚才的推导，他就等于 $\\sum\\limits_{i=1}^{n}(f*g)(i)$ 所以得到杜教筛的核心式子： g(1)S(n)=\\sum\\limits_{i=1}^{n}(f*g)(i) - \\sum \\limits _{i=2}^{n} g(i) S(\\lfloor \\frac{n}{i} \\rfloor)得到这个式子之后有什么用呢？ 现在如果可以找到一个合适的积性函数 $g$ ，使得可以快速算出 $\\sum\\limits_{i=1}^{n}(f*g)(i)$ 和 $g$ 的前缀和，便可以用数论分块递归地求解。 代码按照理解大概可以写成这样（默认 ll 为 long long）（可以理解成一个伪代码。。就是一个思路的框架）12345678910ll GetSum(int n) &#123; // 算 f 前缀和的函数 ll ans = f_g_sum(n); // 算 f * g 的前缀和 // 以下这个 for 循环是数论分块 for(ll l = 2, r; l &lt;= n; l = r + 1) &#123; // 注意从 2 开始 r = (n / (n / l)); ans -= (g_sum(r) - g_sum(l - 1)) * GetSum(n / l); // g_sum 是 g 的前缀和 // 递归 GetSum 求解 &#125; return ans; &#125; 这个代码的复杂度是 $O(n^{\\frac{3}{4}})$，证明如下： 设求出 $S(n)$ 的复杂度是 $T(n)$ ，要求出 $S(n)$ 需要求出 $\\sqrt n$ 个 $S (\\lfloor \\frac{n}{i} \\rfloor)$ 的值，结合数论分块的复杂度 $O(\\sqrt n)$ 可得： T(n) = \\sum\\limits_{i=1}^{\\sqrt n} O(\\sqrt i) + O(\\sqrt {\\frac{n}{i}})=O(n^{\\frac{3}{4}})还可以进一步优化杜教筛，即先线性筛出前 $m$ 个答案，之后再用杜教筛。这个优化之后的复杂度是： T(n) = \\sum\\limits_{i=1}^{\\lfloor \\frac{n}{m} \\rfloor} \\sqrt \\frac{n}{i} = O({\\frac{n}{\\sqrt m}})当 $m = n ^ {\\frac{2}{3}}$ 时，$T(n) = O(n^{\\frac{2}{3}})$ 可以使用哈希表来存下已经求过的答案，也可以不用。 考虑到上面的求和过程中出现的都是 $\\lfloor \\frac{n}{i} \\rfloor $ 。开一个大小为两倍 $\\sqrt n$ 的数组 $dp$ 记录答案。如果现在需要求出 GetSum(x) ，若 $x \\leq \\sqrt n$ ，返回 dp[x] ，否则返回 dp[sqrt n + n / i] 即可。这样可以省去哈希表的复杂度。","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://yoursite.com/categories/算法笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"},{"name":"杜教筛","slug":"杜教筛","permalink":"http://yoursite.com/tags/杜教筛/"}]},{"title":"BZOJ3160 万径人踪灭","slug":"BZOJ3160","date":"2019-02-28T10:58:37.000Z","updated":"2019-02-28T11:26:48.938Z","comments":true,"path":"2019/02/28/BZOJ3160/","link":"","permalink":"http://yoursite.com/2019/02/28/BZOJ3160/","excerpt":"Description给定一个字符串由 ‘a’ 或 ‘b’ 组成。求有多少个子序列满足字母和坐标都关于一条对称轴对称并且不是连续的 字符串长度 $=n \\leq 10^5$","text":"Description给定一个字符串由 ‘a’ 或 ‘b’ 组成。求有多少个子序列满足字母和坐标都关于一条对称轴对称并且不是连续的 字符串长度 $=n \\leq 10^5$ Solution默认字符串为 $S$ 从 $0$ 开始标号。 答案等于所有的满足字母和坐标都关于一条对称轴对称的子序列数量 - 连续的满足这个性质的子序列数量 后面这个可以直接用 manacher算法 直接求出，只需要考虑前面怎么求 考虑怎么算出关于第 $i$ 个位置对称的子序列个数。设有 $k$ 组 $(x, y)$ 使得 $x + y = 2 i$ 且 $x, y \\not= i$ 且 $S_x = S_y$ ，那么方案数就是 $2^{k+1}-1$ （k 组和 $i$ 这个位置选不选减去都不选的一种情况） 考虑怎么算出关于第 $i$ 到第 $i+1$ 个位置中间这个空隙（可以认为是 $i + \\frac{1}{2}$）对称的子序列的个数。设有 $k$ 组 $(x,y)$ 满足 $S_x = S_y$ 且 $x+y = 2(i+\\frac{1}{2}) = 2i + 1$ ，那么方案数就是 $2^k - 1$（和上面不一样的原因是自己这个位置不是整数不能被选所以不用考虑） 令 $ f_i = \\sum\\limits_{x+y=i} [S_x=S_y] $ ，那么 $f_i$ 和这个 $k$ 的关系是什么呢？ 这里要想清楚。当 $i$ 是偶数的时候，$[S_{\\frac{i}{2}}=S_{\\frac{i}{2}}]$ 其实也被算了进去，所以应该是 $f_i = 2k + 1$；而 $i$ 是奇数的时候就没有这个问题，直接就是 $f_i = 2k$；综合一下其实就是 $k = \\lfloor \\frac{f_i}{2} \\rfloor$ 然后就是怎么求 $f_i$ 的问题了。这是一个卷积的形式，又显然字母之间是独立的。那么对于每一个字母 $x$，令 $g_i = [S_i = x]$，那么 $f$ 就是由两个 $g$ 卷积得到的。所以最后 f 就是对于两个字母分别做一遍卷积加起来就行。 具体的，这道题的做法是： 拿到字符串，跑 manacher 得到 s1 令 $f_i = [S_i = a]$，将 $f * f$ 加到多项式 $h$ 中 令 $g_i = [S_i = b]$，将 $g * g$ 加到多项式 $h$ 中 答案就相当于 $ \\sum\\limits_{i=0}^{2n - 2} (2^{\\lfloor\\frac{h_i}{2}\\rfloor + [2|i]}-1)$ （可能有点复杂不过综合上面来看是显然的） 对于卷积，我用的是 NTT (FFT 我也写了，慢了 4 倍嘿嘿) 时间复杂度 $O(n \\log n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Author: AcFunction * Date: 2019-02-26 22:14:41 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long long#define db double #define RG register #define rep(i, l, r) for(RG int i = l; i &lt;= r; i++) #define per(i, r, l) for(RG int i = r; i &gt;= l; i--)using namespace std;void INIT() &#123; ios :: sync_with_stdio(false); cin.tie(0); &#125;const int N = 1001000;const ll mod = (ll)1e9 + 7; const ll MOD = 998244353; const ll G = 3; int n, len[N], r[N], L; char S[N]; string s; ll f[N], g[N], tmp[N], Ans[N], invl; ll fpw(ll x, ll k, ll p) &#123; ll ret = 1ll; while(k) &#123; if(k &amp; 1) ret = ret * x % p; x = x * x % p; k &gt;&gt;= 1; &#125; return ret; &#125;void NTT(ll *a, int op) &#123; rep(i, 0, L - 1) tmp[i] = a[r[i]]; rep(i, 0, L - 1) a[i] = tmp[i]; for(int i = 1; i &lt; L; i &lt;&lt;= 1) &#123; ll w = fpw(G, (MOD - 1) / (i &lt;&lt; 1), MOD); if(op == -1) w = fpw(w, MOD - 2, MOD); for(int j = 0; j &lt; L; j += i &lt;&lt; 1) &#123; ll wn = 1ll; for(int k = j; k &lt; i + j; k++) &#123; ll t = a[i + k] * wn % MOD; a[i + k] = (a[k] - t + MOD) % MOD; a[k] = (a[k] + t) % MOD; wn = wn * w % MOD; &#125; &#125; &#125; if(op == -1) &#123; rep(i, 0, L - 1) a[i] *= invl, a[i] %= MOD; &#125;&#125;int main() &#123; INIT(); cin &gt;&gt; (S + 1); n = strlen(S + 1); s = \"^#\"; rep(i, 1, n) &#123; s += S[i]; s += '#'; &#125; int mx = 0, id = 0; rep(i, 1, 2 * n + 1) &#123; len[i] = mx &gt; i ? min(len[2 * id - i], mx - i) : 1; while(s[i - len[i]] == s[i + len[i]]) len[i]++; if(mx &lt; i + len[i]) mx = i + len[i], id = i; &#125; ll ans = 0; rep(i, 1, 2 * n + 1) ans += len[i] / 2, ans %= mod; L = 1; while(L &lt;= 2 * n) L &lt;&lt;= 1; invl = fpw(L, MOD - 2, MOD); for(int i = 1; i &lt; L; i &lt;&lt;= 1) for(int j = 0; j &lt; i; j++) r[i + j] = r[j] + L / (i * 2); rep(i, 0, n - 1) f[i] = (S[i + 1] == 'a'); rep(i, 0, n - 1) g[i] = f[i]; NTT(f, 1), NTT(g, 1); rep(i, 0, L - 1) Ans[i] = f[i] * g[i] % MOD; rep(i, 0, n - 1) f[i] = (S[i + 1] == 'b'); rep(i, 0, n - 1) g[i] = f[i]; rep(i, n, L - 1) f[i] = g[i] = 0; NTT(f, 1), NTT(g, 1); rep(i, 0, L - 1) Ans[i] += f[i] * g[i] % MOD, Ans[i] %= MOD; NTT(Ans, -1); ll anss = 0; rep(i, 0, 2 * n - 2) &#123; int t = Ans[i]; t = t / 2; if(i &amp; 1) &#123; anss += (fpw(2, t, mod) - 1) % mod; anss %= mod; &#125; else anss += (fpw(2, t + 1, mod) - 1) % mod; anss %= mod; &#125; cout &lt;&lt; ((anss - ans) % mod + mod) % mod &lt;&lt; endl; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"manacher","slug":"manacher","permalink":"http://yoursite.com/tags/manacher/"},{"name":"FFT","slug":"FFT","permalink":"http://yoursite.com/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"http://yoursite.com/tags/NTT/"}]},{"title":"BZOJ3091 城市旅行","slug":"BZOJ3091","date":"2019-02-21T14:44:18.000Z","updated":"2019-02-21T14:50:27.888Z","comments":true,"path":"2019/02/21/BZOJ3091/","link":"","permalink":"http://yoursite.com/2019/02/21/BZOJ3091/","excerpt":"Description给一颗以 $1$ 为根的有根树，维护以下操作 连接 $(u,v)$ 这条边 删除 $(u,v)$ 这条边 给 $u$ 到 $v$ 的链上每个点加上一个数 求在 $(u,v)$ 上任意选两个点它们之间的权值和的期望 $n, m \\leq 50000, a_i \\leq 10^6$","text":"Description给一颗以 $1$ 为根的有根树，维护以下操作 连接 $(u,v)$ 这条边 删除 $(u,v)$ 这条边 给 $u$ 到 $v$ 的链上每个点加上一个数 求在 $(u,v)$ 上任意选两个点它们之间的权值和的期望 $n, m \\leq 50000, a_i \\leq 10^6$ Solution前三个操作就是 LCT 板子，考虑如何在 LCT 上维护 4 操作 为了方便，设这个路径是 $a_1, a_2, a_3, \\cdots, a_{siz}$ ，其中 $siz$ 是长度 考虑每个点的贡献，易得我们要求的期望值 $=\\frac{\\sum\\limits_{i=1}^{siz} i (siz - i + 1)a_i}{\\frac{siz(siz+1)}{2}}$ 显然这个分母很好搞，只需要考虑怎么在 LCT 上维护分子，或者说在平衡树上。 也就是说，如果知道左子和右子的答案如何更新出这个点的答案 设左子表示 $a_1, a_2, \\cdots, a_p$， 该点的值是 $a_{p+1}$ ，右子表示 $a_{p+2}, \\cdots, a_{siz}$ 可以得到：左子的 $siz_0 = p$，右子的 $siz_1 = siz - p - 1$ 改点要的答案减去左子的答案减去右子的答案便是 $\\sum\\limits_{i=1}^{siz}i(siz - i + 1)a_i - \\sum\\limits_{i=1}^{p}i(p-i+1)a_i-\\sum\\limits_{i=p+2}^{siz} (i-p-1)(siz - i + 1)a_i$ $=\\sum\\limits_{i=1}^{p} i(siz-p)a_i+a_{p+1}(p+1)(siz-p)+\\sum\\limits_{i=p+2}^{siz}(p+1)(siz-i+1)a_i$ 根据上面得到的 $siz_0=p,siz_1=siz-p-1$ 简单化简一下可以得到 $=(siz_1+1)\\sum\\limits_{i=1}^{siz_0}i\\cdot a_i+a_{siz_0+1}(siz_0+1)(siz_1+1)+(siz_0+1)\\sum\\limits_{i=p+2}^{siz}(siz - i +1)a_i$ 到这里应该你已经知道怎么做了.. 为了清楚，再令 $b_1, b_2, \\cdots,b_{siz_b}$ 是左子的， $c_1, c_2, \\cdots,c_{siz_c}$ 是右子的，$d$ 是这个点本身的值。那么可以化简成简单清楚对称的形式： $=(siz_c+1)\\sum\\limits_{i=1}^{siz_b}i\\cdot b_i+d(siz_b+1)(siz_c+1)+(siz_b+1)\\sum\\limits_{i=1}^{siz_c}(siz_c-i+1)c_i$ 你只需要每个点再维护两个值： $ls=\\sum\\limits_{i=1}^{siz}i\\cdot a_i$ 和 $rs=\\sum\\limits_{i=1}^{siz}(siz - i +1)a_i$ 就可以从左右两个儿子得到自己的值 这两个东西维护还是比较简单的..具体的话就是再维护一个 $s$ 为子树里所有数的和然后令 $b,c$ 是左右两个儿子，那么有 $ls = ls_b+d\\cdot(siz_b+1)+ls_c+s_c (siz_b+1)$ 和 $rs=rs_c+d\\cdot(siz_c+1)+rs_b+s_b(siz_c+1)$ 就这样维护 以上是如何用左右儿子的信息得到自己，再来考虑链加的问题 一条链加上一个数 $x$ ，那么会如何影响我们维护的值？ 对于 $s$：$s = s + siz\\cdot x$ 对于 $ls$：$ls = ls + \\sum\\limits_{i=1}^{siz}i \\cdot x = ls + \\frac{siz(siz+1)}{2}\\cdot x$ 对于 $rs$：和 ls 一样 $rs = rs+\\frac{siz(siz+1)}{2}\\cdot x$ 对于最后的答案 $S$：$S = S + \\sum\\limits_{i=1}^{siz} i \\cdot (siz - i +1)\\cdot x$ 通过简单计算可得 $S= S+\\frac{siz(siz+1)(siz+2)}{6}\\cdot x$ 对于自己的值：直接加上 $x$ （废话） 然后 LCT 板子套一套就做完了 注意事项： 翻转的时候需要 swap(ls, rs) 两个点之间是联通的时候才执行链加操作（坑死我了） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173/** * Author: AcFunction * Date: 2019-02-17 11:17:08 * Email: 3486942970@qq.com**/#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 200200; const ll INF = (ll)1e18; int n, m;ll a[N]; struct node &#123; int rev; ll d, s, ls, rs, s1, add, siz; node *ch[2], *prt; int isr() &#123; return (!prt) || ( prt-&gt;ch[0] != (this) &amp;&amp; prt-&gt;ch[1] != (this) ); &#125; int dir() &#123; return prt-&gt;ch[1] == (this); &#125; void setc(node *p, int k) &#123; (this)-&gt;ch[k] = p; if(p) p-&gt;prt = (this); &#125; void setr() &#123; rev ^= 1; swap(ls, rs); swap(ch[0], ch[1]); &#125; void seta(ll x) &#123; d += x, add += x; s += siz * x; ls += siz * (siz + 1) / 2 * x; rs += siz * (siz + 1) / 2 * x; s1 += siz * (siz + 1) * (siz + 2) / 6 * x; &#125; void upd() &#123; siz = 1, s = d; if(ch[0]) siz += ch[0]-&gt;siz, s += ch[0]-&gt;s; if(ch[1]) siz += ch[1]-&gt;siz, s += ch[1]-&gt;s; if(ch[0] &amp;&amp; ch[1]) &#123; ls = ch[0]-&gt;ls + d * (ch[0]-&gt;siz + 1) + ch[1]-&gt;ls + ch[1]-&gt;s * (ch[0]-&gt;siz + 1); rs = ch[1]-&gt;rs + d * (ch[1]-&gt;siz + 1) + ch[0]-&gt;rs + ch[0]-&gt;s * (ch[1]-&gt;siz + 1); s1 = ch[0]-&gt;s1 + ch[1]-&gt;s1; s1 += ch[0]-&gt;ls * (ch[1]-&gt;siz + 1); s1 += ch[1]-&gt;rs * (ch[0]-&gt;siz + 1); s1 += d * (ch[0]-&gt;siz + 1) * (ch[1]-&gt;siz + 1); &#125; else if(ch[0]) &#123; ls = ch[0]-&gt;ls + d * (ch[0]-&gt;siz + 1); rs = d + ch[0]-&gt;rs + ch[0]-&gt;s; s1 = ch[0]-&gt;s1 + ch[0]-&gt;ls + d * (ch[0]-&gt;siz + 1); &#125; else if(ch[1]) &#123; ls = d + ch[1]-&gt;ls + ch[1]-&gt;s; rs = d * (ch[1]-&gt;siz + 1) + ch[1]-&gt;rs; s1 = ch[1]-&gt;s1 + ch[1]-&gt;rs + d * (ch[1]-&gt;siz + 1); &#125; else &#123; ls = rs = s1 = d; &#125; &#125; void push() &#123; if(rev) &#123; if(ch[0]) ch[0]-&gt;setr(); if(ch[1]) ch[1]-&gt;setr(); rev = 0; &#125; if(add) &#123; if(ch[0]) ch[0]-&gt;seta(add); if(ch[1]) ch[1]-&gt;seta(add); add = 0; &#125; &#125;&#125; pool[N * 2], *P[N], *cur = pool;node *New(ll d) &#123; node *p = cur++; p-&gt;d = d, p-&gt;ls = p-&gt;rs = d; p-&gt;s = p-&gt;s1 = d; p-&gt;prt = p-&gt;ch[0] = p-&gt;ch[1] = 0; p-&gt;siz = 1; return p; &#125;void rotate(node *p) &#123; node *prt = p-&gt;prt; int k = p-&gt;dir(); if(!prt-&gt;isr()) prt-&gt;prt-&gt;setc(p, prt-&gt;dir()); else p-&gt;prt = prt-&gt;prt; prt-&gt;setc(p-&gt;ch[!k], k); p-&gt;setc(prt, !k); prt-&gt;upd(); p-&gt;upd();&#125;node *sta[N]; int top; void splay(node *p) &#123; node *q = p; while(1) &#123; sta[++top] = q; if(q-&gt;isr()) break ; q = q-&gt;prt; &#125; while(top) (sta[top--])-&gt;push(); while(!p-&gt;isr()) &#123; if(p-&gt;prt-&gt;isr()) rotate(p); else if(p-&gt;dir() == p-&gt;prt-&gt;dir()) rotate(p-&gt;prt), rotate(p); else rotate(p), rotate(p); &#125; p-&gt;upd(); &#125;node *access(node *p) &#123; node *q = 0; for(; p; p = p-&gt;prt) &#123; splay(p); p-&gt;ch[1] = q; (q = p)-&gt;upd(); &#125; return q; &#125;inline void mkroot(node *p) &#123; access(p); splay(p); p-&gt;setr(); p-&gt;push(); &#125;inline void split (node *p, node *q) &#123; mkroot(p); access(q); splay(p); &#125;inline void link (node *p, node *q) &#123; mkroot(p); mkroot(q); q-&gt;prt = p; &#125;inline void cut (node *p, node *q) &#123; split(p, q); p-&gt;ch[1] = q-&gt;prt = 0; &#125;inline node *find(node *p) &#123; access(p); splay(p); while(p-&gt;ch[0]) p = p-&gt;ch[0]; return p; &#125;inline ll gcd(ll a, ll b) &#123; return !b ? a : gcd(b, a % b); &#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;a[i]); P[i] = New(a[i]); &#125; for(int i = 1; i &lt; n; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); link(P[u], P[v]); &#125; for(int i = 1; i &lt;= m; i++) &#123; int op, u, v; ll d; scanf(\"%d %d %d\", &amp;op, &amp;u, &amp;v); if(op == 1) if(find(P[u]) == find(P[v])) cut(P[u], P[v]); if(op == 2) if(find(P[u]) != find(P[v])) link(P[u], P[v]); if(op == 3) &#123; scanf(\"%lld\", &amp;d); if(find(P[u]) != find(P[v])) continue ; // important! split(P[u], P[v]), P[u]-&gt;seta(d); &#125; if(op == 4) &#123; if(find(P[u]) != find(P[v])) &#123; printf(\"-1\\n\"); continue ; &#125; split(P[u], P[v]); ll ans = P[u]-&gt;s1; ll t = P[u]-&gt;siz * (P[u]-&gt;siz + 1) / 2; ll g = gcd(ans, t); printf(\"%lld/%lld\\n\", ans / g, t / g); &#125; &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://yoursite.com/tags/LCT/"}]},{"title":"CF1110E Magic Stones","slug":"CF1110E","date":"2019-02-09T01:52:27.000Z","updated":"2019-02-09T02:00:53.168Z","comments":true,"path":"2019/02/09/CF1110E/","link":"","permalink":"http://yoursite.com/2019/02/09/CF1110E/","excerpt":"Description给出一个初始序列 $a$ 和一个目标序列 $b$，你可以对 $a$ 中的除去第一个和最后一个点之外的任意一个点 $i$ ，让 $a_i$ 变成 $a_{i-1}+a_{i+1}-a_i$ 。问是否能够通过若干次操作使得 a 变成 b 序列长度 $n \\leq 10^5$","text":"Description给出一个初始序列 $a$ 和一个目标序列 $b$，你可以对 $a$ 中的除去第一个和最后一个点之外的任意一个点 $i$ ，让 $a_i$ 变成 $a_{i-1}+a_{i+1}-a_i$ 。问是否能够通过若干次操作使得 a 变成 b 序列长度 $n \\leq 10^5$ Solution我觉得这个题应该放在 A 考虑一个序列 : a|b|c 对 b 进行操作：a|a+c-b|c 他的差分序列原来是：a-b | b-c 现在变成了：b-c | a-b 所以一次操作相当于是把差分数组里的相邻两个数给交换了位置 所以只用判断目标序列的差分数组排序后是否等于初始序列的差分数组 还有第一个数相不相等（比赛的时候没考虑这个 wa 了一发…） 时间复杂度瓶颈在排序（或者说判断相同） Code1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100100; int n, a[N], b[N]; int main() &#123; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;b[i]); if(a[1] != b[1]) &#123; printf(\"No\\n\"); return 0; &#125; for(int i = 1; i &lt; n; i++) a[i] = a[i + 1] - a[i]; for(int i = 1; i &lt; n; i++) b[i] = b[i + 1] - b[i]; sort(a + 1, a + n), sort(b + 1, b + n); for(int i = 1; i &lt; n; i++) if(a[i] != b[i]) &#123; printf(\"No\\n\"); return 0; &#125; printf(\"Yes\\n\"); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[]},{"title":"CF1110F Nearest Leaf","slug":"CF1110F","date":"2019-02-09T00:59:23.000Z","updated":"2019-02-09T01:42:55.597Z","comments":true,"path":"2019/02/09/CF1110F/","link":"","permalink":"http://yoursite.com/2019/02/09/CF1110F/","excerpt":"Description给你一颗满足编号 = dfs 序的带边权的有根树。$m$ 次询问，每次给出 $v,l,r$ 求编号在 $[l,r]$ 中的叶子到 $v$ 节点的最短距离 $n,m \\leq 5\\times10^5,w \\leq 10^9$","text":"Description给你一颗满足编号 = dfs 序的带边权的有根树。$m$ 次询问，每次给出 $v,l,r$ 求编号在 $[l,r]$ 中的叶子到 $v$ 节点的最短距离 $n,m \\leq 5\\times10^5,w \\leq 10^9$ Solution如果我们知道 $u$ 节点到所有叶子的最短路，如何求出他的某一个儿子 $v$ 到所有叶子的最短路呢？ 不妨设 $(u,v)$ 的边权是 $w$ 。那么在 $v$ 这颗子树内的叶子到 $v$ 的距离较 $u$ 要减少 $w$ ； $v$ 这颗子树外的叶子到 $v$ 的距离较 $u$ 要增加 $w$ 。 又良心出题人给的树是满足那个性质的，所以子树内的编号是连续的。 所以最开始 dfs 一遍。求出每个点到根的距离。把询问离线，进行一次先序遍历。 每次进入到一颗子树，就用线段树把该子树内的叶子减少 w 外面的增加 w 当回溯的父亲的时候，就用线段树把该子树内的叶子增加 w 外面的减少 w 然后遍历到一个节点就把和他有关的询问全都用线段树里的信息处理掉就行了 Code我的实现貌似有点麻烦…我直接用线段树维护叶子，所以每次给出的左右端点还要在叶子序列里二分一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;#define ll long long#define PI pair#define Fi first#define Se second#define MP make_pair#define INF 1000000000000000000using namespace std;const int N = 500500; int n, m, siz[N]; ll dis[N], ans[N];vector &lt;int&gt; lea; struct edge &#123; int v; ll w; edge *next; &#125; pol[N * 2], *head[N], *cu = pol;inline void addedge(int u, int v, ll w) &#123; edge *p = cu++, *q = cu++; p-&gt;v = v, p-&gt;w = w, p-&gt;next = head[u], head[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = head[v], head[v] = q; &#125;inline void dfs(int u, int pre) &#123; siz[u] = 1; bool fla = 1; for(edge *p = head[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(v == pre) continue ; fla = 0; dis[v] = dis[u] + p-&gt;w; dfs(v, u); siz[u] += siz[v]; &#125; if(fla) lea.push_back(u); &#125;struct ST &#123; int l, r; ll tag, mn; ST *ch[2]; inline void seta(ll d) &#123; tag += d; mn += d; &#125; inline void upd() &#123; mn = min(ch[0]-&gt;mn, ch[1]-&gt;mn); &#125; inline void push() &#123; if(tag) &#123; if(ch[0]) ch[0]-&gt;seta(tag); if(ch[1]) ch[1]-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[N * 2], *cur = pool, *rt; inline void build(ST *p, int l, int r) &#123; p-&gt;l = l, p-&gt;r = r; if(l == r) &#123; p-&gt;mn = dis[lea[l - 1]]; return ; &#125; ST *ls = cur++, *rs = cur++; p-&gt;ch[0] = ls, p-&gt;ch[1] = rs; int mid = (l + r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); p-&gt;upd(); &#125;inline void modify(ST *p, int l, int r, ll d) &#123; if(l &gt; r) return ; if(p-&gt;l == l &amp;&amp; p-&gt;r == r) return p-&gt;seta(d); p-&gt;push(); if(p-&gt;ch[0]-&gt;r &gt;= r) modify(p-&gt;ch[0], l, r, d); else if(p-&gt;ch[1]-&gt;l &lt;= l) modify(p-&gt;ch[1], l, r, d); else modify(p-&gt;ch[0], l, p-&gt;ch[0]-&gt;r, d), modify(p-&gt;ch[1], p-&gt;ch[1]-&gt;l, r, d); p-&gt;upd(); &#125;inline ll Qmin(ST *p, int l, int r) &#123; if(l &gt; r) return INF; p-&gt;push(); if(p-&gt;l == l &amp;&amp; p-&gt;r == r) return p-&gt;mn; if(p-&gt;ch[0]-&gt;r &gt;= r) return Qmin(p-&gt;ch[0], l, r); else if(p-&gt;ch[1]-&gt;l &lt;= l) return Qmin(p-&gt;ch[1], l, r); else return min(Qmin(p-&gt;ch[0], l, p-&gt;ch[0]-&gt;r), Qmin(p-&gt;ch[1], p-&gt;ch[1]-&gt;l, r)); &#125;vector &lt; PI &lt;int, PI &lt;int, int&gt; &gt; &gt; Q[N]; // emm 我还不太会用 lower_bound / upper_bound 所以就只能手写了..inline int up(int x) &#123; int l = 0, r = n - 1, ret = 0; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(lea[mid] &lt;= x) l = mid + 1, ret = mid; else r = mid - 1; &#125; return ret + 1; &#125;inline int lw(int x) &#123; int l = 0, r = n - 1, ret = n - 1; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(lea[mid] &gt;= x) r = mid - 1, ret = mid; else l = mid + 1; &#125; return ret + 1; &#125;inline void solve(int u, int pre) &#123; for(int i = 0; i &lt; Q[u].size(); i++) &#123; int id = Q[u][i].Fi; int l = Q[u][i].Se.Fi; int r = Q[u][i].Se.Se; // printf(\"***%d %d %d\\n\", id, up(l), lw(r)); ans[id] = Qmin(rt, lw(l), up(r)); &#125; for(edge *p = head[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(v == pre) continue ; int L = lw(v), R = up(v + siz[v] - 1); ll w = p-&gt;w; // printf(\"%d %d %d\\n\", v, L, R); modify(rt, L, R, -w); modify(rt, 1, L - 1, w); modify(rt, R + 1, n, w); solve(v, u); modify(rt, L, R, w); modify(rt, 1, L - 1, -w); modify(rt, R + 1, n, -w); &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 2; i &lt;= n; i++) &#123; int p; ll w; scanf(\"%d %lld\", &amp;p, &amp;w); addedge(p, i, w); &#125; dfs(1, 0); n = lea.size(); sort(lea.begin(), lea.end()); build(rt = cur++, 1, n); for(int i = 1; i &lt;= m; i++) &#123; int v, l, r; scanf(\"%d %d %d\", &amp;v, &amp;l, &amp;r); Q[v].push_back(MP(i, MP(l, r))); &#125; solve(1, 0); for(int i = 1; i &lt;= m; i++) printf(\"%lld\\n\", ans[i]); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"dfs序","slug":"dfs序","permalink":"http://yoursite.com/tags/dfs序/"}]},{"title":"「云玩家拯救计划」小题单","slug":"Cloud-Player-Rescue-Plan","date":"2019-02-02T06:20:23.000Z","updated":"2019-02-09T01:14:32.656Z","comments":true,"path":"2019/02/02/Cloud-Player-Rescue-Plan/","link":"","permalink":"http://yoursite.com/2019/02/02/Cloud-Player-Rescue-Plan/","excerpt":"云玩家拯救计划（雾","text":"云玩家拯救计划（雾 网络流A(CF1009G)：直接贪心，用二分图里的一个霍尔定理来判断合法性。实现上可以简单一点。 B(CF808F)：先二分答案，观察到除了 2 以外所有质数由偶数+奇数得来。于是 check 就可以特判 1 + 1 的情况，建图最小割即可。 C(CF164C)：把任务按照开始时间排序，S -&gt; 最小的开始时间 -&gt; 第二个 -&gt; .. -&gt; 第 n 个 -&gt; T 连流量 m 费用 0 ，再对于每个任务连一条从起点到终点加 1，流量 1 费用 -c 的边。然后最小费用最大流就好了。我还是不会输出方案（捂脸 D(CF277E)：以前做过…写过题解… E(CF1082G)：把每个点和每条边算成一个点，边的权值是负的，然后最大权闭合子图 F(BZOJ3158)： 考虑 % 4 可以证明奇数方+奇数方不等于完全平方，同时偶数的最大公约数 &gt; 1 所以奇数一边偶数一边建二分图然后就是套路的最小割了G(CF863F)：可以求出每个点的可行区间，然后那个平方的条件就可以拆边。就是 (1,1), (3,1), (5,1), (7,1) …. 然后最小费用最大流 H(CF498C)：显然除质因子答案最大 &amp;&amp; 质因子之间相互独立。对于每一个出现过的质因子跑最大流就行了 数论A(BZOJ2154) ：不妨设 $n \\leq m$ $\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m} lcm(i, j)$ $=\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m} \\frac{ij}{\\gcd(i,j)}$ $=\\sum\\limits_{d=1}^{n}\\sum\\limits_{i’=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum\\limits_{j’=1}^{\\lfloor \\frac{m}{d} \\rfloor} i’j’d [\\gcd(i’,j’)=1]$ $=\\sum\\limits_{d=1}^{n}d \\sum\\limits_{i’=1}^{\\lfloor \\frac{n}{d} \\rfloor} i’ \\sum\\limits_{j’=1}^{\\lfloor \\frac{m}{d} \\rfloor} j’ [gcd(i’,j’)=1]$ $ =\\sum\\limits_{d=1}^{n} d \\sum\\limits_{i’=1}^{\\lfloor \\frac{n}{d} \\rfloor} i’ \\sum\\limits_{j’=1}^{\\lfloor \\frac{m}{d} \\rfloor} j’ \\sum\\limits_{d’|i’,d’|j’}\\mu(d’)$ $=\\sum\\limits_{d=1}^{n}\\sum\\limits_{d’=1}^{n}\\mu(d’)d \\sum\\limits_{i’=1}^{\\lfloor \\frac{n}{d’d} \\rfloor} i’ \\sum\\limits_{j’=1}^{\\lfloor \\frac{m}{d’d} \\rfloor} j’ $ 令 $dd’=T, F(T)=\\sum\\limits_{d | T}\\mu(d)\\frac{T}{d}$ 。F 可以线性筛出来，就做完了 ） 然后这个题连分块都不用（ 好像有需要分块的加强版被权限了（ B(BZOJ2440)：题解 C(BZOJ3529)：题解 D(HDU6053)： 待填坑 E(BZOJ2956)： $\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} i\\not= j(m\\%j)$ $=\\sum\\limits_{i=1}^{n}n\\%i\\sum\\limits_{j=1}^{m}m\\%j-\\sum\\limits_{i=1}^{n}(n\\%i)(m\\%i)$ 然后把 $n\\%i$ 搞成 $n -i \\lfloor\\frac{n}{i}\\rfloor $ ，$m\\%i$ 同理，然后推推式子分个块就做完了 F(HDU4947)：待填坑 G(BZOJ2005)：有点简单懒得写hhh H(HDU4473)：把题目要求转化为有多少个有序对 (a,b,c) 满足 abc = n。然后分三类 a,b,c;a,a,b;a,a,a 讨论下就行了（优秀的暴力… I(HDU5942)：有点难啊…看的 这个题解 线段树主席树A(HDU4578)：线段树维护加标记乘标记以及三个值分别表示和，平方的和，立方的和。加标记更新就用二项式展开一下倒序更新；乘标记就是和乘上d，平方乘上d^2，立方同理…然后覆盖操作拆成先乘 0 再加 。 B(BZOJ1818)：先把题目条件转化成所有由这些点组成的平行于坐标轴的线段之间有几个交点（端点也算）。然后就直接把坐标离散化一下然后扫描线扫过去中间用树状数组维护一下就行了。 C(COT)：板子再见 D(BZOJ3261)：搞个可持久化 0/1 trie 维护前缀异或和然后就做完了（板子） E(CF484E)：二分答案下，然后对于一个值是否合法只需要把 &gt; 该数的变成 1 ，小于该数的变成 0 然后用线段树维护这个区间内的最长的 1 序列。由于不能开一堆线段树，所以用主席数的思想就行了（我都觉得我说的不清楚…） F()： G：线段树合并裸题 H：kruskal 重构树上主席树 I：对每一位维护线段树就行了 J：压个位然后维护区间或就行了 K：模板题再见","categories":[],"tags":[]},{"title":"CF757F Team Rocket Rises Again","slug":"CF757F","date":"2019-02-01T11:41:04.000Z","updated":"2019-02-01T12:15:18.513Z","comments":true,"path":"2019/02/01/CF757F/","link":"","permalink":"http://yoursite.com/2019/02/01/CF757F/","excerpt":"Description一个 $n$ 个点 $m$ 条边的无向图，给出起点 $S$ 。求删除掉一个不是 $S$ 的点后最多能改变多少个点到 $S$ 的最短路。输出这个最大值。 $n \\leq 200000, m \\leq \\min(\\frac{n(n-1)}{2},300000)$","text":"Description一个 $n$ 个点 $m$ 条边的无向图，给出起点 $S$ 。求删除掉一个不是 $S$ 的点后最多能改变多少个点到 $S$ 的最短路。输出这个最大值。 $n \\leq 200000, m \\leq \\min(\\frac{n(n-1)}{2},300000)$ Solution在飞机上写的题解 2333 定义 $d_u$ 是 $S$ 到 $u$ 的最短路；最短路 DAG 为所有有向边 $(u,v)$ 满足 $d_u+w(u,v)=d_v$ 组成的 DAG . 那么显然删这个 DAG 上的点才是对答案有贡献的。 考虑如何求出删完一个点会使得有多少个点的最短路有改变。 把这个 DAG 的支配树建出来然后对于一个点它在支配树上的子树大小就是答案。 注：支配树是啥？ 在一个有向图中有一个节点是 $S$ ；对于节点 $u$ 从 $S$ 到 $u$ 上的路径必到的点称之为 $u$ 的支配点 对于每一个 $u$ ，从离他最近的一个点向他连一条边。这些边组成的便是原图的支配树。其中 $S$ 为根节点 对于一个 DAG 如何建出他的支配树？即对于一个点怎么求出离他最近的支配点？ 可以考虑用拓扑排序的顺序更新。对于节点 $u$ ，它的所有前驱在支配树上的 LCA便是它在支配树上的父亲；即离他最近的支配点。 这个过程需要维护的就是 加点 和 维护 LCA 。可以用倍增用 $O(n \\log n)$ 的时间复杂度解决 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long // don't think I use int ! const int N = 300300; const int INF = (int)4e18; int n, m, S, dis[N], U[N], V[N], W[N], ind[N], fa[N][25], dep[N], siz[N]; vector &lt;int&gt; g[N]; struct edge &#123; int v, w; edge *next; &#125; *h1[N], *h2[N], *h3[N], pool[N * 6], *cur = pool; inline void add1(int u, int v, int w) &#123; edge *p = cur++; p-&gt;w = w; p-&gt;v = v, p-&gt;next = h1[u], h1[u] = p; &#125;inline void add2(int u, int v) &#123; edge *p = cur++; p-&gt;v = v, p-&gt;next = h2[u], h2[u] = p; &#125;inline void add3(int u, int v) &#123; edge *p = cur++; p-&gt;v = v, p-&gt;next = h3[u], h3[u] = p; &#125;inline void add(int x, int f) &#123; fa[x][0] = f; for(int i = 1; i &lt;= 20; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1]; dep[x] = dep[f] + 1; &#125;inline int LCA(int u, int v) &#123; if(dep[u] &lt; dep[v]) swap(u, v); for(int i = 20; i &gt;= 0; i--) if(dep[fa[u][i]] &gt;= dep[v] &amp;&amp; fa[u][i]) u = fa[u][i]; if(u == v) return u; for(int i = 20; i &gt;= 0; i--) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; return fa[u][0]; &#125;struct node &#123; int d, id; inline bool operator &lt; (const node &amp;x) const &#123; return d &gt; x.d; &#125;&#125; tmp; priority_queue &lt;node&gt; Q; inline void dijkstra() &#123; for(int i = 1; i &lt;= n; i++) dis[i] = INF; tmp.id = S, tmp.d = 0; Q.push(tmp); dis[S] = 0; while(!Q.empty()) &#123; tmp = Q.top(); Q.pop(); int u = tmp.id; if(dis[u] &lt; tmp.d) continue ; for(edge *p = h1[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(dis[v] &gt; dis[u] + p-&gt;w) &#123; dis[v] = dis[u] + p-&gt;w; tmp.id = v, tmp.d = dis[v]; Q.push(tmp); &#125; &#125; &#125;&#125;inline void dfs(int u, int pre) &#123; siz[u] = 1; for(edge *p = h3[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; if(v == pre) continue ; dfs(v, u); siz[u] += siz[v]; &#125;&#125;signed main() &#123; scanf(\"%lld %lld %lld\", &amp;n, &amp;m, &amp;S); for(int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf(\"%lld %lld %lld\", &amp;u, &amp;v, &amp;w); U[i] = u, V[i] = v, W[i] = w; add1(u, v, w), add1(v, u, w); &#125; dijkstra(); for(int i = 1; i &lt;= m; i++) &#123; if(dis[U[i]] == dis[V[i]] + W[i]) add2(V[i], U[i]), ind[U[i]]++, g[U[i]].push_back(V[i]); if(dis[V[i]] == dis[U[i]] + W[i]) add2(U[i], V[i]), ind[V[i]]++, g[V[i]].push_back(U[i]); &#125; queue &lt;int&gt; Q; Q.push(S); dep[S] = 1; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); // printf(\"%d\\n\", u); if(g[u].size()) &#123; int lca = g[u][0]; for(int i = 1; i &lt; g[u].size(); i++) &#123; // printf(\"%d\\n\", g[u][i]); lca = LCA(g[u][i], lca); &#125; add(u, lca); add3(lca, u); &#125; for(edge *p = h2[u]; p; p = p-&gt;next) &#123; int v = p-&gt;v; ind[v]--; if(ind[v] == 0) Q.push(v); &#125; &#125; int ans = 0; dfs(S, 0); for(int i = 1; i &lt;= n; i++) if(i != S) ans = max(ans, siz[i]); printf(\"%lld\\n\", ans); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"支配树","slug":"支配树","permalink":"http://yoursite.com/tags/支配树/"},{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"},{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"}]},{"title":"趣题「红眼睛与蓝眼睛」","slug":"Red-And-Blue-Eye","date":"2019-01-23T13:35:50.000Z","updated":"2019-01-23T14:27:49.329Z","comments":true,"path":"2019/01/23/Red-And-Blue-Eye/","link":"","permalink":"http://yoursite.com/2019/01/23/Red-And-Blue-Eye/","excerpt":"一道有趣的题目。","text":"一道有趣的题目。 Description一个岛上有 $n$ 个人，其中有 $m$ 个红眼睛，$n - m$ 个蓝眼睛。这个岛有三个规则 他们不能照镜子，不能看自己眼睛的颜色。 他们不能告诉别人对方的眼睛是什么颜色。 一旦有人知道了自己是红眼睛，他就会在当天夜里自杀。 如果有一天，一个外来人来到这里对他们所有人说「你们这里有红眼睛的人」 假设每一个人都有着极强的逻辑推理能力。 求证：在这句话公布后地第 $m$ 天晚上这 $m$ 个红眼睛会一起自杀。 注：每一个人是不知道岛上有多少个红眼睛的人的 Solution乍一看，这题毫无头绪。告诉了一句「你们这里有红眼睛的人」又能怎么样呢？ 先来看一个数学归纳法的证明： 如果这个岛上只有一个红眼睛，听到这句话后看到其他人都不是红眼睛，便意识到自己是红眼睛，当天自杀。 假设当这个岛上有 $m$ 个红眼睛，他们会在第 $m$ 天自杀成立 当有 $m + 1$ 个红眼睛的时候，在每个红眼睛看来，都有 $m$ 个红眼睛，这个红眼睛能够推理出如果他不是红眼睛，那么他看到的 $m$ 个红眼睛都会在第 $m$ 天自杀 。而在第 $m$ 天，没有人自杀。一到第 $m + 1$ 天，每个红眼睛都意识到他是红眼睛。于是都在第 $m + 1$ 天自杀了 命题得证。看似没有问题，实际上，除了 $m = 1$ 的情况，这句话就相当于废话。因为没有任何用 要么在这之前红眼睛早就死光了，要么根本就不会死人。 但这并不是一个错误的事情。一个大神的回答说出来了 戳这里 这句话的作用就在于，让 每个人都知道每个人都知道这里有红眼睛的人 进一步地，这句话让 每个人都每个人都知道每个人都知道这里有红眼睛的人 等等 引用这位大神的话，就是： 简单说，「岛上有红眼睛」这件事本来只是一项「共有知识」（Mutual knowledge），公开宣告使它变成了一项「公共知识」（Common knowledge）。这两种知识的区分在认知逻辑里面非常重要，在博弈论中有广泛的应用。 用不严谨的话粗略介绍一下这两个概念：对于一个给定的命题P和一群给定的人，共有知识只需要满足一个条件：这群人中所有人都知道P，那么P就是这群人的共有知识。公共知识则需要满足以下所有条件：这群人中1、所有人都知道P；2、所有人都知道所有人都知道P；3、所有人都知道所有人都知道所有人都知道P；4、所有人都知道所有人都知道所有人都知道所有人都知道P；5、…… 共有知识 转化成 公共知识 的影响是很大的，就像这个例子一样 共有知识 转化成 公共知识 也是很难的，所以累次这个例子不太可能实现 同时这句话也统一了所有人的时间起点，时间在推理中扮演者重要的角色。这句话也让每一个人知道别人也知道这个时间起点 ，这样才有 “第 $m$ 天” 这种说法能够统一（就像人的出生时间不同，自然不能做出有效的推理","categories":[{"name":"趣题","slug":"趣题","permalink":"http://yoursite.com/categories/趣题/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"http://yoursite.com/tags/博弈论/"}]},{"title":"BZOJ2653 middle","slug":"BZOJ2653","date":"2019-01-20T05:31:24.000Z","updated":"2019-02-01T12:15:07.166Z","comments":true,"path":"2019/01/20/BZOJ2653/","link":"","permalink":"http://yoursite.com/2019/01/20/BZOJ2653/","excerpt":"Description给你一个序列，每次询问给出四个数 $a,b,c,d$，求所有区间 $[l,r]$ 满足 $l \\in [a,b], r \\in [c,d]$ 的中位数的最大值。强制在线。 $n \\leq 20000, Q \\leq 25000,a_i \\leq 10^9$","text":"Description给你一个序列，每次询问给出四个数 $a,b,c,d$，求所有区间 $[l,r]$ 满足 $l \\in [a,b], r \\in [c,d]$ 的中位数的最大值。强制在线。 $n \\leq 20000, Q \\leq 25000,a_i \\leq 10^9$ Solution考虑二分答案。假设现在二分出来的是 $x$ ，那么把 $\\ge x$ 的位置设成 $1$ ，$&lt; x$ 的设为 $-1$ 。那么一个区间的中位数 $\\ge x$ 等价于这个区间的和 $\\ge 0$ 如何处理题目给的左右端点的限制？ 可以发现 $[l,r]$ 必然包含 $[b+1,c-1]$ (如果 $b+1 \\leq c+1$ 的话）所以 $[l, r]$ 的和必然包含 $[b+1, c-1]$ 的和 显然让 $[l,r]$ 的和最大的方案是取 $[a,b]$ 的最大右段和 和 $[c,d]$ 的最大左段和 这些都可以用线段树维护。但这样需要每个数都开一颗线段树，空间爆炸。 把数组排序，这样每个数的线段树显然只是由前一个数的线段树把一个点的权值从 $1$ 改为 $-1$ 。可以使用主席树的思想（貌似就是主席树 然后就做完了。复杂度 $O(m \\log^2 n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2000; int n, m; int q[4]; struct Node &#123; int d, id; &#125; a[N]; inline bool cmp(Node x, Node y) &#123; return x.d &lt; y.d; &#125;struct node &#123; int left, right; int sm, lm, rm; node *ch[2]; inline void upd() &#123; sm = ch[0]-&gt;sm + ch[1]-&gt;sm; lm = max(ch[0]-&gt;lm, ch[0]-&gt;sm + ch[1]-&gt;lm); rm = max(ch[1]-&gt;rm, ch[1]-&gt;sm + ch[0]-&gt;rm); &#125;&#125; *rt[N], pool[N * 50], *cur = pool, *ans; inline void B (node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;sm = r-&gt;lm = r-&gt;rm = 1; return ; &#125; node *lson = cur++, *rson = cur++; int mid = (left + right) &gt;&gt; 1; r-&gt;ch[0] = lson, r-&gt;ch[1] = rson; B(lson, left, mid), B(rson, mid + 1, right); r-&gt;upd(); &#125;inline void I (node *pre, node *now, int pos) &#123; now-&gt;left = pre-&gt;left, now-&gt;right = pre-&gt;right; if(now-&gt;left == now-&gt;right) &#123; now-&gt;sm = now-&gt;lm = now-&gt;rm = -1; return ; &#125; int mid = (pre-&gt;left + pre-&gt;right) &gt;&gt; 1; if(pos &lt;= mid) now-&gt;ch[1] = pre-&gt;ch[1], I(pre-&gt;ch[0], now-&gt;ch[0] = cur++, pos); if(pos &gt; mid) now-&gt;ch[0] = pre-&gt;ch[0], I(pre-&gt;ch[1], now-&gt;ch[1] = cur++, pos); now-&gt;upd(); &#125;inline node* Q (node *now, int l, int r) &#123; if(now-&gt;left == l &amp;&amp; now-&gt;right == r) return now; if(now-&gt;ch[0]-&gt;right &gt;= r) return Q(now-&gt;ch[0], l, r); else if(now-&gt;ch[1]-&gt;left &lt;= l) return Q(now-&gt;ch[1], l, r); else &#123; node *ret = cur++, *L, *R; L = Q(now-&gt;ch[0], l, now-&gt;ch[0]-&gt;right); R = Q(now-&gt;ch[1], now-&gt;ch[1]-&gt;left, r); ret-&gt;sm = L-&gt;sm + R-&gt;sm; ret-&gt;lm = max(L-&gt;lm, L-&gt;sm + R-&gt;lm); ret-&gt;rm = max(R-&gt;rm, R-&gt;sm + L-&gt;rm); return ret; &#125;&#125;inline bool check(int id) &#123; int sum = 0; if(q[2] + 1 &lt;= q[3] - 1) sum += Q (rt[id - 1], q[2] + 1, q[3] - 1)-&gt;sm; sum += Q (rt[id - 1], q[1], q[2])-&gt;rm; sum += Q (rt[id - 1], q[3], q[4])-&gt;lm; return sum &gt;= 0; &#125;int main() &#123; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i].d); a[i].id = i; &#125; sort(a + 1, a + n + 1, cmp); B(rt[0] = cur++, 1, n); for(int i = 1; i &lt;= n; i++) &#123; rt[i] = cur++; I(rt[i - 1], rt[i], a[i].id); &#125; int ans = 0; scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf(\"%d\", &amp;q[j]), q[j] += ans, q[j] %= n; q[j]++; &#125; sort(q + 1, q + 4 + 1); int l = 1, r = n; while(l &lt;= r) &#123; int mid = (l + r) / 2; if(check(mid)) l = mid + 1, ans = a[mid].d; else r = mid - 1; &#125; printf(\"%d\\n\", ans); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/主席树/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/二分/"}]},{"title":"LOJ2174 「FJOI2016」神秘数","slug":"LOJ2174","date":"2019-01-17T08:32:40.000Z","updated":"2019-01-17T13:49:08.370Z","comments":true,"path":"2019/01/17/LOJ2174/","link":"","permalink":"http://yoursite.com/2019/01/17/LOJ2174/","excerpt":"Description$n$ 个数的序列，每次询问一个区间，求最小的一个数使得不能用这个区间中的数之和表示。 $n \\leq 10^5, \\sum a_i \\leq 10^9$","text":"Description$n$ 个数的序列，每次询问一个区间，求最小的一个数使得不能用这个区间中的数之和表示。 $n \\leq 10^5, \\sum a_i \\leq 10^9$ Solution第一次用数组写数据结构真短啊 考虑只有一次询问怎么做 把给定的区间内的数排序，从小到大扫一遍。 如果一个数比他之前的数之和至少大了 $1$ ，那么答案就是和 + 1 否则就可以把$[1,\\text{前缀和}]$ 都表示出来（感性理解很容易） 这道题怎么做也就显然了起来。只需要用主席树维护区间中小于等于某个数的数之和即可。流程如下 当前答案是 $a$，令 $S$ 是区间中 $\\leq a$ 的数之和 如果 $S &lt; a$ 则 $a$ 就是最后的答案 否则 让 $a = S+1$ 然后重复此操作 最开始的时候 $a=1$ 这样做的话 $a$ 每次都会翻一倍，所以最后的总复杂度是 $O(m \\log n \\log \\sum a_i)$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 50000500; const int L = 1000000000; int n, m, a[N], cnt; int root[N], ch[N][2]; ll sum[N]; inline void I (int pre, int now, int l, int r, int val) &#123; ch[now][0] = ch[pre][0], ch[now][1] = ch[pre][1]; int mid = (l + r) &gt;&gt; 1; sum[now] = sum[pre] + val; if(l == r) return ; if(val &lt;= mid) ch[now][0] = ++cnt, I(ch[pre][0], ch[now][0], l, mid, val); else ch[now][1] = ++cnt, I(ch[pre][1], ch[now][1], mid + 1, r, val); &#125;inline int Q(int pre, int now, int l, int r, int val) &#123; if(l == r) return sum[now] - sum[pre]; int mid = (l + r) / 2; if(val &lt;= mid) return Q(ch[pre][0], ch[now][0], l, mid, val); else return sum[ch[now][0]] - sum[ch[pre][0]] + Q(ch[pre][1], ch[now][1], mid + 1, r, val); &#125;int main() &#123; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); root[i] = ++cnt; I(root[i - 1], root[i], 1, L, a[i]); &#125; scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int l, r; scanf(\"%d %d\", &amp;l, &amp;r); int ans = 1; int S; while(1) &#123; S = Q(root[l - 1], root[r], 1, L, ans); if(S &lt; ans) &#123; printf(\"%d\\n\", ans); break ; &#125; else ans = S + 1; &#125; &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/主席树/"}]},{"title":"BZOJ3529 「SDOI2014」数表","slug":"bzoj3529","date":"2019-01-14T12:42:52.000Z","updated":"2019-01-20T05:28:09.946Z","comments":true,"path":"2019/01/14/bzoj3529/","link":"","permalink":"http://yoursite.com/2019/01/14/bzoj3529/","excerpt":"Description$T$ 组询问，定义 $F(n)=\\sum\\limits_{d|n}d$。每次给出 $n,m,a$ 求 \\sum\\limits_{i=1,j=1,F(\\gcd(i,j)) \\leq a}^{i\\leq n, j \\leq m} F (\\gcd(i,j))$T \\leq 20000;n,m,a\\leq 10^5$","text":"Description$T$ 组询问，定义 $F(n)=\\sum\\limits_{d|n}d$。每次给出 $n,m,a$ 求 \\sum\\limits_{i=1,j=1,F(\\gcd(i,j)) \\leq a}^{i\\leq n, j \\leq m} F (\\gcd(i,j))$T \\leq 20000;n,m,a\\leq 10^5$ Solution首先 $F$ 可以直接暴力地 $O(n \\log n)$ 筛出来。 考虑 $a$ 的限制不是很好处理，假设没有这个 $a$ 的限制，则所求为 \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m} F (\\gcd(i,j))令 $G(i)=\\sum\\limits_{x=1}^{n}\\sum\\limits_{y=1}^{m}[\\gcd(x,y)=i]$。这个东西是什么呢？在 这里 有它的推导过程。根据里面的过程，可以得到 $G(i) = \\sum\\limits_{d=1}^{\\lfloor\\frac{n}{i}\\rfloor}\\mu(d)\\lfloor\\frac{n}{id}\\rfloor\\lfloor\\frac{m}{id}\\rfloor$（默认 $n \\leq m$）令下面的过程中$t = id$，则所求的是 \\sum\\limits_{i=1}^{n}F(i)G(i)= \\sum\\limits_{i=1}^{n}F(i)\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{i}\\rfloor}\\mu(d)\\lfloor\\frac{n}{id}\\rfloor\\lfloor\\frac{m}{id}\\rfloor=\\sum\\limits_{i=1}^{n}F(i)\\sum\\limits_{i | t}\\mu(\\frac{t}{i})\\lfloor\\frac{n}{t}\\rfloor\\lfloor\\frac{m}{t}\\rfloor=\\sum\\limits_{t=1}^{n}\\lfloor\\frac{n}{t}\\rfloor\\lfloor\\frac{m}{t}\\rfloor\\sum\\limits_{i | t}F(i)\\mu(\\frac{t}{i})观察后面的式子，正好是一个狄利克雷卷积的形式。这种样子的都可以类似于那种 $O(n \\log n)$ 地质数筛法在调和级数内求出来，再结合分块就可以做完这个没有 $a$ 的题。 现在有了 $a$ 的限制之后，离线。把询问按照 $a$ 从小到大排序，然后按照 $F(i)$ 从小到大加入。每当有一个新的 $a$ ，就可以移动指针，将一些 $F$ 用处理 $\\sum\\limits_{i | t}F(i)\\mu(\\frac{t}{i})$ 的方式加入到这个里面。然后加入完之后用分块计算就行。 现在需要维护单点操作，查询前缀和，树状数组是不错的选择。 由于取模是 $2^{32} - 1$ ，可以直接 int 自然溢出最后和 $2147483647$ 取一个 &amp; 就行了。 时间复杂度：$O(n + n \\log n + n \\log ^ 2 (n) + T \\log (n)\\sqrt n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000; int T, cnt, flag[N + 5], p[N + 5], F[N + 5], mu[N + 5], ans[N + 5]; inline void prework() &#123; flag[1] = mu[1] = 1; for(int i = 2; i &lt;= N; i++) &#123; if(!flag[i]) &#123; p[++cnt] = i, mu[i] = -1; &#125; for(int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= N; j++) &#123; flag[i * p[j]] = 1; if(i % p[j] == 0) &#123; mu[i * p[j]] = 0; break ; &#125; mu[i * p[j]] = mu[i] * -1; &#125; &#125; for(int i = 1; i &lt;= N; i++) for(int j = i; j &lt;= N; j += i) F[j] += i;&#125;int c[N + 5]; inline int lb(int x) &#123; return x &amp; (-x); &#125;inline void add(int x, int d) &#123; for(int i = x; i &lt;= N; i += lb(i)) c[i] += d; &#125;inline int sum(int x) &#123; int ret = 0; for(int i = x; i; i -= lb(i)) ret += c[i]; return ret; &#125;inline int calc(int n, int m) &#123; int ret = 0; for(int l = 1, r; l &lt;= min(n, m); l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ret += (n / l) * (m / l) * (sum(r) - sum(l - 1)); &#125; return ret; &#125;struct Query &#123; int n, m, a, id; inline bool operator &lt; (const Query &amp;x) const &#123; return a &lt; x.a; &#125;&#125;Q[N + 5]; struct node &#123; int id, d; inline bool operator &lt; (const node &amp;x) const &#123; return d &lt; x.d; &#125;&#125;A[N + 5]; int main() &#123; prework(); scanf(\"%d\", &amp;T); for(int i = 1; i &lt;= T; i++) scanf(\"%d %d %d\", &amp;Q[i].n, &amp;Q[i].m, &amp;Q[i].a), Q[i].id = i; for(int i = 1; i &lt;= N; i++) A[i].d = F[i], A[i].id = i; sort(Q + 1, Q + T + 1); sort(A + 1, A + N + 1); int pos = 0; for(int i = 1; i &lt;= T; i++) &#123; while(pos &lt; N &amp;&amp; A[pos + 1].d &lt;= Q[i].a) &#123; ++pos; for(int j = 1; A[pos].id * j &lt;= N; j++) add(j * A[pos].id, A[pos].d * mu[j]); &#125; ans[Q[i].id] = calc(Q[i].n, Q[i].m); &#125; for(int i = 1; i &lt;= T; i++) printf(\"%d\\n\", ans[i] &amp; 2147483647); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"},{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://yoursite.com/tags/莫比乌斯反演/"}]}]}