{"pages":[{"title":"Links","text":"常用 OJ Luogu BZOJ LOJ UOJ CodeForces 友链欢迎交换友链=w= 同学 我的博客园 https://www.cnblogs.com/acfunction Parick Wang https://www.cnblogs.com/newbiepwang 书海扬帆 www.ljhedp.cn 大佬 Siyuan小姐姐 Orz https://hydingsy.github.io/ memset0 大佬 Orz https://memset0.cn/","link":"/Links/index.html"}],"posts":[{"title":"BZOJ3529 「SDOI2014」数表","text":"Description$T$ 组询问，定义 $F(n)=\\sum\\limits_{d|n}d$。每次给出 $n,m,a$ 求 $$\\sum\\limits_{i=1,j=1,F(\\gcd(i,j)) \\leq a}^{i\\leq n, j \\leq m} F (\\gcd(i,j))$$ $T \\leq 20000;n,m,a\\leq 10^5$ Solution首先 $F$ 可以直接暴力地 $O(n \\log n)$ 筛出来。 考虑 $a$ 的限制不是很好处理，假设没有这个 $a$ 的限制，则所求为 $$\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m} F (\\gcd(i,j))$$ 令 $G(i)=\\sum\\limits_{x=1}^{n}\\sum\\limits_{y=1}^{m}[\\gcd(x,y)=i]$。这个东西是什么呢？在 这里 有它的推导过程。根据里面的过程，可以得到 $G(i) = \\sum\\limits_{d=1}^{\\lfloor\\frac{n}{i}\\rfloor}\\mu(d)\\lfloor\\frac{n}{id}\\rfloor\\lfloor\\frac{m}{id}\\rfloor$（默认 $n \\leq m$）令下面的过程中$t = id$，则所求的是 $$\\sum\\limits_{i=1}^{n}F(i)G(i)$$ $$= \\sum\\limits_{i=1}^{n}F(i)\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{i}\\rfloor}\\mu(d)\\lfloor\\frac{n}{id}\\rfloor\\lfloor\\frac{m}{id}\\rfloor $$ $$=\\sum\\limits_{i=1}^{n}F(i)\\sum\\limits_{i | t}\\mu(\\frac{t}{i})\\lfloor\\frac{n}{t}\\rfloor\\lfloor\\frac{m}{t}\\rfloor$$ $$=\\sum\\limits_{t=1}^{n}\\lfloor\\frac{n}{t}\\rfloor\\lfloor\\frac{m}{t}\\rfloor\\sum\\limits_{i | t}F(i)\\mu(\\frac{t}{i})$$ 观察后面的式子，正好是一个狄利克雷卷积的形式。这种样子的都可以类似于那种 $O(n \\log n)$ 地质数筛法在调和级数内求出来，再结合分块就可以做完这个没有 $a$ 的题。 现在有了 $a$ 的限制之后，离线。把询问按照 $a$ 从小到大排序，然后按照 $F(i)$ 从小到大加入。每当有一个新的 $a$ ，就可以移动指针，将一些 $F$ 用处理 $\\sum\\limits_{i | t}F(i)\\mu(\\frac{t}{i})$ 的方式加入到这个里面。然后加入完之后用分块计算就行。 现在需要维护单点操作，查询前缀和，树状数组是不错的选择。 由于取模是 $2^{32} - 1$ ，可以直接 int 自然溢出最后和 $2147483647$ 取一个 &amp; 就行了。 时间复杂度：$O(n + n \\log n + n \\log ^ 2 (n) + T \\log (n)\\sqrt n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000; int T, cnt, flag[N + 5], p[N + 5], F[N + 5], mu[N + 5], ans[N + 5]; inline void prework() { flag[1] = mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!flag[i]) { p[++cnt] = i, mu[i] = -1; } for(int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= N; j++) { flag[i * p[j]] = 1; if(i % p[j] == 0) { mu[i * p[j]] = 0; break ; } mu[i * p[j]] = mu[i] * -1; } } for(int i = 1; i &lt;= N; i++) for(int j = i; j &lt;= N; j += i) F[j] += i;}int c[N + 5]; inline int lb(int x) { return x &amp; (-x); }inline void add(int x, int d) { for(int i = x; i &lt;= N; i += lb(i)) c[i] += d; }inline int sum(int x) { int ret = 0; for(int i = x; i; i -= lb(i)) ret += c[i]; return ret; }inline int calc(int n, int m) { int ret = 0; for(int l = 1, r; l &lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); ret += (n / l) * (m / l) * (sum(r) - sum(l - 1)); } return ret; }struct Query { int n, m, a, id; inline bool operator &lt; (const Query &amp;x) const { return a &lt; x.a; }}Q[N + 5]; struct node { int id, d; inline bool operator &lt; (const node &amp;x) const { return d &lt; x.d; }}A[N + 5]; int main() { prework(); scanf(\"%d\", &amp;T); for(int i = 1; i &lt;= T; i++) scanf(\"%d %d %d\", &amp;Q[i].n, &amp;Q[i].m, &amp;Q[i].a), Q[i].id = i; for(int i = 1; i &lt;= N; i++) A[i].d = F[i], A[i].id = i; sort(Q + 1, Q + T + 1); sort(A + 1, A + N + 1); int pos = 0; for(int i = 1; i &lt;= T; i++) { while(pos &lt; N &amp;&amp; A[pos + 1].d &lt;= Q[i].a) { ++pos; for(int j = 1; A[pos].id * j &lt;= N; j++) add(j * A[pos].id, A[pos].d * mu[j]); } ans[Q[i].id] = calc(Q[i].n, Q[i].m); } for(int i = 1; i &lt;= T; i++) printf(\"%d\\n\", ans[i] &amp; 2147483647); return 0; }","link":"/2019/01/14/BZOJ3529/"},{"title":"BZOJ2653 middle","text":"Description给你一个序列，每次询问给出四个数 $a,b,c,d$，求所有区间 $[l,r]$ 满足 $l \\in [a,b], r \\in [c,d]$ 的中位数的最大值。强制在线 $n \\leq 20000, Q \\leq 25000,a_i \\leq 10^9$ Solution考虑二分答案。假设现在二分出来的是 $x$ ，那么把 $\\ge x$ 的位置设成 $1$ ，$&lt; x$ 的设为 $-1$ 。那么一个区间的中位数 $\\ge x$ 等价于这个区间的和 $\\ge 0$ 如何处理题目给的左右端点的限制？ 可以发现 $[l,r]$ 必然包含 $[b+1,c-1]$ (如果 $b+1 \\leq c+1$ 的话）所以 $[l, r]$ 的和必然包含 $[b+1, c-1]$ 的和 显然让 $[l,r]$ 的和最大的方案是取 $[a,b]$ 的最大右段和 和 $[c,d]$ 的最大左段和 这些都可以用线段树维护。但这样需要每个数都开一颗线段树，空间爆炸。 把数组排序，这样每个数的线段树显然只是由前一个数的线段树把一个点的权值从 $1$ 改为 $-1$ 。可以使用主席树的思想（貌似就是主席树 然后就做完了。复杂度 $O(m \\log^2 n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2000; int n, m; int q[4]; struct Node { int d, id; } a[N]; inline bool cmp(Node x, Node y) { return x.d &lt; y.d; }struct node { int left, right; int sm, lm, rm; node *ch[2]; inline void upd() { sm = ch[0]-&gt;sm + ch[1]-&gt;sm; lm = max(ch[0]-&gt;lm, ch[0]-&gt;sm + ch[1]-&gt;lm); rm = max(ch[1]-&gt;rm, ch[1]-&gt;sm + ch[0]-&gt;rm); }} *rt[N], pool[N * 50], *cur = pool, *ans; inline void B (node *r, int left, int right) { r-&gt;left = left, r-&gt;right = right; if(left == right) { r-&gt;sm = r-&gt;lm = r-&gt;rm = 1; return ; } node *lson = cur++, *rson = cur++; int mid = (left + right) &gt;&gt; 1; r-&gt;ch[0] = lson, r-&gt;ch[1] = rson; B(lson, left, mid), B(rson, mid + 1, right); r-&gt;upd(); }inline void I (node *pre, node *now, int pos) { now-&gt;left = pre-&gt;left, now-&gt;right = pre-&gt;right; if(now-&gt;left == now-&gt;right) { now-&gt;sm = now-&gt;lm = now-&gt;rm = -1; return ; } int mid = (pre-&gt;left + pre-&gt;right) &gt;&gt; 1; if(pos &lt;= mid) now-&gt;ch[1] = pre-&gt;ch[1], I(pre-&gt;ch[0], now-&gt;ch[0] = cur++, pos); if(pos &gt; mid) now-&gt;ch[0] = pre-&gt;ch[0], I(pre-&gt;ch[1], now-&gt;ch[1] = cur++, pos); now-&gt;upd(); }inline node* Q (node *now, int l, int r) { if(now-&gt;left == l &amp;&amp; now-&gt;right == r) return now; if(now-&gt;ch[0]-&gt;right &gt;= r) return Q(now-&gt;ch[0], l, r); else if(now-&gt;ch[1]-&gt;left &lt;= l) return Q(now-&gt;ch[1], l, r); else { node *ret = cur++, *L, *R; L = Q(now-&gt;ch[0], l, now-&gt;ch[0]-&gt;right); R = Q(now-&gt;ch[1], now-&gt;ch[1]-&gt;left, r); ret-&gt;sm = L-&gt;sm + R-&gt;sm; ret-&gt;lm = max(L-&gt;lm, L-&gt;sm + R-&gt;lm); ret-&gt;rm = max(R-&gt;rm, R-&gt;sm + L-&gt;rm); return ret; }}inline bool check(int id) { int sum = 0; if(q[2] + 1 &lt;= q[3] - 1) sum += Q (rt[id - 1], q[2] + 1, q[3] - 1)-&gt;sm; sum += Q (rt[id - 1], q[1], q[2])-&gt;rm; sum += Q (rt[id - 1], q[3], q[4])-&gt;lm; return sum &gt;= 0; }int main() { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i].d); a[i].id = i; } sort(a + 1, a + n + 1, cmp); B(rt[0] = cur++, 1, n); for(int i = 1; i &lt;= n; i++) { rt[i] = cur++; I(rt[i - 1], rt[i], a[i].id); } int ans = 0; scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) { for(int j = 1; j &lt;= 4; j++) { scanf(\"%d\", &amp;q[j]), q[j] += ans, q[j] %= n; q[j]++; } sort(q + 1, q + 4 + 1); int l = 1, r = n; while(l &lt;= r) { int mid = (l + r) / 2; if(check(mid)) l = mid + 1, ans = a[mid].d; else r = mid - 1; } printf(\"%d\\n\", ans); } return 0; }","link":"/2019/01/20/BZOJ2653/"},{"title":"LOJ2174 「FJOI2016」神秘数","text":"Description$n$ 个数的序列，每次询问一个区间，求最小的一个数使得不能用这个区间中的数之和表示。 $n \\leq 10^5, \\sum a_i \\leq 10^9$ Solution第一次用数组写数据结构真短啊 考虑只有一次询问怎么做 把给定的区间内的数排序，从小到大扫一遍。 如果一个数比他之前的数之和至少大了 $1$ ，那么答案就是和 + 1 否则就可以把$[1,\\text{前缀和}]$ 都表示出来（感性理解很容易） 这道题怎么做也就显然了起来。只需要用主席树维护区间中小于等于某个数的数之和即可。流程如下 当前答案是 $a$，令 $S$ 是区间中 $\\leq a$ 的数之和 如果 $S &lt; a$ 则 $a$ 就是最后的答案 否则 让 $a = S+1$ 然后重复此操作 最开始的时候 $a=1$ 这样做的话 $a$ 每次都会翻一倍，所以最后的总复杂度是 $O(m \\log n \\log \\sum a_i)$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 50000500; const int L = 1000000000; int n, m, a[N], cnt; int root[N], ch[N][2]; ll sum[N]; inline void I (int pre, int now, int l, int r, int val) { ch[now][0] = ch[pre][0], ch[now][1] = ch[pre][1]; int mid = (l + r) &gt;&gt; 1; sum[now] = sum[pre] + val; if(l == r) return ; if(val &lt;= mid) ch[now][0] = ++cnt, I(ch[pre][0], ch[now][0], l, mid, val); else ch[now][1] = ++cnt, I(ch[pre][1], ch[now][1], mid + 1, r, val); }inline int Q(int pre, int now, int l, int r, int val) { if(l == r) return sum[now] - sum[pre]; int mid = (l + r) / 2; if(val &lt;= mid) return Q(ch[pre][0], ch[now][0], l, mid, val); else return sum[ch[now][0]] - sum[ch[pre][0]] + Q(ch[pre][1], ch[now][1], mid + 1, r, val); }int main() { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); root[i] = ++cnt; I(root[i - 1], root[i], 1, L, a[i]); } scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) { int l, r; scanf(\"%d %d\", &amp;l, &amp;r); int ans = 1; int S; while(1) { S = Q(root[l - 1], root[r], 1, L, ans); if(S &lt; ans) { printf(\"%d\\n\", ans); break ; } else ans = S + 1; } } return 0; }","link":"/2019/01/17/LOJ2174/"}],"tags":[{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/莫比乌斯反演/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"主席树, 二分","slug":"主席树-二分","link":"/tags/主席树-二分/"},{"name":"主席树","slug":"主席树","link":"/tags/主席树/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"}]}