{"pages":[{"title":"友链","text":"常用 OJ Luogu | BZOJ | LOJ | UOJ | CodeForces | AtCoder | CodeChef 常用网站Github | Graph Editor | OEIS | OIerDb 友链欢迎交换友链=w= 同学 我的博客园 https://www.cnblogs.com/acfunction Parick Wang https://tle666.github.io 书海扬帆 www.ljhedp.cn 大佬 Siyuan 小姐姐 Orz https://hydingsy.github.io/ memset0 巨佬 Orz https://memset0.cn/ lmy 神仙 Orz https://www.cnblogs.com/LiM-817/","link":"/Links/index.html"}],"posts":[{"title":"BZOJ2653 middle","text":"Description给你一个序列，每次询问给出四个数 $a,b,c,d$，求所有区间 $[l,r]$ 满足 $l \\in [a,b], r \\in [c,d]$ 的中位数的最大值。强制在线。 $n \\leq 20000, Q \\leq 25000,a_i \\leq 10^9$ Solution考虑二分答案。假设现在二分出来的是 $x$ ，那么把 $\\ge x$ 的位置设成 $1$ ，$&lt; x$ 的设为 $-1$ 。那么一个区间的中位数 $\\ge x$ 等价于这个区间的和 $\\ge 0$ 如何处理题目给的左右端点的限制？ 可以发现 $[l,r]$ 必然包含 $[b+1,c-1]$ (如果 $b+1 \\leq c+1$ 的话）所以 $[l, r]$ 的和必然包含 $[b+1, c-1]$ 的和 显然让 $[l,r]$ 的和最大的方案是取 $[a,b]$ 的最大右段和 和 $[c,d]$ 的最大左段和 这些都可以用线段树维护。但这样需要每个数都开一颗线段树，空间爆炸。 把数组排序，这样每个数的线段树显然只是由前一个数的线段树把一个点的权值从 $1$ 改为 $-1$ 。可以使用主席树的思想（貌似就是主席树 然后就做完了。复杂度 $O(m \\log^2 n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2000; int n, m; int q[4]; struct Node { int d, id; } a[N]; inline bool cmp(Node x, Node y) { return x.d &lt; y.d; }struct node { int left, right; int sm, lm, rm; node *ch[2]; inline void upd() { sm = ch[0]-&gt;sm + ch[1]-&gt;sm; lm = max(ch[0]-&gt;lm, ch[0]-&gt;sm + ch[1]-&gt;lm); rm = max(ch[1]-&gt;rm, ch[1]-&gt;sm + ch[0]-&gt;rm); }} *rt[N], pool[N * 50], *cur = pool, *ans; inline void B (node *r, int left, int right) { r-&gt;left = left, r-&gt;right = right; if(left == right) { r-&gt;sm = r-&gt;lm = r-&gt;rm = 1; return ; } node *lson = cur++, *rson = cur++; int mid = (left + right) &gt;&gt; 1; r-&gt;ch[0] = lson, r-&gt;ch[1] = rson; B(lson, left, mid), B(rson, mid + 1, right); r-&gt;upd(); }inline void I (node *pre, node *now, int pos) { now-&gt;left = pre-&gt;left, now-&gt;right = pre-&gt;right; if(now-&gt;left == now-&gt;right) { now-&gt;sm = now-&gt;lm = now-&gt;rm = -1; return ; } int mid = (pre-&gt;left + pre-&gt;right) &gt;&gt; 1; if(pos &lt;= mid) now-&gt;ch[1] = pre-&gt;ch[1], I(pre-&gt;ch[0], now-&gt;ch[0] = cur++, pos); if(pos &gt; mid) now-&gt;ch[0] = pre-&gt;ch[0], I(pre-&gt;ch[1], now-&gt;ch[1] = cur++, pos); now-&gt;upd(); }inline node* Q (node *now, int l, int r) { if(now-&gt;left == l &amp;&amp; now-&gt;right == r) return now; if(now-&gt;ch[0]-&gt;right &gt;= r) return Q(now-&gt;ch[0], l, r); else if(now-&gt;ch[1]-&gt;left &lt;= l) return Q(now-&gt;ch[1], l, r); else { node *ret = cur++, *L, *R; L = Q(now-&gt;ch[0], l, now-&gt;ch[0]-&gt;right); R = Q(now-&gt;ch[1], now-&gt;ch[1]-&gt;left, r); ret-&gt;sm = L-&gt;sm + R-&gt;sm; ret-&gt;lm = max(L-&gt;lm, L-&gt;sm + R-&gt;lm); ret-&gt;rm = max(R-&gt;rm, R-&gt;sm + L-&gt;rm); return ret; }}inline bool check(int id) { int sum = 0; if(q[2] + 1 &lt;= q[3] - 1) sum += Q (rt[id - 1], q[2] + 1, q[3] - 1)-&gt;sm; sum += Q (rt[id - 1], q[1], q[2])-&gt;rm; sum += Q (rt[id - 1], q[3], q[4])-&gt;lm; return sum &gt;= 0; }int main() { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i].d); a[i].id = i; } sort(a + 1, a + n + 1, cmp); B(rt[0] = cur++, 1, n); for(int i = 1; i &lt;= n; i++) { rt[i] = cur++; I(rt[i - 1], rt[i], a[i].id); } int ans = 0; scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) { for(int j = 1; j &lt;= 4; j++) { scanf(\"%d\", &amp;q[j]), q[j] += ans, q[j] %= n; q[j]++; } sort(q + 1, q + 4 + 1); int l = 1, r = n; while(l &lt;= r) { int mid = (l + r) / 2; if(check(mid)) l = mid + 1, ans = a[mid].d; else r = mid - 1; } printf(\"%d\\n\", ans); } return 0; }","link":"/2019/01/20/BZOJ2653/"},{"title":"CF1110F Nearest Leaf","text":"Description给你一颗满足编号 = dfs 序的带边权的有根树。$m$ 次询问，每次给出 $v,l,r$ 求编号在 $[l,r]$ 中的叶子到 $v$ 节点的最短距离 $n,m \\leq 5\\times10^5,w \\leq 10^9$ Solution如果我们知道 $u$ 节点到所有叶子的最短路，如何求出他的某一个儿子 $v$ 到所有叶子的最短路呢？ 不妨设 $(u,v)$ 的边权是 $w$ 。那么在 $v$ 这颗子树内的叶子到 $v$ 的距离较 $u$ 要减少 $w$ ； $v$ 这颗子树外的叶子到 $v$ 的距离较 $u$ 要增加 $w$ 。 又良心出题人给的树是满足那个性质的，所以子树内的编号是连续的。 所以最开始 dfs 一遍。求出每个点到根的距离。把询问离线，进行一次先序遍历。 每次进入到一颗子树，就用线段树把该子树内的叶子减少 w 外面的增加 w 当回溯的父亲的时候，就用线段树把该子树内的叶子增加 w 外面的减少 w 然后遍历到一个节点就把和他有关的询问全都用线段树里的信息处理掉就行了 Code我的实现貌似有点麻烦…我直接用线段树维护叶子，所以每次给出的左右端点还要在叶子序列里二分一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;#define ll long long#define PI pair#define Fi first#define Se second#define MP make_pair#define INF 1000000000000000000using namespace std;const int N = 500500; int n, m, siz[N]; ll dis[N], ans[N];vector &lt;int&gt; lea; struct edge { int v; ll w; edge *next; } pol[N * 2], *head[N], *cu = pol;inline void addedge(int u, int v, ll w) { edge *p = cu++, *q = cu++; p-&gt;v = v, p-&gt;w = w, p-&gt;next = head[u], head[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = head[v], head[v] = q; }inline void dfs(int u, int pre) { siz[u] = 1; bool fla = 1; for(edge *p = head[u]; p; p = p-&gt;next) { int v = p-&gt;v; if(v == pre) continue ; fla = 0; dis[v] = dis[u] + p-&gt;w; dfs(v, u); siz[u] += siz[v]; } if(fla) lea.push_back(u); }struct ST { int l, r; ll tag, mn; ST *ch[2]; inline void seta(ll d) { tag += d; mn += d; } inline void upd() { mn = min(ch[0]-&gt;mn, ch[1]-&gt;mn); } inline void push() { if(tag) { if(ch[0]) ch[0]-&gt;seta(tag); if(ch[1]) ch[1]-&gt;seta(tag); tag = 0; } }} pool[N * 2], *cur = pool, *rt; inline void build(ST *p, int l, int r) { p-&gt;l = l, p-&gt;r = r; if(l == r) { p-&gt;mn = dis[lea[l - 1]]; return ; } ST *ls = cur++, *rs = cur++; p-&gt;ch[0] = ls, p-&gt;ch[1] = rs; int mid = (l + r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); p-&gt;upd(); }inline void modify(ST *p, int l, int r, ll d) { if(l &gt; r) return ; if(p-&gt;l == l &amp;&amp; p-&gt;r == r) return p-&gt;seta(d); p-&gt;push(); if(p-&gt;ch[0]-&gt;r &gt;= r) modify(p-&gt;ch[0], l, r, d); else if(p-&gt;ch[1]-&gt;l &lt;= l) modify(p-&gt;ch[1], l, r, d); else modify(p-&gt;ch[0], l, p-&gt;ch[0]-&gt;r, d), modify(p-&gt;ch[1], p-&gt;ch[1]-&gt;l, r, d); p-&gt;upd(); }inline ll Qmin(ST *p, int l, int r) { if(l &gt; r) return INF; p-&gt;push(); if(p-&gt;l == l &amp;&amp; p-&gt;r == r) return p-&gt;mn; if(p-&gt;ch[0]-&gt;r &gt;= r) return Qmin(p-&gt;ch[0], l, r); else if(p-&gt;ch[1]-&gt;l &lt;= l) return Qmin(p-&gt;ch[1], l, r); else return min(Qmin(p-&gt;ch[0], l, p-&gt;ch[0]-&gt;r), Qmin(p-&gt;ch[1], p-&gt;ch[1]-&gt;l, r)); }vector &lt; PI &lt;int, PI &lt;int, int&gt; &gt; &gt; Q[N]; // emm 我还不太会用 lower_bound / upper_bound 所以就只能手写了..inline int up(int x) { int l = 0, r = n - 1, ret = 0; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(lea[mid] &lt;= x) l = mid + 1, ret = mid; else r = mid - 1; } return ret + 1; }inline int lw(int x) { int l = 0, r = n - 1, ret = n - 1; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(lea[mid] &gt;= x) r = mid - 1, ret = mid; else l = mid + 1; } return ret + 1; }inline void solve(int u, int pre) { for(int i = 0; i &lt; Q[u].size(); i++) { int id = Q[u][i].Fi; int l = Q[u][i].Se.Fi; int r = Q[u][i].Se.Se; // printf(\"***%d %d %d\\n\", id, up(l), lw(r)); ans[id] = Qmin(rt, lw(l), up(r)); } for(edge *p = head[u]; p; p = p-&gt;next) { int v = p-&gt;v; if(v == pre) continue ; int L = lw(v), R = up(v + siz[v] - 1); ll w = p-&gt;w; // printf(\"%d %d %d\\n\", v, L, R); modify(rt, L, R, -w); modify(rt, 1, L - 1, w); modify(rt, R + 1, n, w); solve(v, u); modify(rt, L, R, w); modify(rt, 1, L - 1, -w); modify(rt, R + 1, n, -w); }}int main() { scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 2; i &lt;= n; i++) { int p; ll w; scanf(\"%d %lld\", &amp;p, &amp;w); addedge(p, i, w); } dfs(1, 0); n = lea.size(); sort(lea.begin(), lea.end()); build(rt = cur++, 1, n); for(int i = 1; i &lt;= m; i++) { int v, l, r; scanf(\"%d %d %d\", &amp;v, &amp;l, &amp;r); Q[v].push_back(MP(i, MP(l, r))); } solve(1, 0); for(int i = 1; i &lt;= m; i++) printf(\"%lld\\n\", ans[i]); return 0; }","link":"/2019/02/09/CF1110F/"},{"title":"CF757F Team Rocket Rises Again","text":"Description一个 $n$ 个点 $m$ 条边的无向图，给出起点 $S$ 。求删除掉一个不是 $S$ 的点后最多能改变多少个点到 $S$ 的最短路。输出这个最大值。 $n \\leq 200000, m \\leq \\min(\\frac{n(n-1)}{2},300000)$ Solution在飞机上写的题解 2333 定义 $d_u$ 是 $S$ 到 $u$ 的最短路；最短路 DAG 为所有有向边 $(u,v)$ 满足 $d_u+w(u,v)=d_v$ 组成的 DAG . 那么显然删这个 DAG 上的点才是对答案有贡献的。 考虑如何求出删完一个点会使得有多少个点的最短路有改变。 把这个 DAG 的支配树建出来然后对于一个点它在支配树上的子树大小就是答案。 注：支配树是啥？ 在一个有向图中有一个节点是 $S$ ；对于节点 $u$ 从 $S$ 到 $u$ 上的路径必到的点称之为 $u$ 的支配点 对于每一个 $u$ ，从离他最近的一个点向他连一条边。这些边组成的便是原图的支配树。其中 $S$ 为根节点 对于一个 DAG 如何建出他的支配树？即对于一个点怎么求出离他最近的支配点？ 可以考虑用拓扑排序的顺序更新。对于节点 $u$ ，它的所有前驱在支配树上的 LCA便是它在支配树上的父亲；即离他最近的支配点。 这个过程需要维护的就是 加点 和 维护 LCA 。可以用倍增用 $O(n \\log n)$ 的时间复杂度解决 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long // don't think I use int ! const int N = 300300; const int INF = (int)4e18; int n, m, S, dis[N], U[N], V[N], W[N], ind[N], fa[N][25], dep[N], siz[N]; vector &lt;int&gt; g[N]; struct edge { int v, w; edge *next; } *h1[N], *h2[N], *h3[N], pool[N * 6], *cur = pool; inline void add1(int u, int v, int w) { edge *p = cur++; p-&gt;w = w; p-&gt;v = v, p-&gt;next = h1[u], h1[u] = p; }inline void add2(int u, int v) { edge *p = cur++; p-&gt;v = v, p-&gt;next = h2[u], h2[u] = p; }inline void add3(int u, int v) { edge *p = cur++; p-&gt;v = v, p-&gt;next = h3[u], h3[u] = p; }inline void add(int x, int f) { fa[x][0] = f; for(int i = 1; i &lt;= 20; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1]; dep[x] = dep[f] + 1; }inline int LCA(int u, int v) { if(dep[u] &lt; dep[v]) swap(u, v); for(int i = 20; i &gt;= 0; i--) if(dep[fa[u][i]] &gt;= dep[v] &amp;&amp; fa[u][i]) u = fa[u][i]; if(u == v) return u; for(int i = 20; i &gt;= 0; i--) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; return fa[u][0]; }struct node { int d, id; inline bool operator &lt; (const node &amp;x) const { return d &gt; x.d; }} tmp; priority_queue &lt;node&gt; Q; inline void dijkstra() { for(int i = 1; i &lt;= n; i++) dis[i] = INF; tmp.id = S, tmp.d = 0; Q.push(tmp); dis[S] = 0; while(!Q.empty()) { tmp = Q.top(); Q.pop(); int u = tmp.id; if(dis[u] &lt; tmp.d) continue ; for(edge *p = h1[u]; p; p = p-&gt;next) { int v = p-&gt;v; if(dis[v] &gt; dis[u] + p-&gt;w) { dis[v] = dis[u] + p-&gt;w; tmp.id = v, tmp.d = dis[v]; Q.push(tmp); } } }}inline void dfs(int u, int pre) { siz[u] = 1; for(edge *p = h3[u]; p; p = p-&gt;next) { int v = p-&gt;v; if(v == pre) continue ; dfs(v, u); siz[u] += siz[v]; }}signed main() { scanf(\"%lld %lld %lld\", &amp;n, &amp;m, &amp;S); for(int i = 1; i &lt;= m; i++) { int u, v, w; scanf(\"%lld %lld %lld\", &amp;u, &amp;v, &amp;w); U[i] = u, V[i] = v, W[i] = w; add1(u, v, w), add1(v, u, w); } dijkstra(); for(int i = 1; i &lt;= m; i++) { if(dis[U[i]] == dis[V[i]] + W[i]) add2(V[i], U[i]), ind[U[i]]++, g[U[i]].push_back(V[i]); if(dis[V[i]] == dis[U[i]] + W[i]) add2(U[i], V[i]), ind[V[i]]++, g[V[i]].push_back(U[i]); } queue &lt;int&gt; Q; Q.push(S); dep[S] = 1; while(!Q.empty()) { int u = Q.front(); Q.pop(); // printf(\"%d\\n\", u); if(g[u].size()) { int lca = g[u][0]; for(int i = 1; i &lt; g[u].size(); i++) { // printf(\"%d\\n\", g[u][i]); lca = LCA(g[u][i], lca); } add(u, lca); add3(lca, u); } for(edge *p = h2[u]; p; p = p-&gt;next) { int v = p-&gt;v; ind[v]--; if(ind[v] == 0) Q.push(v); } } int ans = 0; dfs(S, 0); for(int i = 1; i &lt;= n; i++) if(i != S) ans = max(ans, siz[i]); printf(\"%lld\\n\", ans); return 0; }","link":"/2019/02/01/CF757F/"},{"title":"「云玩家拯救计划」小题单","text":"云玩家拯救计划（雾 网络流A(CF1009G)：直接贪心，用二分图里的一个霍尔定理来判断合法性。实现上可以简单一点。 B(CF808F)：先二分答案，观察到除了 2 以外所有质数由偶数+奇数得来。于是 check 就可以特判 1 + 1 的情况，建图最小割即可。 C(CF164C)：把任务按照开始时间排序，S -&gt; 最小的开始时间 -&gt; 第二个 -&gt; .. -&gt; 第 n 个 -&gt; T 连流量 m 费用 0 ，再对于每个任务连一条从起点到终点加 1，流量 1 费用 -c 的边。然后最小费用最大流就好了。我还是不会输出方案（捂脸 D(CF277E)：以前做过…写过题解… E(CF1082G)：把每个点和每条边算成一个点，边的权值是负的，然后最大权闭合子图 F(BZOJ3158)： 考虑 % 4 可以证明奇数方+奇数方不等于完全平方，同时偶数的最大公约数 &gt; 1 所以奇数一边偶数一边建二分图然后就是套路的最小割了G(CF863F)：可以求出每个点的可行区间，然后那个平方的条件就可以拆边。就是 (1,1), (3,1), (5,1), (7,1) …. 然后最小费用最大流 H(CF498C)：显然除质因子答案最大 &amp;&amp; 质因子之间相互独立。对于每一个出现过的质因子跑最大流就行了 数论A(BZOJ2154) ：不妨设 $n \\leq m$ $\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m} lcm(i, j)$ $=\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m} \\frac{ij}{\\gcd(i,j)}$ $=\\sum\\limits_{d=1}^{n}\\sum\\limits_{i’=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum\\limits_{j’=1}^{\\lfloor \\frac{m}{d} \\rfloor} i’j’d [\\gcd(i’,j’)=1]$ $=\\sum\\limits_{d=1}^{n}d \\sum\\limits_{i’=1}^{\\lfloor \\frac{n}{d} \\rfloor} i’ \\sum\\limits_{j’=1}^{\\lfloor \\frac{m}{d} \\rfloor} j’ [gcd(i’,j’)=1]$ $ =\\sum\\limits_{d=1}^{n} d \\sum\\limits_{i’=1}^{\\lfloor \\frac{n}{d} \\rfloor} i’ \\sum\\limits_{j’=1}^{\\lfloor \\frac{m}{d} \\rfloor} j’ \\sum\\limits_{d’|i’,d’|j’}\\mu(d’)$ $=\\sum\\limits_{d=1}^{n}\\sum\\limits_{d’=1}^{n}\\mu(d’)d \\sum\\limits_{i’=1}^{\\lfloor \\frac{n}{d’d} \\rfloor} i’ \\sum\\limits_{j’=1}^{\\lfloor \\frac{m}{d’d} \\rfloor} j’ $ 令 $dd’=T, F(T)=\\sum\\limits_{d | T}\\mu(d)\\frac{T}{d}$ 。F 可以线性筛出来，就做完了 ） 然后这个题连分块都不用（ 好像有需要分块的加强版被权限了（ B(BZOJ2440)：题解 C(BZOJ3529)：题解 D(HDU6053)： 待填坑 E(BZOJ2956)： $\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} i\\not= j(m\\%j)$ $=\\sum\\limits_{i=1}^{n}n\\%i\\sum\\limits_{j=1}^{m}m\\%j-\\sum\\limits_{i=1}^{n}(n\\%i)(m\\%i)$ 然后把 $n\\%i$ 搞成 $n -i \\lfloor\\frac{n}{i}\\rfloor $ ，$m\\%i$ 同理，然后推推式子分个块就做完了 F(HDU4947)：待填坑 G(BZOJ2005)：有点简单懒得写hhh H(HDU4473)：把题目要求转化为有多少个有序对 (a,b,c) 满足 abc = n。然后分三类 a,b,c;a,a,b;a,a,a 讨论下就行了（优秀的暴力… I(HDU5942)：有点难啊…看的 这个题解 线段树主席树A(HDU4578)：线段树维护加标记乘标记以及三个值分别表示和，平方的和，立方的和。加标记更新就用二项式展开一下倒序更新；乘标记就是和乘上d，平方乘上d^2，立方同理…然后覆盖操作拆成先乘 0 再加 。 B(BZOJ1818)：先把题目条件转化成所有由这些点组成的平行于坐标轴的线段之间有几个交点（端点也算）。然后就直接把坐标离散化一下然后扫描线扫过去中间用树状数组维护一下就行了。 C(COT)：板子再见 D(BZOJ3261)：搞个可持久化 0/1 trie 维护前缀异或和然后就做完了（板子） E(CF484E)：二分答案下，然后对于一个值是否合法只需要把 &gt; 该数的变成 1 ，小于该数的变成 0 然后用线段树维护这个区间内的最长的 1 序列。由于不能开一堆线段树，所以用主席数的思想就行了（我都觉得我说的不清楚…） F()： G：线段树合并裸题 H：kruskal 重构树上主席树 I：对每一位维护线段树就行了 J：压个位然后维护区间或就行了 K：模板题再见","link":"/2019/02/02/Cloud-Player-Rescue-Plan/"},{"title":"LOJ2174 「FJOI2016」神秘数","text":"Description$n$ 个数的序列，每次询问一个区间，求最小的一个数使得不能用这个区间中的数之和表示。 $n \\leq 10^5, \\sum a_i \\leq 10^9$ Solution第一次用数组写数据结构真短啊 考虑只有一次询问怎么做 把给定的区间内的数排序，从小到大扫一遍。 如果一个数比他之前的数之和至少大了 $1$ ，那么答案就是和 + 1 否则就可以把$[1,\\text{前缀和}]$ 都表示出来（感性理解很容易） 这道题怎么做也就显然了起来。只需要用主席树维护区间中小于等于某个数的数之和即可。流程如下 当前答案是 $a$，令 $S$ 是区间中 $\\leq a$ 的数之和 如果 $S &lt; a$ 则 $a$ 就是最后的答案 否则 让 $a = S+1$ 然后重复此操作 最开始的时候 $a=1$ 这样做的话 $a$ 每次都会翻一倍，所以最后的总复杂度是 $O(m \\log n \\log \\sum a_i)$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 50000500; const int L = 1000000000; int n, m, a[N], cnt; int root[N], ch[N][2]; ll sum[N]; inline void I (int pre, int now, int l, int r, int val) { ch[now][0] = ch[pre][0], ch[now][1] = ch[pre][1]; int mid = (l + r) &gt;&gt; 1; sum[now] = sum[pre] + val; if(l == r) return ; if(val &lt;= mid) ch[now][0] = ++cnt, I(ch[pre][0], ch[now][0], l, mid, val); else ch[now][1] = ++cnt, I(ch[pre][1], ch[now][1], mid + 1, r, val); }inline int Q(int pre, int now, int l, int r, int val) { if(l == r) return sum[now] - sum[pre]; int mid = (l + r) / 2; if(val &lt;= mid) return Q(ch[pre][0], ch[now][0], l, mid, val); else return sum[ch[now][0]] - sum[ch[pre][0]] + Q(ch[pre][1], ch[now][1], mid + 1, r, val); }int main() { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); root[i] = ++cnt; I(root[i - 1], root[i], 1, L, a[i]); } scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) { int l, r; scanf(\"%d %d\", &amp;l, &amp;r); int ans = 1; int S; while(1) { S = Q(root[l - 1], root[r], 1, L, ans); if(S &lt; ans) { printf(\"%d\\n\", ans); break ; } else ans = S + 1; } } return 0; }","link":"/2019/01/17/LOJ2174/"},{"title":"趣题「红眼睛与蓝眼睛」","text":"一道有趣的题目。 Description一个岛上有 $n$ 个人，其中有 $m$ 个红眼睛，$n - m$ 个蓝眼睛。这个岛有三个规则 他们不能照镜子，不能看自己眼睛的颜色。 他们不能告诉别人对方的眼睛是什么颜色。 一旦有人知道了自己是红眼睛，他就会在当天夜里自杀。 如果有一天，一个外来人来到这里对他们所有人说「你们这里有红眼睛的人」 假设每一个人都有着极强的逻辑推理能力。 求证：在这句话公布后地第 $m$ 天晚上这 $m$ 个红眼睛会一起自杀。 注：每一个人是不知道岛上有多少个红眼睛的人的 Solution乍一看，这题毫无头绪。告诉了一句「你们这里有红眼睛的人」又能怎么样呢？ 先来看一个数学归纳法的证明： 如果这个岛上只有一个红眼睛，听到这句话后看到其他人都不是红眼睛，便意识到自己是红眼睛，当天自杀。 假设当这个岛上有 $m$ 个红眼睛，他们会在第 $m$ 天自杀成立 当有 $m + 1$ 个红眼睛的时候，在每个红眼睛看来，都有 $m$ 个红眼睛，这个红眼睛能够推理出如果他不是红眼睛，那么他看到的 $m$ 个红眼睛都会在第 $m$ 天自杀 。而在第 $m$ 天，没有人自杀。一到第 $m + 1$ 天，每个红眼睛都意识到他是红眼睛。于是都在第 $m + 1$ 天自杀了 命题得证。看似没有问题，实际上，除了 $m = 1$ 的情况，这句话就相当于废话。因为没有任何用 要么在这之前红眼睛早就死光了，要么根本就不会死人。 但这并不是一个错误的事情。一个大神的回答说出来了 戳这里 这句话的作用就在于，让 每个人都知道每个人都知道这里有红眼睛的人 进一步地，这句话让 每个人都每个人都知道每个人都知道这里有红眼睛的人 等等 引用这位大神的话，就是： 简单说，「岛上有红眼睛」这件事本来只是一项「共有知识」（Mutual knowledge），公开宣告使它变成了一项「公共知识」（Common knowledge）。这两种知识的区分在认知逻辑里面非常重要，在博弈论中有广泛的应用。 用不严谨的话粗略介绍一下这两个概念：对于一个给定的命题P和一群给定的人，共有知识只需要满足一个条件：这群人中所有人都知道P，那么P就是这群人的共有知识。公共知识则需要满足以下所有条件：这群人中1、所有人都知道P；2、所有人都知道所有人都知道P；3、所有人都知道所有人都知道所有人都知道P；4、所有人都知道所有人都知道所有人都知道所有人都知道P；5、…… 共有知识 转化成 公共知识 的影响是很大的，就像这个例子一样 共有知识 转化成 公共知识 也是很难的，所以累次这个例子不太可能实现 同时这句话也统一了所有人的时间起点，时间在推理中扮演者重要的角色。这句话也让每一个人知道别人也知道这个时间起点 ，这样才有 “第 $m$ 天” 这种说法能够统一（就像人的出生时间不同，自然不能做出有效的推理","link":"/2019/01/23/Red-And-Blue-Eye/"},{"title":"BZOJ3529 「SDOI2014」数表","text":"Description$T$ 组询问，定义 $F(n)=\\sum\\limits_{d|n}d$。每次给出 $n,m,a$ 求 $$\\sum\\limits_{i=1,j=1,F(\\gcd(i,j)) \\leq a}^{i\\leq n, j \\leq m} F (\\gcd(i,j))$$ $T \\leq 20000;n,m,a\\leq 10^5$ Solution首先 $F$ 可以直接暴力地 $O(n \\log n)$ 筛出来。 考虑 $a$ 的限制不是很好处理，假设没有这个 $a$ 的限制，则所求为 $$\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m} F (\\gcd(i,j))$$ 令 $G(i)=\\sum\\limits_{x=1}^{n}\\sum\\limits_{y=1}^{m}[\\gcd(x,y)=i]$。这个东西是什么呢？在 这里 有它的推导过程。根据里面的过程，可以得到 $G(i) = \\sum\\limits_{d=1}^{\\lfloor\\frac{n}{i}\\rfloor}\\mu(d)\\lfloor\\frac{n}{id}\\rfloor\\lfloor\\frac{m}{id}\\rfloor$（默认 $n \\leq m$）令下面的过程中$t = id$，则所求的是 $$\\sum\\limits_{i=1}^{n}F(i)G(i)$$ $$= \\sum\\limits_{i=1}^{n}F(i)\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{i}\\rfloor}\\mu(d)\\lfloor\\frac{n}{id}\\rfloor\\lfloor\\frac{m}{id}\\rfloor $$ $$=\\sum\\limits_{i=1}^{n}F(i)\\sum\\limits_{i | t}\\mu(\\frac{t}{i})\\lfloor\\frac{n}{t}\\rfloor\\lfloor\\frac{m}{t}\\rfloor$$ $$=\\sum\\limits_{t=1}^{n}\\lfloor\\frac{n}{t}\\rfloor\\lfloor\\frac{m}{t}\\rfloor\\sum\\limits_{i | t}F(i)\\mu(\\frac{t}{i})$$ 观察后面的式子，正好是一个狄利克雷卷积的形式。这种样子的都可以类似于那种 $O(n \\log n)$ 地质数筛法在调和级数内求出来，再结合分块就可以做完这个没有 $a$ 的题。 现在有了 $a$ 的限制之后，离线。把询问按照 $a$ 从小到大排序，然后按照 $F(i)$ 从小到大加入。每当有一个新的 $a$ ，就可以移动指针，将一些 $F$ 用处理 $\\sum\\limits_{i | t}F(i)\\mu(\\frac{t}{i})$ 的方式加入到这个里面。然后加入完之后用分块计算就行。 现在需要维护单点操作，查询前缀和，树状数组是不错的选择。 由于取模是 $2^{32} - 1$ ，可以直接 int 自然溢出最后和 $2147483647$ 取一个 &amp; 就行了。 时间复杂度：$O(n + n \\log n + n \\log ^ 2 (n) + T \\log (n)\\sqrt n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000; int T, cnt, flag[N + 5], p[N + 5], F[N + 5], mu[N + 5], ans[N + 5]; inline void prework() { flag[1] = mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!flag[i]) { p[++cnt] = i, mu[i] = -1; } for(int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= N; j++) { flag[i * p[j]] = 1; if(i % p[j] == 0) { mu[i * p[j]] = 0; break ; } mu[i * p[j]] = mu[i] * -1; } } for(int i = 1; i &lt;= N; i++) for(int j = i; j &lt;= N; j += i) F[j] += i;}int c[N + 5]; inline int lb(int x) { return x &amp; (-x); }inline void add(int x, int d) { for(int i = x; i &lt;= N; i += lb(i)) c[i] += d; }inline int sum(int x) { int ret = 0; for(int i = x; i; i -= lb(i)) ret += c[i]; return ret; }inline int calc(int n, int m) { int ret = 0; for(int l = 1, r; l &lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); ret += (n / l) * (m / l) * (sum(r) - sum(l - 1)); } return ret; }struct Query { int n, m, a, id; inline bool operator &lt; (const Query &amp;x) const { return a &lt; x.a; }}Q[N + 5]; struct node { int id, d; inline bool operator &lt; (const node &amp;x) const { return d &lt; x.d; }}A[N + 5]; int main() { prework(); scanf(\"%d\", &amp;T); for(int i = 1; i &lt;= T; i++) scanf(\"%d %d %d\", &amp;Q[i].n, &amp;Q[i].m, &amp;Q[i].a), Q[i].id = i; for(int i = 1; i &lt;= N; i++) A[i].d = F[i], A[i].id = i; sort(Q + 1, Q + T + 1); sort(A + 1, A + N + 1); int pos = 0; for(int i = 1; i &lt;= T; i++) { while(pos &lt; N &amp;&amp; A[pos + 1].d &lt;= Q[i].a) { ++pos; for(int j = 1; A[pos].id * j &lt;= N; j++) add(j * A[pos].id, A[pos].d * mu[j]); } ans[Q[i].id] = calc(Q[i].n, Q[i].m); } for(int i = 1; i &lt;= T; i++) printf(\"%d\\n\", ans[i] &amp; 2147483647); return 0; }","link":"/2019/01/14/bzoj3529/"}],"tags":[{"name":"主席树","slug":"主席树","link":"/tags/主席树/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"dfs序","slug":"dfs序","link":"/tags/dfs序/"},{"name":"支配树","slug":"支配树","link":"/tags/支配树/"},{"name":"倍增","slug":"倍增","link":"/tags/倍增/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"博弈论","slug":"博弈论","link":"/tags/博弈论/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/莫比乌斯反演/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"趣题","slug":"趣题","link":"/categories/趣题/"}]}