<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CF757F Team Rocket Rises Again</title>
      <link href="/2019/02/01/CF757F/"/>
      <url>/2019/02/01/CF757F/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个 $n$ 个点 $m$ 条边的无向图，给出起点 $S$ 。求删除掉一个不是 $S$ 的点后最多能改变多少个点到 $S$ 的最短路。输出这个最大值。</p><p>$n \leq 200000, m \leq \min(\frac{n(n-1)}{2},300000)$ </p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>在飞机上写的题解 2333</p><p>定义 $d_u$ 是 $S$ 到 $u$ 的最短路；最短路 DAG 为所有有向边 $(u,v)$ 满足 $d_u+w(u,v)=d_v$ 组成的 DAG .</p><p>那么显然删这个 DAG 上的点才是对答案有贡献的。</p><p>考虑如何求出删完一个点会使得有多少个点的最短路有改变。</p><p>把这个 DAG 的支配树建出来然后对于一个点它在支配树上的子树大小就是答案。</p><p>注：支配树是啥？</p><p>在一个有向图中有一个节点是 $S$ ；对于节点 $u$ 从 $S$ 到 $u$ 上的路径必到的点称之为 $u$ 的支配点</p><p>对于每一个 $u$ ，从离他最近的一个点向他连一条边。这些边组成的便是原图的支配树。其中 $S$ 为根节点</p><p>对于一个 DAG 如何建出他的支配树？即对于一个点怎么求出离他最近的支配点？</p><p>可以考虑用拓扑排序的顺序更新。对于节点 $u$ ，它的所有前驱在支配树上的 LCA便是它在支配树上的父亲；即离他最近的支配点。</p><p>这个过程需要维护的就是 加点 和 维护 LCA 。可以用倍增用 $O(n \log n)$ 的时间复杂度解决</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long <span class="hljs-comment">// don't think I use int ! </span></span></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">300300</span>; </span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = (<span class="hljs-keyword">int</span>)<span class="hljs-number">4e18</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> n, m, S, dis[N], U[N], V[N], W[N], ind[N], fa[N][<span class="hljs-number">25</span>], dep[N], siz[N]; </span><br><span class="line"><span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; g[N]; </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> v, w; edge *next; </span><br><span class="line">&#125; *h1[N], *h2[N], *h3[N], pool[N * <span class="hljs-number">6</span>], *cur = pool; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++; p-&gt;w = w; </span><br><span class="line">  p-&gt;v = v, p-&gt;next = h1[u], h1[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++;</span><br><span class="line">  p-&gt;v = v, p-&gt;next = h2[u], h2[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  edge *p = cur++;</span><br><span class="line">  p-&gt;v = v, p-&gt;next = h3[u], h3[u] = p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  fa[x][<span class="hljs-number">0</span>] = f;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++)</span><br><span class="line">    fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>]; </span><br><span class="line">  dep[x] = dep[f] + <span class="hljs-number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">    <span class="hljs-keyword">if</span>(dep[fa[u][i]] &gt;= dep[v] &amp;&amp; fa[u][i])</span><br><span class="line">      u = fa[u][i]; </span><br><span class="line">  <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span> u; </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--)</span><br><span class="line">    <span class="hljs-keyword">if</span>(fa[u][i] != fa[v][i])</span><br><span class="line">      u = fa[u][i], v = fa[v][i];</span><br><span class="line">  <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> d, id; </span><br><span class="line">  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;x) <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> d &gt; x.d; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; tmp; </span><br><span class="line">priority_queue &lt;node&gt; Q; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">    dis[i] = INF;</span><br><span class="line">  tmp.id = S, tmp.d = <span class="hljs-number">0</span>; Q.push(tmp); dis[S] = <span class="hljs-number">0</span>; </span><br><span class="line">  <span class="hljs-keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    tmp = Q.top(); Q.pop();</span><br><span class="line">    <span class="hljs-keyword">int</span> u = tmp.id;</span><br><span class="line">    <span class="hljs-keyword">if</span>(dis[u] &lt; tmp.d) <span class="hljs-keyword">continue</span> ; </span><br><span class="line">    <span class="hljs-keyword">for</span>(edge *p = h1[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> v = p-&gt;v; </span><br><span class="line">      <span class="hljs-keyword">if</span>(dis[v] &gt; dis[u] + p-&gt;w) &#123;</span><br><span class="line">        dis[v] = dis[u] + p-&gt;w; </span><br><span class="line">        tmp.id = v, tmp.d = dis[v];</span><br><span class="line">        Q.push(tmp); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">  siz[u] = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(edge *p = h3[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> v = p-&gt;v; <span class="hljs-keyword">if</span>(v == pre) <span class="hljs-keyword">continue</span> ; </span><br><span class="line">    dfs(v, u); siz[u] += siz[v]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld %lld %lld"</span>, &amp;n, &amp;m, &amp;S);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> u, v, w;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld %lld %lld"</span>, &amp;u, &amp;v, &amp;w); </span><br><span class="line">    U[i] = u, V[i] = v, W[i] = w; </span><br><span class="line">    add1(u, v, w), add1(v, u, w); </span><br><span class="line">  &#125;</span><br><span class="line">  dijkstra(); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(dis[U[i]] == dis[V[i]] + W[i])</span><br><span class="line">      add2(V[i], U[i]), ind[U[i]]++, g[U[i]].push_back(V[i]);</span><br><span class="line">    <span class="hljs-keyword">if</span>(dis[V[i]] == dis[U[i]] + W[i])</span><br><span class="line">      add2(U[i], V[i]), ind[V[i]]++, g[V[i]].push_back(U[i]); </span><br><span class="line">  &#125; <span class="hljs-built_in">queue</span> &lt;<span class="hljs-keyword">int</span>&gt; Q; Q.push(S); dep[S] = <span class="hljs-number">1</span>; </span><br><span class="line">  <span class="hljs-keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">    <span class="hljs-comment">// printf("%d\n", u); </span></span><br><span class="line">    <span class="hljs-keyword">if</span>(g[u].size()) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> lca = g[u][<span class="hljs-number">0</span>];</span><br><span class="line">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; g[u].size(); i++) &#123;</span><br><span class="line">       <span class="hljs-comment">// printf("%d\n", g[u][i]); </span></span><br><span class="line">        lca = LCA(g[u][i], lca);</span><br><span class="line">      &#125; </span><br><span class="line">      add(u, lca); add3(lca, u); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(edge *p = h2[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> v = p-&gt;v; ind[v]--;</span><br><span class="line">      <span class="hljs-keyword">if</span>(ind[v] == <span class="hljs-number">0</span>) Q.push(v); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;  </span><br><span class="line">  dfs(S, <span class="hljs-number">0</span>); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="hljs-keyword">if</span>(i != S) ans = max(ans, siz[i]); </span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans); </span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 支配树 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>趣题「红眼睛与蓝眼睛」</title>
      <link href="/2019/01/23/Red-And-Blue-Eye/"/>
      <url>/2019/01/23/Red-And-Blue-Eye/</url>
      
        <content type="html"><![CDATA[<p>一道有趣的题目。</p><a id="more"></a> <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个岛上有 $n$ 个人，其中有 $m$ 个红眼睛，$n -  m$ 个蓝眼睛。这个岛有三个规则</p><ol><li>他们不能照镜子，不能看自己眼睛的颜色。</li><li>他们不能告诉别人对方的眼睛是什么颜色。</li><li>一旦有人知道了自己是红眼睛，他就会在当天夜里自杀。</li></ol><p>如果有一天，一个外来人来到这里对他们所有人说「你们这里有红眼睛的人」</p><p>假设每一个人都有着极强的逻辑推理能力。 </p><p>求证：在这句话公布后地第 $m$ 天晚上这 $m$ 个红眼睛会一起自杀。</p><p>注：每一个人是不知道岛上有多少个红眼睛的人的</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>乍一看，这题毫无头绪。告诉了一句「你们这里有红眼睛的人」又能怎么样呢？</p><p>先来看一个数学归纳法的证明：</p><ol><li><p>如果这个岛上只有一个红眼睛，听到这句话后看到其他人都不是红眼睛，便意识到自己是红眼睛，当天自杀。</p></li><li><p>假设当这个岛上有 $m$ 个红眼睛，他们会在第 $m$ 天自杀成立</p><p>当有 $m + 1$ 个红眼睛的时候，在每个红眼睛看来，都有 $m$ 个红眼睛，这个红眼睛能够推理出如果他不是红眼睛，那么他看到的 $m$ 个红眼睛都会在第 $m$ 天自杀 。而在第 $m$ 天，没有人自杀。一到第 $m + 1$ 天，每个红眼睛都意识到他是红眼睛。于是都在第 $m + 1$ 天自杀了</p></li></ol><p>命题得证。看似没有问题，实际上，除了 $m = 1$  的情况，这句话就相当于废话。因为没有任何用</p><p>要么在这之前红眼睛早就死光了，要么根本就不会死人。</p><p>但这并不是一个错误的事情。一个大神的回答说出来了 <a href="https://www.zhihu.com/question/21262930/answer/17690897" target="_blank" rel="noopener">戳这里</a> </p><p>这句话的作用就在于，让 <strong>每个人都知道每个人都知道这里有红眼睛的人</strong> </p><p>进一步地，这句话让  <strong>每个人都每个人都知道每个人都知道这里有红眼睛的人</strong>  等等</p><p>引用这位大神的话，就是：</p><blockquote><p>简单说，「岛上有红眼睛」这件事本来只是一项「<strong>共有知识</strong>」（<a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Mutual_knowledge_%2528logic%2529" target="_blank" rel="noopener">Mutual knowledge</a>），公开宣告使它变成了一项「<strong>公共知识</strong>」（<a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Common_knowledge_%2528logic%2529" target="_blank" rel="noopener">Common knowledge</a>）。这两种知识的区分在认知逻辑里面非常重要，在博弈论中有广泛的应用。</p></blockquote><blockquote><p>用不严谨的话粗略介绍一下这两个概念：对于一个给定的命题P和一群给定的人，共有知识只需要满足一个条件：这群人中所有人都知道P，那么P就是这群人的共有知识。<br>公共知识则需要满足以下所有条件：<br>这群人中<br>1、所有人都知道P；<br>2、所有人都知道所有人都知道P；<br>3、所有人都知道所有人都知道所有人都知道P；<br>4、所有人都知道所有人都知道所有人都知道所有人都知道P；<br>5、……</p></blockquote><p>共有知识 转化成 公共知识 的影响是很大的，就像这个例子一样</p><p>共有知识 转化成 公共知识 也是很难的，所以累次这个例子不太可能实现</p><hr><p>同时这句话也统一了所有人的<strong>时间起点</strong>，时间在推理中扮演者重要的角色。这句话也让每一个人知道别人也知道这个时间起点 ，这样才有 “第 $m$ 天” 这种说法能够统一（就像人的出生时间不同，自然不能做出有效的推理</p>]]></content>
      
      
      <categories>
          
          <category> 趣题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2653 middle</title>
      <link href="/2019/01/20/BZOJ2653/"/>
      <url>/2019/01/20/BZOJ2653/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给你一个序列，每次询问给出四个数 $a,b,c,d$，求所有区间 $[l,r]$ 满足 $l \in [a,b], r \in [c,d]$ 的中位数的最大值。强制在线。</p><p>$n \leq 20000, Q \leq 25000,a_i \leq 10^9$</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑二分答案。假设现在二分出来的是 $x$ ，那么把 $\ge x$ 的位置设成 $1$ ，$&lt; x$ 的设为 $-1$ 。那么一个区间的中位数 $\ge x$ 等价于这个区间的和 $\ge 0$</p><p>如何处理题目给的左右端点的限制？</p><p>可以发现 $[l,r]$ 必然包含 $[b+1,c-1]$ (如果 $b+1 \leq c+1$ 的话）所以 $[l, r]$ 的和必然包含 $[b+1, c-1]$ 的和</p><p>显然让 $[l,r]$ 的和最大的方案是取 $[a,b]$ 的最大右段和 和 $[c,d]$ 的最大左段和</p><p>这些都可以用线段树维护。但这样需要每个数都开一颗线段树，空间爆炸。</p><p>把数组排序，这样每个数的线段树显然只是由前一个数的线段树把一个点的权值从 $1$ 改为 $-1$ 。可以使用主席树的思想（貌似就是主席树</p><p>然后就做完了。复杂度 $O(m \log^2 n)$ </p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2000</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> n, m; <span class="hljs-keyword">int</span> q[<span class="hljs-number">4</span>]; </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> d, id; </span><br><span class="line">&#125; a[N]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node x, Node y)</span> </span>&#123; </span><br><span class="line">  <span class="hljs-keyword">return</span> x.d &lt; y.d; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> left, right; </span><br><span class="line">  <span class="hljs-keyword">int</span> sm, lm, rm; </span><br><span class="line">  node *ch[<span class="hljs-number">2</span>]; </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sm = ch[<span class="hljs-number">0</span>]-&gt;sm + ch[<span class="hljs-number">1</span>]-&gt;sm; </span><br><span class="line">    lm = max(ch[<span class="hljs-number">0</span>]-&gt;lm, ch[<span class="hljs-number">0</span>]-&gt;sm + ch[<span class="hljs-number">1</span>]-&gt;lm);</span><br><span class="line">    rm = max(ch[<span class="hljs-number">1</span>]-&gt;rm, ch[<span class="hljs-number">1</span>]-&gt;sm + ch[<span class="hljs-number">0</span>]-&gt;rm); </span><br><span class="line">  &#125;</span><br><span class="line">&#125; *rt[N], pool[N * <span class="hljs-number">50</span>], *cur = pool, *ans; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B</span> <span class="hljs-params">(node *r, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123; </span><br><span class="line">  r-&gt;left = left, r-&gt;right = right; </span><br><span class="line">  <span class="hljs-keyword">if</span>(left == right) &#123; r-&gt;sm = r-&gt;lm = r-&gt;rm = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> ; &#125;</span><br><span class="line">  node *lson = cur++, *rson = cur++; </span><br><span class="line">  <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">  r-&gt;ch[<span class="hljs-number">0</span>] = lson, r-&gt;ch[<span class="hljs-number">1</span>] = rson;</span><br><span class="line">  B(lson, left, mid), B(rson, mid + <span class="hljs-number">1</span>, right);  r-&gt;upd(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">I</span> <span class="hljs-params">(node *pre, node *now, <span class="hljs-keyword">int</span> pos)</span> </span>&#123; </span><br><span class="line">  now-&gt;left = pre-&gt;left, now-&gt;right = pre-&gt;right; </span><br><span class="line">  <span class="hljs-keyword">if</span>(now-&gt;left == now-&gt;right) &#123;</span><br><span class="line">    now-&gt;sm = now-&gt;lm = now-&gt;rm = <span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span> ; </span><br><span class="line">  &#125; <span class="hljs-keyword">int</span> mid = (pre-&gt;left + pre-&gt;right) &gt;&gt; <span class="hljs-number">1</span>; </span><br><span class="line">  <span class="hljs-keyword">if</span>(pos &lt;= mid) now-&gt;ch[<span class="hljs-number">1</span>] = pre-&gt;ch[<span class="hljs-number">1</span>], I(pre-&gt;ch[<span class="hljs-number">0</span>], now-&gt;ch[<span class="hljs-number">0</span>] = cur++, pos); </span><br><span class="line">  <span class="hljs-keyword">if</span>(pos &gt;  mid) now-&gt;ch[<span class="hljs-number">0</span>] = pre-&gt;ch[<span class="hljs-number">0</span>], I(pre-&gt;ch[<span class="hljs-number">1</span>], now-&gt;ch[<span class="hljs-number">1</span>] = cur++, pos); </span><br><span class="line">  now-&gt;upd(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> node* <span class="hljs-title">Q</span> <span class="hljs-params">(node *now, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(now-&gt;left == l &amp;&amp; now-&gt;right == r) <span class="hljs-keyword">return</span> now; </span><br><span class="line">  <span class="hljs-keyword">if</span>(now-&gt;ch[<span class="hljs-number">0</span>]-&gt;right &gt;= r) <span class="hljs-keyword">return</span> Q(now-&gt;ch[<span class="hljs-number">0</span>], l, r);</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(now-&gt;ch[<span class="hljs-number">1</span>]-&gt;left &lt;= l) <span class="hljs-keyword">return</span> Q(now-&gt;ch[<span class="hljs-number">1</span>], l, r); </span><br><span class="line">  <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    node *ret = cur++, *L, *R;</span><br><span class="line">    L = Q(now-&gt;ch[<span class="hljs-number">0</span>], l, now-&gt;ch[<span class="hljs-number">0</span>]-&gt;right);</span><br><span class="line">    R = Q(now-&gt;ch[<span class="hljs-number">1</span>], now-&gt;ch[<span class="hljs-number">1</span>]-&gt;left, r);</span><br><span class="line">    ret-&gt;sm = L-&gt;sm + R-&gt;sm; </span><br><span class="line">    ret-&gt;lm = max(L-&gt;lm, L-&gt;sm + R-&gt;lm);</span><br><span class="line">    ret-&gt;rm = max(R-&gt;rm, R-&gt;sm + L-&gt;rm); </span><br><span class="line">    <span class="hljs-keyword">return</span> ret; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span>(q[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span> &lt;= q[<span class="hljs-number">3</span>] - <span class="hljs-number">1</span>) sum += Q (rt[id - <span class="hljs-number">1</span>], q[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>, q[<span class="hljs-number">3</span>] - <span class="hljs-number">1</span>)-&gt;sm; </span><br><span class="line">  sum += Q (rt[id - <span class="hljs-number">1</span>], q[<span class="hljs-number">1</span>], q[<span class="hljs-number">2</span>])-&gt;rm; </span><br><span class="line">  sum += Q (rt[id - <span class="hljs-number">1</span>], q[<span class="hljs-number">3</span>], q[<span class="hljs-number">4</span>])-&gt;lm; </span><br><span class="line">  <span class="hljs-keyword">return</span> sum &gt;= <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i].d); </span><br><span class="line">    a[i].id = i; </span><br><span class="line">  &#125; sort(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, cmp);</span><br><span class="line">  B(rt[<span class="hljs-number">0</span>] = cur++, <span class="hljs-number">1</span>, n); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    rt[i] = cur++; I(rt[i - <span class="hljs-number">1</span>], rt[i], a[i].id);  </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">4</span>; j++) &#123;</span><br><span class="line">      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;q[j]), </span><br><span class="line">      q[j] += ans, q[j] %= n; q[j]++; </span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="hljs-number">1</span>, q + <span class="hljs-number">4</span> + <span class="hljs-number">1</span>); </span><br><span class="line">    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n; </span><br><span class="line">    <span class="hljs-keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>; </span><br><span class="line">      <span class="hljs-keyword">if</span>(check(mid)) l = mid + <span class="hljs-number">1</span>, ans = a[mid].d; </span><br><span class="line">      <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; </span><br><span class="line">    &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOJ2174 「FJOI2016」神秘数</title>
      <link href="/2019/01/17/LOJ2174/"/>
      <url>/2019/01/17/LOJ2174/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>$n$ 个数的序列，每次询问一个区间，求最小的一个数使得不能用这个区间中的数之和表示。</p><p>$n \leq 10^5, \sum a_i \leq 10^9$</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><del>第一次用数组写数据结构真短啊</del></p><p>考虑只有一次询问怎么做</p><p>把给定的区间内的数排序，从小到大扫一遍。</p><p>如果一个数比他之前的数之和至少大了 $1$ ，那么答案就是和 + 1</p><p>否则就可以把$[1,\text{前缀和}]$ 都表示出来（感性理解很容易）</p><p>这道题怎么做也就显然了起来。只需要用主席树维护区间中小于等于某个数的数之和即可。流程如下</p><p>当前答案是 $a$，令 $S$ 是区间中 $\leq a$ 的数之和  </p><ol><li>如果 $S &lt; a$ 则 $a$ 就是最后的答案</li><li>否则 让 $a = S+1$ 然后重复此操作</li></ol><p>最开始的时候 $a=1$</p><p>这样做的话 $a$ 每次都会翻一倍，所以最后的总复杂度是  $O(m \log n \log \sum a_i)$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50000500</span>; </span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> L = <span class="hljs-number">1000000000</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> n, m, a[N], cnt; </span><br><span class="line"><span class="hljs-keyword">int</span> root[N], ch[N][<span class="hljs-number">2</span>]; ll sum[N]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">I</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  ch[now][<span class="hljs-number">0</span>] = ch[pre][<span class="hljs-number">0</span>], ch[now][<span class="hljs-number">1</span>] = ch[pre][<span class="hljs-number">1</span>]; </span><br><span class="line">  <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; sum[now] = sum[pre] + val; <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> ; </span><br><span class="line">  <span class="hljs-keyword">if</span>(val &lt;= mid) ch[now][<span class="hljs-number">0</span>] = ++cnt, I(ch[pre][<span class="hljs-number">0</span>], ch[now][<span class="hljs-number">0</span>], l, mid, val);</span><br><span class="line">  <span class="hljs-keyword">else</span> ch[now][<span class="hljs-number">1</span>] = ++cnt, I(ch[pre][<span class="hljs-number">1</span>], ch[now][<span class="hljs-number">1</span>], mid + <span class="hljs-number">1</span>, r, val); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Q</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> sum[now] - sum[pre]; <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span>(val &lt;= mid) <span class="hljs-keyword">return</span> Q(ch[pre][<span class="hljs-number">0</span>], ch[now][<span class="hljs-number">0</span>], l, mid, val);</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> sum[ch[now][<span class="hljs-number">0</span>]] - sum[ch[pre][<span class="hljs-number">0</span>]] + Q(ch[pre][<span class="hljs-number">1</span>], ch[now][<span class="hljs-number">1</span>], mid + <span class="hljs-number">1</span>, r, val); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]); root[i] = ++cnt; </span><br><span class="line">    I(root[i - <span class="hljs-number">1</span>], root[i], <span class="hljs-number">1</span>, L, a[i]); </span><br><span class="line">  &#125; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m); </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> l, r; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;l, &amp;r); </span><br><span class="line">    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>; </span><br><span class="line">    <span class="hljs-keyword">int</span> S; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;</span><br><span class="line">      S = Q(root[l - <span class="hljs-number">1</span>], root[r], <span class="hljs-number">1</span>, L, ans); </span><br><span class="line">      <span class="hljs-keyword">if</span>(S &lt; ans) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans); <span class="hljs-keyword">break</span> ; &#125;</span><br><span class="line">      <span class="hljs-keyword">else</span> ans = S + <span class="hljs-number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3529 「SDOI2014」数表</title>
      <link href="/2019/01/14/bzoj3529/"/>
      <url>/2019/01/14/bzoj3529/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>$T$ 组询问，定义 $F(n)=\sum\limits_{d|n}d$。每次给出 $n,m,a$ 求  </p><p>$$\sum\limits_{i=1,j=1,F(\gcd(i,j)) \leq a}^{i\leq n, j \leq m} F (\gcd(i,j))$$</p><p>$T \leq 20000;n,m,a\leq 10^5$</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先 $F$ 可以直接暴力地 $O(n \log n)$ 筛出来。</p><p>考虑 $a$ 的限制不是很好处理，假设没有这个 $a$ 的限制，则所求为</p><p>$$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} F (\gcd(i,j))$$</p><p>令 $G(i)=\sum\limits_{x=1}^{n}\sum\limits_{y=1}^{m}[\gcd(x,y)=i]$。这个东西是什么呢？在 <a href="https://www.cnblogs.com/acfunction/p/10127599.html" target="_blank" rel="noopener">这里</a> 有它的推导过程。根据里面的过程，可以得到 $G(i) = \sum\limits_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)\lfloor\frac{n}{id}\rfloor\lfloor\frac{m}{id}\rfloor$（默认 $n \leq m$）<br>令下面的过程中$t = id$，则所求的是 </p><p>$$\sum\limits_{i=1}^{n}F(i)G(i)$$</p><p> $$= \sum\limits_{i=1}^{n}F(i)\sum\limits_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)\lfloor\frac{n}{id}\rfloor\lfloor\frac{m}{id}\rfloor $$</p><p>$$=\sum\limits_{i=1}^{n}F(i)\sum\limits_{i | t}\mu(\frac{t}{i})\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor$$</p><p>$$=\sum\limits_{t=1}^{n}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum\limits_{i | t}F(i)\mu(\frac{t}{i})$$</p><p>观察后面的式子，正好是一个狄利克雷卷积的形式。这种样子的都可以类似于那种 $O(n \log n)$ 地质数筛法在调和级数内求出来，再结合分块就可以做完这个没有 $a$ 的题。</p><p>现在有了 $a$ 的限制之后，离线。把询问按照 $a$ 从小到大排序，然后按照 $F(i)$ 从小到大加入。每当有一个新的 $a$ ，就可以移动指针，将一些 $F$ 用处理 $\sum\limits_{i | t}F(i)\mu(\frac{t}{i})$ 的方式加入到这个里面。然后加入完之后用分块计算就行。</p><p>现在需要维护单点操作，查询前缀和，树状数组是不错的选择。</p><p>由于取模是 $2^{32} - 1$ ，可以直接 int 自然溢出最后和 $2147483647$ 取一个 &amp; 就行了。</p><p>时间复杂度：$O(n + n \log n +  n \log ^ 2 (n) + T \log (n)\sqrt n)$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> T, cnt, flag[N + <span class="hljs-number">5</span>], p[N + <span class="hljs-number">5</span>], F[N + <span class="hljs-number">5</span>], mu[N + <span class="hljs-number">5</span>], ans[N + <span class="hljs-number">5</span>]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  flag[<span class="hljs-number">1</span>] = mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(!flag[i]) &#123; p[++cnt] = i, mu[i] = <span class="hljs-number">-1</span>; &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= N; j++) &#123;</span><br><span class="line">      flag[i * p[j]] = <span class="hljs-number">1</span>; <span class="hljs-keyword">if</span>(i % p[j] == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        mu[i * p[j]] = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span> ;</span><br><span class="line">      &#125; mu[i * p[j]] = mu[i] * <span class="hljs-number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt;= N; j += i) F[j] += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> c[N + <span class="hljs-number">5</span>]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lb</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i &lt;= N; i += lb(i)) c[i] += d; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i; i -= lb(i)) </span><br><span class="line">    ret += c[i]; <span class="hljs-keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r; l &lt;= min(n, m); l = r + <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    r = min(n / (n / l), m / (m / l)); </span><br><span class="line">    ret += (n / l) * (m / l) * (sum(r) - sum(l - <span class="hljs-number">1</span>)); </span><br><span class="line">  &#125; <span class="hljs-keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Query</span> &#123;</span> </span><br><span class="line">  <span class="hljs-keyword">int</span> n, m, a, id;</span><br><span class="line">  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Query &amp;x) <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a &lt; x.a; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;Q[N + <span class="hljs-number">5</span>]; </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> id, d; </span><br><span class="line">  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;x) <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> d &lt; x.d; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;A[N + <span class="hljs-number">5</span>]; </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  prework(); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;Q[i].n, &amp;Q[i].m, &amp;Q[i].a), Q[i].id = i; </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) A[i].d = F[i], A[i].id = i; </span><br><span class="line">  sort(Q + <span class="hljs-number">1</span>, Q + T + <span class="hljs-number">1</span>); sort(A + <span class="hljs-number">1</span>, A + N + <span class="hljs-number">1</span>); <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>; </span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">while</span>(pos &lt; N &amp;&amp; A[pos + <span class="hljs-number">1</span>].d &lt;= Q[i].a) &#123;</span><br><span class="line">      ++pos;</span><br><span class="line">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; A[pos].id * j &lt;= N; j++)</span><br><span class="line">        add(j * A[pos].id, A[pos].d * mu[j]);</span><br><span class="line">        </span><br><span class="line">    &#125; ans[Q[i].id] = calc(Q[i].n, Q[i].m); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans[i] &amp; <span class="hljs-number">2147483647</span>); </span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
